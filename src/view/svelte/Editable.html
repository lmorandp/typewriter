{#each entries as entry}
  {#if entry.lines}
    <svelte:component {entry.Component} lines={entry.lines} {markups} {embeds}/>
  {:else}
    <svelte:component {entry.Component} attributes={entry.line.attributes} contents={entry.line.contents} {markups} {embeds}/>
  {/if}
{/each}

<script>
import Paragraph from './Paragraph.html';
import Header from './Header.html';

export default {
  computed: {

    entries: ({ blocks, delta }) => {
      if (!blocks || !delta) return [];

      const lines = [];
      const components = [];

      delta.eachLine((contents, attributes) => {
        lines.push({
          attributes,
          contents
        });
        components.push(findComponent(blocks, attributes));
      });

      // Optimize. Components with a static preload method expect an array of lines of the same component that can be
      // combined. `preload` gives an opportunity for the component to decide which lines it will handle at once.
      // `preload` receives an array of all the lines it _might_ handle (those with the same component which are next to
      // each other) and should return an array of the lines it will handle, returning `lines` if it expects to handle
      // all the sibling lines. A component with preload will receive a property `lines` with those lines returned from
      // the `preload` method. A component without preload will receive the properties `attributes`, `contents`,
      // `markups`, and `embeds`.
      const entries = [];

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const Component = components[i];
        if (Component.preload) {
          let j = i + 1;
          while (components.length > j && components[j] === Component) j++;

          const handledLines = Component.preload(lines.slice(i, j));
          entries.push({ Component, lines: handledLines });
          i += handledLines.length - 1;
        } else {
          entries.push({ Component, line });
        }
      }

      return entries;
    }
  },

  data() {
    return {
      blocks: {
        default: Paragraph,
        header: Header,
      },
      markups: {

      },
      embeds: {

      },
    }
  },
}

function findType(blocks, attributes) {
  if (!attributes) return blocks.default;
  return blocks[Object.keys(attributes).find(name => name in blocks)] || blocks.default;
}
</script>