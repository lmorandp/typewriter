var app = (function () {
	'use strict';

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var internal = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });

	function noop() {}

	const identity = x => x;

	function assign(tar, src) {
		for (const k in src) tar[k] = src[k];
		return tar;
	}

	function is_promise(value) {
		return value && typeof value.then === 'function';
	}

	function add_location(element, file, line, column, char) {
		element.__svelte_meta = {
			loc: { file, line, column, char }
		};
	}

	function run(fn) {
		return fn();
	}

	function blank_object() {
		return Object.create(null);
	}

	function run_all(fns) {
		fns.forEach(run);
	}

	function is_function(thing) {
		return typeof thing === 'function';
	}

	function safe_not_equal(a, b) {
		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function not_equal(a, b) {
		return a != a ? b == b : a !== b;
	}

	function validate_store(store, name) {
		if (!store || typeof store.subscribe !== 'function') {
			throw new Error(`'${name}' is not a store with a 'subscribe' method`);
		}
	}

	function subscribe(component, store, callback) {
		component.$$.on_destroy.push(store.subscribe(callback));
	}

	function create_slot(definition, ctx, fn) {
		if (definition) {
			const slot_ctx = get_slot_context(definition, ctx, fn);
			return definition[0](slot_ctx);
		}
	}

	function get_slot_context(definition, ctx, fn) {
		return definition[1]
			? assign({}, assign(ctx.$$scope.ctx, definition[1](fn ? fn(ctx) : {})))
			: ctx.$$scope.ctx;
	}

	function get_slot_changes(definition, ctx, changed, fn) {
		return definition[1]
			? assign({}, assign(ctx.$$scope.changed || {}, definition[1](fn ? fn(changed) : {})))
			: ctx.$$scope.changed || {};
	}

	function exclude_internal_props(props) {
		const result = {};
		for (const k in props) if (k[0] !== '$') result[k] = props[k];
		return result;
	}

	const tasks = new Set();
	let running = false;

	function run_tasks() {
		tasks.forEach(task => {
			if (!task[0](window.performance.now())) {
				tasks.delete(task);
				task[1]();
			}
		});

		running = tasks.size > 0;
		if (running) requestAnimationFrame(run_tasks);
	}

	function clear_loops() {
		// for testing...
		tasks.forEach(task => tasks.delete(task));
		running = false;
	}

	function loop(fn) {
		let task;

		if (!running) {
			running = true;
			requestAnimationFrame(run_tasks);
		}

		return {
			promise: new Promise(fulfil => {
				tasks.add(task = [fn, fulfil]);
			}),
			abort() {
				tasks.delete(task);
			}
		};
	}

	function append(target, node) {
		target.appendChild(node);
	}

	function insert(target, node, anchor) {
		target.insertBefore(node, anchor);
	}

	function detach(node) {
		node.parentNode.removeChild(node);
	}

	function detach_between(before, after) {
		while (before.nextSibling && before.nextSibling !== after) {
			before.parentNode.removeChild(before.nextSibling);
		}
	}

	function detach_before(after) {
		while (after.previousSibling) {
			after.parentNode.removeChild(after.previousSibling);
		}
	}

	function detach_after(before) {
		while (before.nextSibling) {
			before.parentNode.removeChild(before.nextSibling);
		}
	}

	function destroy_each(iterations, detaching) {
		for (let i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d(detaching);
		}
	}

	function element(name) {
		return document.createElement(name);
	}

	function svg_element(name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	}

	function text(data) {
		return document.createTextNode(data);
	}

	function space() {
		return text(' ');
	}

	function empty() {
		return text('');
	}

	function listen(node, event, handler, options) {
		node.addEventListener(event, handler, options);
		return () => node.removeEventListener(event, handler, options);
	}

	function prevent_default(fn) {
		return function(event) {
			event.preventDefault();
			return fn.call(this, event);
		};
	}

	function stop_propagation(fn) {
		return function(event) {
			event.stopPropagation();
			return fn.call(this, event);
		};
	}

	function attr(node, attribute, value) {
		if (value == null) node.removeAttribute(attribute);
		else node.setAttribute(attribute, value);
	}

	function set_attributes(node, attributes) {
		for (const key in attributes) {
			if (key === 'style') {
				node.style.cssText = attributes[key];
			} else if (key in node) {
				node[key] = attributes[key];
			} else {
				attr(node, key, attributes[key]);
			}
		}
	}

	function set_custom_element_data(node, prop, value) {
		if (prop in node) {
			node[prop] = value;
		} else {
			attr(node, prop, value);
		}
	}

	function xlink_attr(node, attribute, value) {
		node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
	}

	function get_binding_group_value(group) {
		const value = [];
		for (let i = 0; i < group.length; i += 1) {
			if (group[i].checked) value.push(group[i].__value);
		}
		return value;
	}

	function to_number(value) {
		return value === '' ? undefined : +value;
	}

	function time_ranges_to_array(ranges) {
		const array = [];
		for (let i = 0; i < ranges.length; i += 1) {
			array.push({ start: ranges.start(i), end: ranges.end(i) });
		}
		return array;
	}

	function children(element) {
		return Array.from(element.childNodes);
	}

	function claim_element(nodes, name, attributes, svg) {
		for (let i = 0; i < nodes.length; i += 1) {
			const node = nodes[i];
			if (node.nodeName === name) {
				for (let j = 0; j < node.attributes.length; j += 1) {
					const attribute = node.attributes[j];
					if (!attributes[attribute.name]) node.removeAttribute(attribute.name);
				}
				return nodes.splice(i, 1)[0]; // TODO strip unwanted attributes
			}
		}

		return svg ? svg_element(name) : element(name);
	}

	function claim_text(nodes, data) {
		for (let i = 0; i < nodes.length; i += 1) {
			const node = nodes[i];
			if (node.nodeType === 3) {
				node.data = data;
				return nodes.splice(i, 1)[0];
			}
		}

		return text(data);
	}

	function set_data(text, data) {
		text.data = '' + data;
	}

	function set_input_type(input, type) {
		try {
			input.type = type;
		} catch (e) {
			// do nothing
		}
	}

	function set_style(node, key, value) {
		node.style.setProperty(key, value);
	}

	function select_option(select, value) {
		for (let i = 0; i < select.options.length; i += 1) {
			const option = select.options[i];

			if (option.__value === value) {
				option.selected = true;
				return;
			}
		}
	}

	function select_options(select, value) {
		for (let i = 0; i < select.options.length; i += 1) {
			const option = select.options[i];
			option.selected = ~value.indexOf(option.__value);
		}
	}

	function select_value(select) {
		const selected_option = select.querySelector(':checked') || select.options[0];
		return selected_option && selected_option.__value;
	}

	function select_multiple_value(select) {
		return [].map.call(select.querySelectorAll(':checked'), option => option.__value);
	}

	function add_resize_listener(element, fn) {
		if (getComputedStyle(element).position === 'static') {
			element.style.position = 'relative';
		}

		const object = document.createElement('object');
		object.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;');
		object.type = 'text/html';

		let win;

		object.onload = () => {
			win = object.contentDocument.defaultView;
			win.addEventListener('resize', fn);
		};

		if (/Trident/.test(navigator.userAgent)) {
			element.appendChild(object);
			object.data = 'about:blank';
		} else {
			object.data = 'about:blank';
			element.appendChild(object);
		}

		return {
			cancel: () => {
				win && win.removeEventListener && win.removeEventListener('resize', fn);
				element.removeChild(object);
			}
		};
	}

	function toggle_class(element, name, toggle) {
		element.classList[toggle ? 'add' : 'remove'](name);
	}

	function custom_event(type, detail) {
		const e = document.createEvent('CustomEvent');
		e.initCustomEvent(type, false, false, detail);
		return e;
	}

	let stylesheet;
	let active = 0;
	let current_rules = {};

	// https://github.com/darkskyapp/string-hash/blob/master/index.js
	function hash(str) {
		let hash = 5381;
		let i = str.length;

		while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
		return hash >>> 0;
	}

	function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
		const step = 16.666 / duration;
		let keyframes = '{\n';

		for (let p = 0; p <= 1; p += step) {
			const t = a + (b - a) * ease(p);
			keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
		}

		const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
		const name = `__svelte_${hash(rule)}_${uid}`;

		if (!current_rules[name]) {
			if (!stylesheet) {
				const style = element('style');
				document.head.appendChild(style);
				stylesheet = style.sheet;
			}

			current_rules[name] = true;
			stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
		}

		const animation = node.style.animation || '';
		node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;

		active += 1;
		return name;
	}

	function delete_rule(node, name) {
		node.style.animation = (node.style.animation || '')
			.split(', ')
			.filter(name
				? anim => anim.indexOf(name) < 0 // remove specific animation
				: anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
			)
			.join(', ');

		if (name && !--active) clear_rules();
	}

	function clear_rules() {
		requestAnimationFrame(() => {
			if (active) return;
			let i = stylesheet.cssRules.length;
			while (i--) stylesheet.deleteRule(i);
			current_rules = {};
		});
	}

	function create_animation(node, from, fn, params) {
		if (!from) return noop;

		const to = node.getBoundingClientRect();
		if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom) return noop;

		const {
			delay = 0,
			duration = 300,
			easing = identity,
			start: start_time = window.performance.now() + delay,
			end = start_time + duration,
			tick = noop,
			css
		} = fn(node, { from, to }, params);

		let running = true;
		let started = false;
		let name;

		const css_text = node.style.cssText;

		function start() {
			if (css) {
				if (delay) node.style.cssText = css_text; // TODO create delayed animation instead?
				name = create_rule(node, 0, 1, duration, 0, easing, css);
			}

			started = true;
		}

		function stop() {
			if (css) delete_rule(node, name);
			running = false;
		}

		loop(now => {
			if (!started && now >= start_time) {
				start();
			}

			if (started && now >= end) {
				tick(1, 0);
				stop();
			}

			if (!running) {
				return false;
			}

			if (started) {
				const p = now - start_time;
				const t = 0 + 1 * easing(p / duration);
				tick(t, 1 - t);
			}

			return true;
		});

		if (delay) {
			if (css) node.style.cssText += css(0, 1);
		} else {
			start();
		}

		tick(0, 1);

		return stop;
	}

	function fix_position(node) {
		const style = getComputedStyle(node);

		if (style.position !== 'absolute' && style.position !== 'fixed') {
			const { width, height } = style;
			const a = node.getBoundingClientRect();
			node.style.position = 'absolute';
			node.style.width = width;
			node.style.height = height;
			const b = node.getBoundingClientRect();

			if (a.left !== b.left || a.top !== b.top) {
				const style = getComputedStyle(node);
				const transform = style.transform === 'none' ? '' : style.transform;

				node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
			}
		}
	}

	function set_current_component(component) {
		exports.current_component = component;
	}

	function get_current_component() {
		if (!exports.current_component) throw new Error(`Function called outside component initialization`);
		return exports.current_component;
	}

	function beforeUpdate(fn) {
		get_current_component().$$.before_render.push(fn);
	}

	function onMount(fn) {
		get_current_component().$$.on_mount.push(fn);
	}

	function afterUpdate(fn) {
		get_current_component().$$.after_render.push(fn);
	}

	function onDestroy(fn) {
		get_current_component().$$.on_destroy.push(fn);
	}

	function createEventDispatcher() {
		const component = exports.current_component;

		return (type, detail) => {
			const callbacks = component.$$.callbacks[type];

			if (callbacks) {
				// TODO are there situations where events could be dispatched
				// in a server (non-DOM) environment?
				const event = custom_event(type, detail);
				callbacks.slice().forEach(fn => {
					fn.call(component, event);
				});
			}
		};
	}

	function setContext(key, context) {
		get_current_component().$$.context.set(key, context);
	}

	function getContext(key) {
		return get_current_component().$$.context.get(key);
	}

	// TODO figure out if we still want to support
	// shorthand events, or if we want to implement
	// a real bubbling mechanism
	function bubble(component, event) {
		const callbacks = component.$$.callbacks[event.type];

		if (callbacks) {
			callbacks.slice().forEach(fn => fn(event));
		}
	}

	const dirty_components = [];
	const intros = { enabled: false };

	let update_promise;
	const binding_callbacks = [];
	const render_callbacks = [];

	function schedule_update() {
		if (!update_promise) {
			update_promise = Promise.resolve();
			update_promise.then(flush);
		}
	}

	function add_render_callback(fn) {
		render_callbacks.push(fn);
	}

	function tick() {
		schedule_update();
		return update_promise;
	}

	function add_binding_callback(fn) {
		binding_callbacks.push(fn);
	}

	function flush() {
		const seen_callbacks = new Set();

		do {
			// first, call beforeUpdate functions
			// and update components
			while (dirty_components.length) {
				const component = dirty_components.shift();
				set_current_component(component);
				update(component.$$);
			}

			while (binding_callbacks.length) binding_callbacks.shift()();

			// then, once components are updated, call
			// afterUpdate functions. This may cause
			// subsequent updates...
			while (render_callbacks.length) {
				const callback = render_callbacks.pop();
				if (!seen_callbacks.has(callback)) {
					callback();

					// ...so guard against infinite loops
					seen_callbacks.add(callback);
				}
			}
		} while (dirty_components.length);

		update_promise = null;
	}

	function update($$) {
		if ($$.fragment) {
			$$.update($$.dirty);
			run_all($$.before_render);
			$$.fragment.p($$.dirty, $$.ctx);
			$$.dirty = null;

			$$.after_render.forEach(add_render_callback);
		}
	}

	let promise;

	function wait() {
		if (!promise) {
			promise = Promise.resolve();
			promise.then(() => {
				promise = null;
			});
		}

		return promise;
	}

	function dispatch(node, direction, kind) {
		node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
	}

	let outros;

	function group_outros() {
		outros = {
			remaining: 0,
			callbacks: []
		};
	}

	function check_outros() {
		if (!outros.remaining) {
			run_all(outros.callbacks);
		}
	}

	function on_outro(callback) {
		outros.callbacks.push(callback);
	}

	function create_in_transition(node, fn, params) {
		let config = fn(node, params);
		let running = false;
		let animation_name;
		let task;
		let uid = 0;

		function cleanup() {
			if (animation_name) delete_rule(node, animation_name);
		}

		function go() {
			const {
				delay = 0,
				duration = 300,
				easing = identity,
				tick: tick$$1 = noop,
				css
			} = config;

			if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
			tick$$1(0, 1);

			const start_time = window.performance.now() + delay;
			const end_time = start_time + duration;

			if (task) task.abort();
			running = true;

			task = loop(now => {
				if (running) {
					if (now >= end_time) {
						tick$$1(1, 0);
						cleanup();
						return running = false;
					}

					if (now >= start_time) {
						const t = easing((now - start_time) / duration);
						tick$$1(t, 1 - t);
					}
				}

				return running;
			});
		}

		let started = false;

		return {
			start() {
				if (started) return;

				delete_rule(node);

				if (typeof config === 'function') {
					config = config();
					wait().then(go);
				} else {
					go();
				}
			},

			invalidate() {
				started = false;
			},

			end() {
				if (running) {
					cleanup();
					running = false;
				}
			}
		};
	}

	function create_out_transition(node, fn, params) {
		let config = fn(node, params);
		let running = true;
		let animation_name;

		const group = outros;

		group.remaining += 1;

		function go() {
			const {
				delay = 0,
				duration = 300,
				easing = identity,
				tick: tick$$1 = noop,
				css
			} = config;

			if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);

			const start_time = window.performance.now() + delay;
			const end_time = start_time + duration;

			loop(now => {
				if (running) {
					if (now >= end_time) {
						tick$$1(0, 1);

						if (!--group.remaining) {
							// this will result in `end()` being called,
							// so we don't need to clean up here
							run_all(group.callbacks);
						}

						return false;
					}

					if (now >= start_time) {
						const t = easing((now - start_time) / duration);
						tick$$1(1 - t, t);
					}
				}

				return running;
			});
		}

		if (typeof config === 'function') {
			wait().then(() => {
				config = config();
				go();
			});
		} else {
			go();
		}

		return {
			end(reset) {
				if (reset && config.tick) {
					config.tick(1, 0);
				}

				if (running) {
					if (animation_name) delete_rule(node, animation_name);
					running = false;
				}
			}
		};
	}

	function create_bidirectional_transition(node, fn, params, intro) {
		let config = fn(node, params);

		let t = intro ? 0 : 1;

		let running_program = null;
		let pending_program = null;
		let animation_name = null;

		function clear_animation() {
			if (animation_name) delete_rule(node, animation_name);
		}

		function init(program, duration) {
			const d = program.b - t;
			duration *= Math.abs(d);

			return {
				a: t,
				b: program.b,
				d,
				duration,
				start: program.start,
				end: program.start + duration,
				group: program.group
			};
		}

		function go(b) {
			const {
				delay = 0,
				duration = 300,
				easing = identity,
				tick: tick$$1 = noop,
				css
			} = config;

			const program = {
				start: window.performance.now() + delay,
				b
			};

			if (!b) {
				program.group = outros;
				outros.remaining += 1;
			}

			if (running_program) {
				pending_program = program;
			} else {
				// if this is an intro, and there's a delay, we need to do
				// an initial tick and/or apply CSS animation immediately
				if (css) {
					clear_animation();
					animation_name = create_rule(node, t, b, duration, delay, easing, css);
				}

				if (b) tick$$1(0, 1);

				running_program = init(program, duration);
				add_render_callback(() => dispatch(node, b, 'start'));

				loop(now => {
					if (pending_program && now > pending_program.start) {
						running_program = init(pending_program, duration);
						pending_program = null;

						dispatch(node, running_program.b, 'start');

						if (css) {
							clear_animation();
							animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
						}
					}

					if (running_program) {
						if (now >= running_program.end) {
							tick$$1(t = running_program.b, 1 - t);
							dispatch(node, running_program.b, 'end');

							if (!pending_program) {
								// we're done
								if (running_program.b) {
									// intro — we can tidy up immediately
									clear_animation();
								} else {
									// outro — needs to be coordinated
									if (!--running_program.group.remaining) run_all(running_program.group.callbacks);
								}
							}

							running_program = null;
						}

						else if (now >= running_program.start) {
							const p = now - running_program.start;
							t = running_program.a + running_program.d * easing(p / running_program.duration);
							tick$$1(t, 1 - t);
						}
					}

					return !!(running_program || pending_program);
				});
			}
		}

		return {
			run(b) {
				if (typeof config === 'function') {
					wait().then(() => {
						config = config();
						go(b);
					});
				} else {
					go(b);
				}
			},

			end() {
				clear_animation();
				running_program = pending_program = null;
			}
		};
	}

	function handle_promise(promise, info) {
		const token = info.token = {};

		function update(type, index, key, value) {
			if (info.token !== token) return;

			info.resolved = key && { [key]: value };

			const child_ctx = assign(assign({}, info.ctx), info.resolved);
			const block = type && (info.current = type)(child_ctx);

			if (info.block) {
				if (info.blocks) {
					info.blocks.forEach((block, i) => {
						if (i !== index && block) {
							group_outros();
							on_outro(() => {
								block.d(1);
								info.blocks[i] = null;
							});
							block.o(1);
							check_outros();
						}
					});
				} else {
					info.block.d(1);
				}

				block.c();
				if (block.i) block.i(1);
				block.m(info.mount(), info.anchor);

				flush();
			}

			info.block = block;
			if (info.blocks) info.blocks[index] = block;
		}

		if (is_promise(promise)) {
			promise.then(value => {
				update(info.then, 1, info.value, value);
			}, error => {
				update(info.catch, 2, info.error, error);
			});

			// if we previously had a then/catch block, destroy it
			if (info.current !== info.pending) {
				update(info.pending, 0);
				return true;
			}
		} else {
			if (info.current !== info.then) {
				update(info.then, 1, info.value, promise);
				return true;
			}

			info.resolved = { [info.value]: promise };
		}
	}

	function destroy_block(block, lookup) {
		block.d(1);
		lookup[block.key] = null;
	}

	function outro_and_destroy_block(block, lookup) {
		on_outro(() => {
			destroy_block(block, lookup);
		});

		block.o(1);
	}

	function fix_and_outro_and_destroy_block(block, lookup) {
		block.f();
		outro_and_destroy_block(block, lookup);
	}

	function update_keyed_each(old_blocks, changed, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
		let o = old_blocks.length;
		let n = list.length;

		let i = o;
		const old_indexes = {};
		while (i--) old_indexes[old_blocks[i].key] = i;

		const new_blocks = [];
		const new_lookup = {};
		const deltas = {};

		i = n;
		while (i--) {
			const child_ctx = get_context(ctx, list, i);
			const key = get_key(child_ctx);
			let block = lookup[key];

			if (!block) {
				block = create_each_block(key, child_ctx);
				block.c();
			} else if (dynamic) {
				block.p(changed, child_ctx);
			}

			new_blocks[i] = new_lookup[key] = block;

			if (key in old_indexes) deltas[key] = Math.abs(i - old_indexes[key]);
		}

		const will_move = {};
		const did_move = {};

		function insert(block) {
			if (block.i) block.i(1);
			block.m(node, next);
			lookup[block.key] = block;
			next = block.first;
			n--;
		}

		while (o && n) {
			const new_block = new_blocks[n - 1];
			const old_block = old_blocks[o - 1];
			const new_key = new_block.key;
			const old_key = old_block.key;

			if (new_block === old_block) {
				// do nothing
				next = new_block.first;
				o--;
				n--;
			}

			else if (!new_lookup[old_key]) {
				// remove old block
				destroy(old_block, lookup);
				o--;
			}

			else if (!lookup[new_key] || will_move[new_key]) {
				insert(new_block);
			}

			else if (did_move[old_key]) {
				o--;

			} else if (deltas[new_key] > deltas[old_key]) {
				did_move[new_key] = true;
				insert(new_block);

			} else {
				will_move[old_key] = true;
				o--;
			}
		}

		while (o--) {
			const old_block = old_blocks[o];
			if (!new_lookup[old_block.key]) destroy(old_block, lookup);
		}

		while (n) insert(new_blocks[n - 1]);

		return new_blocks;
	}

	function measure(blocks) {
		const rects = {};
		let i = blocks.length;
		while (i--) rects[blocks[i].key] = blocks[i].node.getBoundingClientRect();
		return rects;
	}

	function get_spread_update(levels, updates) {
		const update = {};

		const to_null_out = {};
		const accounted_for = {};

		let i = levels.length;
		while (i--) {
			const o = levels[i];
			const n = updates[i];

			if (n) {
				for (const key in o) {
					if (!(key in n)) to_null_out[key] = 1;
				}

				for (const key in n) {
					if (!accounted_for[key]) {
						update[key] = n[key];
						accounted_for[key] = 1;
					}
				}

				levels[i] = n;
			} else {
				for (const key in o) {
					accounted_for[key] = 1;
				}
			}
		}

		for (const key in to_null_out) {
			if (!(key in update)) update[key] = undefined;
		}

		return update;
	}

	const invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
	// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
	// https://infra.spec.whatwg.org/#noncharacter

	function spread(args) {
		const attributes = Object.assign({}, ...args);
		let str = '';

		Object.keys(attributes).forEach(name => {
			if (invalid_attribute_name_character.test(name)) return;

			const value = attributes[name];
			if (value === undefined) return;
			if (value === true) str += " " + name;

			const escaped = String(value)
				.replace(/"/g, '&#34;')
				.replace(/'/g, '&#39;');

			str += " " + name + "=" + JSON.stringify(escaped);
		});

		return str;
	}

	const escaped = {
		'"': '&quot;',
		"'": '&#39;',
		'&': '&amp;',
		'<': '&lt;',
		'>': '&gt;'
	};

	function escape(html) {
		return String(html).replace(/["'&<>]/g, match => escaped[match]);
	}

	function each(items, fn) {
		let str = '';
		for (let i = 0; i < items.length; i += 1) {
			str += fn(items[i], i);
		}
		return str;
	}

	const missing_component = {
		$$render: () => ''
	};

	function validate_component(component, name) {
		if (!component || !component.$$render) {
			if (name === 'svelte:component') name += ' this={...}';
			throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
		}

		return component;
	}

	function debug(file, line, column, values) {
		console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console
		console.log(values); // eslint-disable-line no-console
		return '';
	}

	let on_destroy;

	function create_ssr_component(fn) {
		function $$render(result, props, bindings, slots) {
			const parent_component = exports.current_component;

			const $$ = {
				on_destroy,
				context: new Map(parent_component ? parent_component.$$.context : []),

				// these will be immediately discarded
				on_mount: [],
				before_render: [],
				after_render: [],
				callbacks: blank_object()
			};

			set_current_component({ $$ });

			const html = fn(result, props, bindings, slots);

			set_current_component(parent_component);
			return html;
		}

		return {
			render: (props = {}, options = {}) => {
				on_destroy = [];

				const result = { head: '', css: new Set() };
				const html = $$render(result, props, {}, options);

				run_all(on_destroy);

				return {
					html,
					css: {
						code: Array.from(result.css).map(css => css.code).join('\n'),
						map: null // TODO
					},
					head: result.head
				};
			},

			$$render
		};
	}

	function get_store_value(store) {
		let value;
		store.subscribe(_ => value = _)();
		return value;
	}

	function bind(component, name, callback) {
		if (component.$$.props.indexOf(name) === -1) return;
		component.$$.bound[name] = callback;
		callback(component.$$.ctx[name]);
	}

	function mount_component(component, target, anchor) {
		const { fragment, on_mount, on_destroy, after_render } = component.$$;

		fragment.m(target, anchor);

		// onMount happens after the initial afterUpdate. Because
		// afterUpdate callbacks happen in reverse order (inner first)
		// we schedule onMount callbacks before afterUpdate callbacks
		add_render_callback(() => {
			const new_on_destroy = on_mount.map(run).filter(is_function);
			if (on_destroy) {
				on_destroy.push(...new_on_destroy);
			} else {
				// Edge case - component was destroyed immediately,
				// most likely as a result of a binding initialising
				run_all(new_on_destroy);
			}
			component.$$.on_mount = [];
		});

		after_render.forEach(add_render_callback);
	}

	function destroy(component, detaching) {
		if (component.$$) {
			run_all(component.$$.on_destroy);
			component.$$.fragment.d(detaching);

			// TODO null out other refs, including component.$$ (but need to
			// preserve final state?)
			component.$$.on_destroy = component.$$.fragment = null;
			component.$$.ctx = {};
		}
	}

	function make_dirty(component, key) {
		if (!component.$$.dirty) {
			dirty_components.push(component);
			schedule_update();
			component.$$.dirty = {};
		}
		component.$$.dirty[key] = true;
	}

	function init(component, options, instance, create_fragment, not_equal$$1, prop_names) {
		const parent_component = exports.current_component;
		set_current_component(component);

		const props = options.props || {};

		const $$ = component.$$ = {
			fragment: null,
			ctx: null,

			// state
			props: prop_names,
			update: noop,
			not_equal: not_equal$$1,
			bound: blank_object(),

			// lifecycle
			on_mount: [],
			on_destroy: [],
			before_render: [],
			after_render: [],
			context: new Map(parent_component ? parent_component.$$.context : []),

			// everything else
			callbacks: blank_object(),
			dirty: null
		};

		let ready = false;

		$$.ctx = instance
			? instance(component, props, (key, value) => {
				if ($$.bound[key]) $$.bound[key](value);

				if ($$.ctx) {
					const changed = not_equal$$1(value, $$.ctx[key]);
					if (ready && changed) {
						make_dirty(component, key);
					}

					$$.ctx[key] = value;
					return changed;
				}
			})
			: props;

		$$.update();
		ready = true;
		run_all($$.before_render);
		$$.fragment = create_fragment($$.ctx);

		if (options.target) {
			if (options.hydrate) {
				$$.fragment.l(children(options.target));
			} else {
				$$.fragment.c();
			}

			if (options.intro && component.$$.fragment.i) component.$$.fragment.i();
			mount_component(component, options.target, options.anchor);
			flush();
		}

		set_current_component(parent_component);
	}
	if (typeof HTMLElement !== 'undefined') {
		exports.SvelteElement = class extends HTMLElement {
			constructor() {
				super();
				this.attachShadow({ mode: 'open' });
			}

			connectedCallback() {
				for (const key in this.$$.slotted) {
					this.appendChild(this.$$.slotted[key]);
				}
			}

			attributeChangedCallback(attr$$1, oldValue, newValue) {
				this[attr$$1] = newValue;
			}

			$destroy() {
				destroy(this, true);
				this.$destroy = noop;
			}

			$on(type, callback) {
				// TODO should this delegate to addEventListener?
				const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
				callbacks.push(callback);

				return () => {
					const index = callbacks.indexOf(callback);
					if (index !== -1) callbacks.splice(index, 1);
				};
			}

			$set() {
				// overridden by instance, if it has props
			}
		};
	}

	class SvelteComponent {
		$destroy() {
			destroy(this, true);
			this.$destroy = noop;
		}

		$on(type, callback) {
			const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
			callbacks.push(callback);

			return () => {
				const index = callbacks.indexOf(callback);
				if (index !== -1) callbacks.splice(index, 1);
			};
		}

		$set() {
			// overridden by instance, if it has props
		}
	}

	class SvelteComponentDev extends SvelteComponent {
		constructor(options) {
			if (!options || (!options.target && !options.$$inline)) {
				throw new Error(`'target' is a required option`);
			}

			super();
		}

		$destroy() {
			super.$destroy();
			this.$destroy = () => {
				console.warn(`Component was already destroyed`); // eslint-disable-line no-console
			};
		}
	}

	exports.create_animation = create_animation;
	exports.fix_position = fix_position;
	exports.handle_promise = handle_promise;
	exports.append = append;
	exports.insert = insert;
	exports.detach = detach;
	exports.detach_between = detach_between;
	exports.detach_before = detach_before;
	exports.detach_after = detach_after;
	exports.destroy_each = destroy_each;
	exports.element = element;
	exports.svg_element = svg_element;
	exports.text = text;
	exports.space = space;
	exports.empty = empty;
	exports.listen = listen;
	exports.prevent_default = prevent_default;
	exports.stop_propagation = stop_propagation;
	exports.attr = attr;
	exports.set_attributes = set_attributes;
	exports.set_custom_element_data = set_custom_element_data;
	exports.xlink_attr = xlink_attr;
	exports.get_binding_group_value = get_binding_group_value;
	exports.to_number = to_number;
	exports.time_ranges_to_array = time_ranges_to_array;
	exports.children = children;
	exports.claim_element = claim_element;
	exports.claim_text = claim_text;
	exports.set_data = set_data;
	exports.set_input_type = set_input_type;
	exports.set_style = set_style;
	exports.select_option = select_option;
	exports.select_options = select_options;
	exports.select_value = select_value;
	exports.select_multiple_value = select_multiple_value;
	exports.add_resize_listener = add_resize_listener;
	exports.toggle_class = toggle_class;
	exports.custom_event = custom_event;
	exports.destroy_block = destroy_block;
	exports.outro_and_destroy_block = outro_and_destroy_block;
	exports.fix_and_outro_and_destroy_block = fix_and_outro_and_destroy_block;
	exports.update_keyed_each = update_keyed_each;
	exports.measure = measure;
	exports.set_current_component = set_current_component;
	exports.beforeUpdate = beforeUpdate;
	exports.onMount = onMount;
	exports.afterUpdate = afterUpdate;
	exports.onDestroy = onDestroy;
	exports.createEventDispatcher = createEventDispatcher;
	exports.setContext = setContext;
	exports.getContext = getContext;
	exports.bubble = bubble;
	exports.clear_loops = clear_loops;
	exports.loop = loop;
	exports.dirty_components = dirty_components;
	exports.intros = intros;
	exports.schedule_update = schedule_update;
	exports.add_render_callback = add_render_callback;
	exports.tick = tick;
	exports.add_binding_callback = add_binding_callback;
	exports.flush = flush;
	exports.get_spread_update = get_spread_update;
	exports.invalid_attribute_name_character = invalid_attribute_name_character;
	exports.spread = spread;
	exports.escaped = escaped;
	exports.escape = escape;
	exports.each = each;
	exports.missing_component = missing_component;
	exports.validate_component = validate_component;
	exports.debug = debug;
	exports.create_ssr_component = create_ssr_component;
	exports.get_store_value = get_store_value;
	exports.group_outros = group_outros;
	exports.check_outros = check_outros;
	exports.on_outro = on_outro;
	exports.create_in_transition = create_in_transition;
	exports.create_out_transition = create_out_transition;
	exports.create_bidirectional_transition = create_bidirectional_transition;
	exports.noop = noop;
	exports.identity = identity;
	exports.assign = assign;
	exports.is_promise = is_promise;
	exports.add_location = add_location;
	exports.run = run;
	exports.blank_object = blank_object;
	exports.run_all = run_all;
	exports.is_function = is_function;
	exports.safe_not_equal = safe_not_equal;
	exports.not_equal = not_equal;
	exports.validate_store = validate_store;
	exports.subscribe = subscribe;
	exports.create_slot = create_slot;
	exports.get_slot_context = get_slot_context;
	exports.get_slot_changes = get_slot_changes;
	exports.exclude_internal_props = exclude_internal_props;
	exports.bind = bind;
	exports.mount_component = mount_component;
	exports.init = init;
	exports.SvelteComponent = SvelteComponent;
	exports.SvelteComponentDev = SvelteComponentDev;
	});

	unwrapExports(internal);
	var internal_1 = internal.current_component;
	var internal_2 = internal.SvelteElement;
	var internal_3 = internal.create_animation;
	var internal_4 = internal.fix_position;
	var internal_5 = internal.handle_promise;
	var internal_6 = internal.append;
	var internal_7 = internal.insert;
	var internal_8 = internal.detach;
	var internal_9 = internal.detach_between;
	var internal_10 = internal.detach_before;
	var internal_11 = internal.detach_after;
	var internal_12 = internal.destroy_each;
	var internal_13 = internal.element;
	var internal_14 = internal.svg_element;
	var internal_15 = internal.text;
	var internal_16 = internal.space;
	var internal_17 = internal.empty;
	var internal_18 = internal.listen;
	var internal_19 = internal.prevent_default;
	var internal_20 = internal.stop_propagation;
	var internal_21 = internal.attr;
	var internal_22 = internal.set_attributes;
	var internal_23 = internal.set_custom_element_data;
	var internal_24 = internal.xlink_attr;
	var internal_25 = internal.get_binding_group_value;
	var internal_26 = internal.to_number;
	var internal_27 = internal.time_ranges_to_array;
	var internal_28 = internal.children;
	var internal_29 = internal.claim_element;
	var internal_30 = internal.claim_text;
	var internal_31 = internal.set_data;
	var internal_32 = internal.set_input_type;
	var internal_33 = internal.set_style;
	var internal_34 = internal.select_option;
	var internal_35 = internal.select_options;
	var internal_36 = internal.select_value;
	var internal_37 = internal.select_multiple_value;
	var internal_38 = internal.add_resize_listener;
	var internal_39 = internal.toggle_class;
	var internal_40 = internal.custom_event;
	var internal_41 = internal.destroy_block;
	var internal_42 = internal.outro_and_destroy_block;
	var internal_43 = internal.fix_and_outro_and_destroy_block;
	var internal_44 = internal.update_keyed_each;
	var internal_45 = internal.measure;
	var internal_46 = internal.set_current_component;
	var internal_47 = internal.beforeUpdate;
	var internal_48 = internal.onMount;
	var internal_49 = internal.afterUpdate;
	var internal_50 = internal.onDestroy;
	var internal_51 = internal.createEventDispatcher;
	var internal_52 = internal.setContext;
	var internal_53 = internal.getContext;
	var internal_54 = internal.bubble;
	var internal_55 = internal.clear_loops;
	var internal_56 = internal.loop;
	var internal_57 = internal.dirty_components;
	var internal_58 = internal.intros;
	var internal_59 = internal.schedule_update;
	var internal_60 = internal.add_render_callback;
	var internal_61 = internal.tick;
	var internal_62 = internal.add_binding_callback;
	var internal_63 = internal.flush;
	var internal_64 = internal.get_spread_update;
	var internal_65 = internal.invalid_attribute_name_character;
	var internal_66 = internal.spread;
	var internal_67 = internal.escaped;
	var internal_68 = internal.escape;
	var internal_69 = internal.each;
	var internal_70 = internal.missing_component;
	var internal_71 = internal.validate_component;
	var internal_72 = internal.debug;
	var internal_73 = internal.create_ssr_component;
	var internal_74 = internal.get_store_value;
	var internal_75 = internal.group_outros;
	var internal_76 = internal.check_outros;
	var internal_77 = internal.on_outro;
	var internal_78 = internal.create_in_transition;
	var internal_79 = internal.create_out_transition;
	var internal_80 = internal.create_bidirectional_transition;
	var internal_81 = internal.noop;
	var internal_82 = internal.identity;
	var internal_83 = internal.assign;
	var internal_84 = internal.is_promise;
	var internal_85 = internal.add_location;
	var internal_86 = internal.run;
	var internal_87 = internal.blank_object;
	var internal_88 = internal.run_all;
	var internal_89 = internal.is_function;
	var internal_90 = internal.safe_not_equal;
	var internal_91 = internal.not_equal;
	var internal_92 = internal.validate_store;
	var internal_93 = internal.subscribe;
	var internal_94 = internal.create_slot;
	var internal_95 = internal.get_slot_context;
	var internal_96 = internal.get_slot_changes;
	var internal_97 = internal.exclude_internal_props;
	var internal_98 = internal.bind;
	var internal_99 = internal.mount_component;
	var internal_100 = internal.init;
	var internal_101 = internal.SvelteComponent;
	var internal_102 = internal.SvelteComponentDev;

	var dispatcherEvents = new WeakMap();
	var EventDispatcher = /** @class */ (function () {
	    function EventDispatcher() {
	    }
	    EventDispatcher.prototype.on = function (type, listener) {
	        getEventListeners(this, type, true).add(listener);
	    };
	    EventDispatcher.prototype.off = function (type, listener) {
	        var events = getEventListeners(this, type);
	        events && events["delete"](listener);
	    };
	    EventDispatcher.prototype.once = function (type, listener) {
	        function once() {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            this.off(type, once);
	            listener.apply(this, args);
	        }
	        this.on(type, once);
	    };
	    EventDispatcher.prototype.fire = function (type) {
	        var _this = this;
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        var uncanceled = true;
	        var events = getEventListeners(this, type);
	        if (events)
	            events.forEach(function (listener) {
	                uncanceled && listener.apply(_this, args) !== false || (uncanceled = false);
	            });
	        return uncanceled;
	    };
	    return EventDispatcher;
	}());
	function getEventListeners(obj, type, autocreate) {
	    if (autocreate === void 0) { autocreate = false; }
	    var events = dispatcherEvents.get(obj);
	    if (!events && autocreate)
	        dispatcherEvents.set(obj, events = Object.create(null));
	    return events && events[type] || autocreate && (events[type] = new Set());
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics = function(d, b) {
	    extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return extendStatics(d, b);
	};

	function __extends(d, b) {
	    extendStatics(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign = function() {
	    __assign = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};

	/**
	 * This library modifies the diff-patch-match library by Neil Fraser
	 * by removing the patch and match functionality and certain advanced
	 * options in the diff function. The original license is as follows:
	 *
	 * ===
	 *
	 * Diff Match and Patch
	 *
	 * Copyright 2006 Google Inc.
	 * http://code.google.com/p/google-diff-match-patch/
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * The data structure representing a diff is an array of tuples:
	 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
	 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
	 */
	var DIFF_DELETE = -1;
	var DIFF_INSERT = 1;
	var DIFF_EQUAL = 0;
	/**
	 * Find the differences between two texts.  Simplifies the problem by stripping
	 * any common prefix or suffix off the texts before diffing.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {Int} cursor_pos Expected edit position in text1 (optional)
	 * @return {Array} Array of diff tuples.
	 */
	function diff(text1, text2, cursor_pos) {
	    // Check for equality (speedup).
	    if (text1 == text2) {
	        if (text1) {
	            return [[DIFF_EQUAL, text1]];
	        }
	        return [];
	    }
	    // Check cursor_pos within bounds
	    if (cursor_pos < 0 || text1.length < cursor_pos) {
	        cursor_pos = null;
	    }
	    // Trim off common prefix (speedup).
	    var commonlength = diff_commonPrefix(text1, text2);
	    var commonprefix = text1.substring(0, commonlength);
	    text1 = text1.substring(commonlength);
	    text2 = text2.substring(commonlength);
	    // Trim off common suffix (speedup).
	    commonlength = diff_commonSuffix(text1, text2);
	    var commonsuffix = text1.substring(text1.length - commonlength);
	    text1 = text1.substring(0, text1.length - commonlength);
	    text2 = text2.substring(0, text2.length - commonlength);
	    // Compute the diff on the middle block.
	    var diffs = diff_compute_(text1, text2);
	    // Restore the prefix and suffix.
	    if (commonprefix) {
	        diffs.unshift([DIFF_EQUAL, commonprefix]);
	    }
	    if (commonsuffix) {
	        diffs.push([DIFF_EQUAL, commonsuffix]);
	    }
	    diff_cleanupMerge(diffs);
	    if (cursor_pos != null) {
	        diffs = fix_cursor(diffs, cursor_pos);
	    }
	    diffs = fix_emoji(diffs);
	    return diffs;
	}
	/**
	 * Find the differences between two texts.  Assumes that the texts do not
	 * have any common prefix or suffix.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @return {Array} Array of diff tuples.
	 */
	function diff_compute_(text1, text2) {
	    var diffs;
	    if (!text1) {
	        // Just add some text (speedup).
	        return [[DIFF_INSERT, text2]];
	    }
	    if (!text2) {
	        // Just delete some text (speedup).
	        return [[DIFF_DELETE, text1]];
	    }
	    var longtext = text1.length > text2.length ? text1 : text2;
	    var shorttext = text1.length > text2.length ? text2 : text1;
	    var i = longtext.indexOf(shorttext);
	    if (i != -1) {
	        // Shorter text is inside the longer text (speedup).
	        diffs = [[DIFF_INSERT, longtext.substring(0, i)],
	            [DIFF_EQUAL, shorttext],
	            [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
	        // Swap insertions for deletions if diff is reversed.
	        if (text1.length > text2.length) {
	            diffs[0][0] = diffs[2][0] = DIFF_DELETE;
	        }
	        return diffs;
	    }
	    if (shorttext.length == 1) {
	        // Single character string.
	        // After the previous speedup, the character can't be an equality.
	        return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
	    }
	    // Check to see if the problem can be split in two.
	    var hm = diff_halfMatch_(text1, text2);
	    if (hm) {
	        // A half-match was found, sort out the return data.
	        var text1_a = hm[0];
	        var text1_b = hm[1];
	        var text2_a = hm[2];
	        var text2_b = hm[3];
	        var mid_common = hm[4];
	        // Send both pairs off for separate processing.
	        var diffs_a = diff(text1_a, text2_a);
	        var diffs_b = diff(text1_b, text2_b);
	        // Merge the results.
	        return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
	    }
	    return diff_bisect_(text1, text2);
	}
	/**
	 * Find the 'middle snake' of a diff, split the problem in two
	 * and return the recursively constructed diff.
	 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @return {Array} Array of diff tuples.
	 * @private
	 */
	function diff_bisect_(text1, text2) {
	    // Cache the text lengths to prevent multiple calls.
	    var text1_length = text1.length;
	    var text2_length = text2.length;
	    var max_d = Math.ceil((text1_length + text2_length) / 2);
	    var v_offset = max_d;
	    var v_length = 2 * max_d;
	    var v1 = new Array(v_length);
	    var v2 = new Array(v_length);
	    // Setting all elements to -1 is faster in Chrome & Firefox than mixing
	    // integers and undefined.
	    for (var x = 0; x < v_length; x++) {
	        v1[x] = -1;
	        v2[x] = -1;
	    }
	    v1[v_offset + 1] = 0;
	    v2[v_offset + 1] = 0;
	    var delta = text1_length - text2_length;
	    // If the total number of characters is odd, then the front path will collide
	    // with the reverse path.
	    var front = (delta % 2 != 0);
	    // Offsets for start and end of k loop.
	    // Prevents mapping of space beyond the grid.
	    var k1start = 0;
	    var k1end = 0;
	    var k2start = 0;
	    var k2end = 0;
	    for (var d = 0; d < max_d; d++) {
	        // Walk the front path one step.
	        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
	            var k1_offset = v_offset + k1;
	            var x1;
	            if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
	                x1 = v1[k1_offset + 1];
	            }
	            else {
	                x1 = v1[k1_offset - 1] + 1;
	            }
	            var y1 = x1 - k1;
	            while (x1 < text1_length && y1 < text2_length &&
	                text1.charAt(x1) == text2.charAt(y1)) {
	                x1++;
	                y1++;
	            }
	            v1[k1_offset] = x1;
	            if (x1 > text1_length) {
	                // Ran off the right of the graph.
	                k1end += 2;
	            }
	            else if (y1 > text2_length) {
	                // Ran off the bottom of the graph.
	                k1start += 2;
	            }
	            else if (front) {
	                var k2_offset = v_offset + delta - k1;
	                if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
	                    // Mirror x2 onto top-left coordinate system.
	                    var x2 = text1_length - v2[k2_offset];
	                    if (x1 >= x2) {
	                        // Overlap detected.
	                        return diff_bisectSplit_(text1, text2, x1, y1);
	                    }
	                }
	            }
	        }
	        // Walk the reverse path one step.
	        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
	            var k2_offset = v_offset + k2;
	            var x2;
	            if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
	                x2 = v2[k2_offset + 1];
	            }
	            else {
	                x2 = v2[k2_offset - 1] + 1;
	            }
	            var y2 = x2 - k2;
	            while (x2 < text1_length && y2 < text2_length &&
	                text1.charAt(text1_length - x2 - 1) ==
	                    text2.charAt(text2_length - y2 - 1)) {
	                x2++;
	                y2++;
	            }
	            v2[k2_offset] = x2;
	            if (x2 > text1_length) {
	                // Ran off the left of the graph.
	                k2end += 2;
	            }
	            else if (y2 > text2_length) {
	                // Ran off the top of the graph.
	                k2start += 2;
	            }
	            else if (!front) {
	                var k1_offset = v_offset + delta - k2;
	                if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
	                    var x1 = v1[k1_offset];
	                    var y1 = v_offset + x1 - k1_offset;
	                    // Mirror x2 onto top-left coordinate system.
	                    x2 = text1_length - x2;
	                    if (x1 >= x2) {
	                        // Overlap detected.
	                        return diff_bisectSplit_(text1, text2, x1, y1);
	                    }
	                }
	            }
	        }
	    }
	    // Diff took too long and hit the deadline or
	    // number of diffs equals number of characters, no commonality at all.
	    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
	}
	/**
	 * Given the location of the 'middle snake', split the diff in two parts
	 * and recurse.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} x Index of split point in text1.
	 * @param {number} y Index of split point in text2.
	 * @return {Array} Array of diff tuples.
	 */
	function diff_bisectSplit_(text1, text2, x, y) {
	    var text1a = text1.substring(0, x);
	    var text2a = text2.substring(0, y);
	    var text1b = text1.substring(x);
	    var text2b = text2.substring(y);
	    // Compute both diffs serially.
	    var diffs = diff(text1a, text2a);
	    var diffsb = diff(text1b, text2b);
	    return diffs.concat(diffsb);
	}
	/**
	 * Determine the common prefix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the start of each
	 *     string.
	 */
	function diff_commonPrefix(text1, text2) {
	    // Quick check for common null cases.
	    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
	        return 0;
	    }
	    // Binary search.
	    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	    var pointermin = 0;
	    var pointermax = Math.min(text1.length, text2.length);
	    var pointermid = pointermax;
	    var pointerstart = 0;
	    while (pointermin < pointermid) {
	        if (text1.substring(pointerstart, pointermid) ==
	            text2.substring(pointerstart, pointermid)) {
	            pointermin = pointermid;
	            pointerstart = pointermin;
	        }
	        else {
	            pointermax = pointermid;
	        }
	        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }
	    return pointermid;
	}
	/**
	 * Determine the common suffix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the end of each string.
	 */
	function diff_commonSuffix(text1, text2) {
	    // Quick check for common null cases.
	    if (!text1 || !text2 ||
	        text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
	        return 0;
	    }
	    // Binary search.
	    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	    var pointermin = 0;
	    var pointermax = Math.min(text1.length, text2.length);
	    var pointermid = pointermax;
	    var pointerend = 0;
	    while (pointermin < pointermid) {
	        if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
	            text2.substring(text2.length - pointermid, text2.length - pointerend)) {
	            pointermin = pointermid;
	            pointerend = pointermin;
	        }
	        else {
	            pointermax = pointermid;
	        }
	        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }
	    return pointermid;
	}
	/**
	 * Do the two texts share a substring which is at least half the length of the
	 * longer text?
	 * This speedup can produce non-minimal diffs.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {Array.<string>} Five element Array, containing the prefix of
	 *     text1, the suffix of text1, the prefix of text2, the suffix of
	 *     text2 and the common middle.  Or null if there was no match.
	 */
	function diff_halfMatch_(text1, text2) {
	    var longtext = text1.length > text2.length ? text1 : text2;
	    var shorttext = text1.length > text2.length ? text2 : text1;
	    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
	        return null; // Pointless.
	    }
	    /**
	     * Does a substring of shorttext exist within longtext such that the substring
	     * is at least half the length of longtext?
	     * Closure, but does not reference any external variables.
	     * @param {string} longtext Longer string.
	     * @param {string} shorttext Shorter string.
	     * @param {number} i Start index of quarter length substring within longtext.
	     * @return {Array.<string>} Five element Array, containing the prefix of
	     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
	     *     of shorttext and the common middle.  Or null if there was no match.
	     * @private
	     */
	    function diff_halfMatchI_(longtext, shorttext, i) {
	        // Start with a 1/4 length substring at position i as a seed.
	        var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
	        var j = -1;
	        var best_common = '';
	        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
	        while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
	            var prefixLength = diff_commonPrefix(longtext.substring(i), shorttext.substring(j));
	            var suffixLength = diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));
	            if (best_common.length < suffixLength + prefixLength) {
	                best_common = shorttext.substring(j - suffixLength, j) +
	                    shorttext.substring(j, j + prefixLength);
	                best_longtext_a = longtext.substring(0, i - suffixLength);
	                best_longtext_b = longtext.substring(i + prefixLength);
	                best_shorttext_a = shorttext.substring(0, j - suffixLength);
	                best_shorttext_b = shorttext.substring(j + prefixLength);
	            }
	        }
	        if (best_common.length * 2 >= longtext.length) {
	            return [best_longtext_a, best_longtext_b,
	                best_shorttext_a, best_shorttext_b, best_common];
	        }
	        else {
	            return null;
	        }
	    }
	    // First check if the second quarter is the seed for a half-match.
	    var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
	    // Check again based on the third quarter.
	    var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
	    var hm;
	    if (!hm1 && !hm2) {
	        return null;
	    }
	    else if (!hm2) {
	        hm = hm1;
	    }
	    else if (!hm1) {
	        hm = hm2;
	    }
	    else {
	        // Both matched.  Select the longest.
	        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
	    }
	    // A half-match was found, sort out the return data.
	    var text1_a, text1_b, text2_a, text2_b;
	    if (text1.length > text2.length) {
	        text1_a = hm[0];
	        text1_b = hm[1];
	        text2_a = hm[2];
	        text2_b = hm[3];
	    }
	    else {
	        text2_a = hm[0];
	        text2_b = hm[1];
	        text1_a = hm[2];
	        text1_b = hm[3];
	    }
	    var mid_common = hm[4];
	    return [text1_a, text1_b, text2_a, text2_b, mid_common];
	}
	/**
	 * Reorder and merge like edit sections.  Merge equalities.
	 * Any edit section can move as long as it doesn't cross an equality.
	 * @param {Array} diffs Array of diff tuples.
	 */
	function diff_cleanupMerge(diffs) {
	    diffs.push([DIFF_EQUAL, '']); // Add a dummy entry at the end.
	    var pointer = 0;
	    var count_delete = 0;
	    var count_insert = 0;
	    var text_delete = '';
	    var text_insert = '';
	    var commonlength;
	    while (pointer < diffs.length) {
	        switch (diffs[pointer][0]) {
	            case DIFF_INSERT:
	                count_insert++;
	                text_insert += diffs[pointer][1];
	                pointer++;
	                break;
	            case DIFF_DELETE:
	                count_delete++;
	                text_delete += diffs[pointer][1];
	                pointer++;
	                break;
	            case DIFF_EQUAL:
	                // Upon reaching an equality, check for prior redundancies.
	                if (count_delete + count_insert > 1) {
	                    if (count_delete !== 0 && count_insert !== 0) {
	                        // Factor out any common prefixies.
	                        commonlength = diff_commonPrefix(text_insert, text_delete);
	                        if (commonlength !== 0) {
	                            if ((pointer - count_delete - count_insert) > 0 &&
	                                diffs[pointer - count_delete - count_insert - 1][0] ==
	                                    DIFF_EQUAL) {
	                                diffs[pointer - count_delete - count_insert - 1][1] +=
	                                    text_insert.substring(0, commonlength);
	                            }
	                            else {
	                                diffs.splice(0, 0, [DIFF_EQUAL,
	                                    text_insert.substring(0, commonlength)]);
	                                pointer++;
	                            }
	                            text_insert = text_insert.substring(commonlength);
	                            text_delete = text_delete.substring(commonlength);
	                        }
	                        // Factor out any common suffixies.
	                        commonlength = diff_commonSuffix(text_insert, text_delete);
	                        if (commonlength !== 0) {
	                            diffs[pointer][1] = text_insert.substring(text_insert.length -
	                                commonlength) + diffs[pointer][1];
	                            text_insert = text_insert.substring(0, text_insert.length -
	                                commonlength);
	                            text_delete = text_delete.substring(0, text_delete.length -
	                                commonlength);
	                        }
	                    }
	                    // Delete the offending records and add the merged ones.
	                    if (count_delete === 0) {
	                        diffs.splice(pointer - count_insert, count_delete + count_insert, [DIFF_INSERT, text_insert]);
	                    }
	                    else if (count_insert === 0) {
	                        diffs.splice(pointer - count_delete, count_delete + count_insert, [DIFF_DELETE, text_delete]);
	                    }
	                    else {
	                        diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);
	                    }
	                    pointer = pointer - count_delete - count_insert +
	                        (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
	                }
	                else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
	                    // Merge this equality with the previous one.
	                    diffs[pointer - 1][1] += diffs[pointer][1];
	                    diffs.splice(pointer, 1);
	                }
	                else {
	                    pointer++;
	                }
	                count_insert = 0;
	                count_delete = 0;
	                text_delete = '';
	                text_insert = '';
	                break;
	        }
	    }
	    if (diffs[diffs.length - 1][1] === '') {
	        diffs.pop(); // Remove the dummy entry at the end.
	    }
	    // Second pass: look for single edits surrounded on both sides by equalities
	    // which can be shifted sideways to eliminate an equality.
	    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
	    var changes = false;
	    pointer = 1;
	    // Intentionally ignore the first and last element (don't need checking).
	    while (pointer < diffs.length - 1) {
	        if (diffs[pointer - 1][0] == DIFF_EQUAL &&
	            diffs[pointer + 1][0] == DIFF_EQUAL) {
	            // This is a single edit surrounded by equalities.
	            if (diffs[pointer][1].substring(diffs[pointer][1].length -
	                diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
	                // Shift the edit over the previous equality.
	                diffs[pointer][1] = diffs[pointer - 1][1] +
	                    diffs[pointer][1].substring(0, diffs[pointer][1].length -
	                        diffs[pointer - 1][1].length);
	                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
	                diffs.splice(pointer - 1, 1);
	                changes = true;
	            }
	            else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
	                diffs[pointer + 1][1]) {
	                // Shift the edit over the next equality.
	                diffs[pointer - 1][1] += diffs[pointer + 1][1];
	                diffs[pointer][1] =
	                    diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
	                        diffs[pointer + 1][1];
	                diffs.splice(pointer + 1, 1);
	                changes = true;
	            }
	        }
	        pointer++;
	    }
	    // If shifts were made, the diff needs reordering and another shift sweep.
	    if (changes) {
	        diff_cleanupMerge(diffs);
	    }
	}
	diff.INSERT = DIFF_INSERT;
	diff.DELETE = DIFF_DELETE;
	diff.EQUAL = DIFF_EQUAL;
	/*
	 * Modify a diff such that the cursor position points to the start of a change:
	 * E.g.
	 *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)
	 *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]
	 *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)
	 *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
	 * @return {Array} A tuple [cursor location in the modified diff, modified diff]
	 */
	function cursor_normalize_diff(diffs, cursor_pos) {
	    if (cursor_pos === 0) {
	        return [DIFF_EQUAL, diffs];
	    }
	    for (var current_pos = 0, i = 0; i < diffs.length; i++) {
	        var d = diffs[i];
	        if (d[0] === DIFF_DELETE || d[0] === DIFF_EQUAL) {
	            var next_pos = current_pos + d[1].length;
	            if (cursor_pos === next_pos) {
	                return [i + 1, diffs];
	            }
	            else if (cursor_pos < next_pos) {
	                // copy to prevent side effects
	                diffs = diffs.slice();
	                // split d into two diff changes
	                var split_pos = cursor_pos - current_pos;
	                var d_left = [d[0], d[1].slice(0, split_pos)];
	                var d_right = [d[0], d[1].slice(split_pos)];
	                diffs.splice(i, 1, d_left, d_right);
	                return [i + 1, diffs];
	            }
	            else {
	                current_pos = next_pos;
	            }
	        }
	    }
	    throw new Error('cursor_pos is out of bounds!');
	}
	/*
	 * Modify a diff such that the edit position is "shifted" to the proposed edit location (cursor_position).
	 *
	 * Case 1)
	 *   Check if a naive shift is possible:
	 *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)
	 *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result
	 * Case 2)
	 *   Check if the following shifts are possible:
	 *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']
	 *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']
	 *         ^            ^
	 *         d          d_next
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
	 * @return {Array} Array of diff tuples
	 */
	function fix_cursor(diffs, cursor_pos) {
	    var norm = cursor_normalize_diff(diffs, cursor_pos);
	    var ndiffs = norm[1];
	    var cursor_pointer = norm[0];
	    var d = ndiffs[cursor_pointer];
	    var d_next = ndiffs[cursor_pointer + 1];
	    if (d == null) {
	        // Text was deleted from end of original string,
	        // cursor is now out of bounds in new string
	        return diffs;
	    }
	    else if (d[0] !== DIFF_EQUAL) {
	        // A modification happened at the cursor location.
	        // This is the expected outcome, so we can return the original diff.
	        return diffs;
	    }
	    else {
	        if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
	            // Case 1)
	            // It is possible to perform a naive shift
	            ndiffs.splice(cursor_pointer, 2, d_next, d);
	            return merge_tuples(ndiffs, cursor_pointer, 2);
	        }
	        else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
	            // Case 2)
	            // d[1] is a prefix of d_next[1]
	            // We can assume that d_next[0] !== 0, since d[0] === 0
	            // Shift edit locations..
	            ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
	            var suffix = d_next[1].slice(d[1].length);
	            if (suffix.length > 0) {
	                ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
	            }
	            return merge_tuples(ndiffs, cursor_pointer, 3);
	        }
	        else {
	            // Not possible to perform any modification
	            return diffs;
	        }
	    }
	}
	/*
	 * Check diff did not split surrogate pairs.
	 * Ex. [0, '\uD83D'], [-1, '\uDC36'], [1, '\uDC2F'] -> [-1, '\uD83D\uDC36'], [1, '\uD83D\uDC2F']
	 *     '\uD83D\uDC36' === '🐶', '\uD83D\uDC2F' === '🐯'
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @return {Array} Array of diff tuples
	 */
	function fix_emoji(diffs) {
	    var compact = false;
	    var starts_with_pair_end = function (str) {
	        return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;
	    };
	    var ends_with_pair_start = function (str) {
	        return str.charCodeAt(str.length - 1) >= 0xD800 && str.charCodeAt(str.length - 1) <= 0xDBFF;
	    };
	    for (var i = 2; i < diffs.length; i += 1) {
	        if (diffs[i - 2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i - 2][1]) &&
	            diffs[i - 1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i - 1][1]) &&
	            diffs[i][0] === DIFF_INSERT && starts_with_pair_end(diffs[i][1])) {
	            compact = true;
	            diffs[i - 1][1] = diffs[i - 2][1].slice(-1) + diffs[i - 1][1];
	            diffs[i][1] = diffs[i - 2][1].slice(-1) + diffs[i][1];
	            diffs[i - 2][1] = diffs[i - 2][1].slice(0, -1);
	        }
	    }
	    if (!compact) {
	        return diffs;
	    }
	    var fixed_diffs = [];
	    for (var i = 0; i < diffs.length; i += 1) {
	        if (diffs[i][1].length > 0) {
	            fixed_diffs.push(diffs[i]);
	        }
	    }
	    return fixed_diffs;
	}
	/*
	 * Try to merge tuples with their neigbors in a given range.
	 * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']
	 *
	 * @param {Array} diffs Array of diff tuples.
	 * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).
	 * @param {Int} length Number of consecutive elements to check.
	 * @return {Array} Array of merged diff tuples.
	 */
	function merge_tuples(diffs, start, length) {
	    // Check from (start-1) to (start+length).
	    for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {
	        if (i + 1 < diffs.length) {
	            var left_d = diffs[i];
	            var right_d = diffs[i + 1];
	            if (left_d[0] === right_d[1]) {
	                diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
	            }
	        }
	    }
	    return diffs;
	}

	function shallowEqual(valueA, valueB) {
	    return valueEqual(valueA, valueB, strictEqual);
	}
	function deepEqual(valueA, valueB) {
	    return valueEqual(valueA, valueB, valueEqual);
	}
	function strictEqual(valueA, valueB) {
	    return valueA === valueB;
	}
	function valueEqual(valueA, valueB, propEqual) {
	    if (valueA === valueB)
	        return true;
	    if (valueA instanceof Date && valueB instanceof Date)
	        return valueA.getTime() === valueB.getTime();
	    if (!valueA || !valueB || typeof valueA !== 'object' && typeof valueB !== 'object')
	        return valueA === valueB;
	    return objectEqual(valueA, valueB, propEqual);
	}
	function objectEqual(objA, objB, propEqual) {
	    if (objA.prototype !== objB.prototype)
	        return false;
	    var keysA = Object.keys(objA);
	    var keysB = Object.keys(objB);
	    if (keysA.length !== keysB.length)
	        return false;
	    return keysA.every(function (key, i) { return key === keysB[i] && propEqual(objA[key], objB[key], propEqual); });
	}

	var NULL_CHARACTER = String.fromCharCode(0); // Placeholder char for embed in diff()
	var Delta = /** @class */ (function () {
	    function Delta(ops) {
	        if (ops === void 0) { ops = []; }
	        this.ops = ops;
	    }
	    /**
	     * Appends an insert operation. Returns this for chainability.
	     *
	     * @param {String|Object} text Represents text or embed to insert
	     * @param {Object} attributes Optional attributes to apply
	     */
	    Delta.prototype.insert = function (text, attributes) {
	        var newOp = {};
	        if (text.length === 0)
	            return this;
	        newOp.insert = text;
	        if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
	            newOp.attributes = attributes;
	        }
	        return this._push(newOp);
	    };
	    /**
	     * Appends a delete operation. Returns this for chainability.
	     *
	     * @param {Number} length Number of characters to delete
	     */
	    Delta.prototype["delete"] = function (length) {
	        if (length <= 0)
	            return this;
	        return this._push({ "delete": length });
	    };
	    /**
	     * Appends a retain operation. Returns this for chainability.
	     *
	     * @param {Number} length Number of characters to retain
	     * @param {Object} attributes Optional attributes to apply
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.retain = function (length, attributes) {
	        if (length <= 0)
	            return this;
	        var newOp = { retain: length };
	        if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
	            newOp.attributes = attributes;
	        }
	        return this._push(newOp);
	    };
	    /**
	     * Freezes delta from future modifications. Returns this for chainability.
	     *
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.freeze = function () {
	        var _this = this;
	        this._push = function () { return _this; };
	        return this;
	    };
	    /**
	     * Adds a new operation. Returns this for chainability.
	     *
	     * @param {Object} newOp A new operation
	     * @returns {Delta} This delta
	     */
	    Delta.prototype._push = function (newOp) {
	        var index = this.ops.length;
	        var lastOp = this.ops[index - 1];
	        if (typeof lastOp === 'object') {
	            if (typeof newOp["delete"] === 'number' && typeof lastOp["delete"] === 'number') {
	                this.ops[index - 1] = { "delete": lastOp["delete"] + newOp["delete"] };
	                return this;
	            }
	            // Since it does not matter if we insert before or after deleting at the same index,
	            // always prefer to insert first
	            if (typeof lastOp["delete"] === 'number' && newOp.insert != null) {
	                index -= 1;
	                lastOp = this.ops[index - 1];
	                if (typeof lastOp !== 'object') {
	                    this.ops.unshift(newOp);
	                    return this;
	                }
	            }
	            if (deepEqual(newOp.attributes, lastOp.attributes)) {
	                if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {
	                    this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };
	                    if (typeof newOp.attributes === 'object')
	                        this.ops[index - 1].attributes = newOp.attributes;
	                    return this;
	                }
	                else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {
	                    this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };
	                    if (typeof newOp.attributes === 'object')
	                        this.ops[index - 1].attributes = newOp.attributes;
	                    return this;
	                }
	            }
	        }
	        if (index === this.ops.length) {
	            this.ops.push(newOp);
	        }
	        else {
	            this.ops.splice(index, 0, newOp);
	        }
	        return this;
	    };
	    /**
	     * Chops off trailing retain instructions to make the delta concise.
	     *
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.chop = function () {
	        var lastOp = this.ops[this.ops.length - 1];
	        if (lastOp && lastOp.retain && !lastOp.attributes) {
	            this.ops.pop();
	        }
	        return this;
	    };
	    /**
	     * Returns an iterator to iterate over the operations of this delta.
	     *
	     * @returns {Iterator} An operation iterator with methods hasNext, next, peek, peekLength, & peekType
	     */
	    Delta.prototype.iterator = function () {
	        return new Iterator(this.ops);
	    };
	    /**
	     * Returns an array of operations that passes a given function.
	     *
	     * @param {Function} predicate Function to test each operation against. Return true to keep the operation, false
	     *                             otherwise
	     * @returns {Array} Filtered resulting array
	     */
	    Delta.prototype.filter = function (predicate) {
	        return this.ops.filter(predicate);
	    };
	    /**
	     * Iterates through operations, calling the provided function for each operation.
	     *
	     * @param {Function} predicate Function to call during iteration, passing in the current operation
	     */
	    Delta.prototype.forEach = function (predicate) {
	        this.ops.forEach(predicate);
	    };
	    /**
	     * Returns a new array with the results of calling provided function on each operation.
	     *
	     * @param {Function} predicate Function to call, passing in the current operation, returning an element of the new
	     *                             array to be returned
	     * @returns {Array} A new array with each element being the result of the given function
	     */
	    Delta.prototype.map = function (predicate) {
	        return this.ops.map(predicate);
	    };
	    /**
	     * Create an array of two arrays, the first with operations that pass the given function, the other that failed.
	     *
	     * @param {Function} predicate Function to call, passing in the current operation, returning whether that operation
	     *                             passed
	     * @returns {Array} A new array of two Arrays, the first with passed operations, the other with failed operations
	     */
	    Delta.prototype.partition = function (predicate) {
	        var passed = [], failed = [];
	        this.forEach(function (op) {
	            var target = predicate(op) ? passed : failed;
	            target.push(op);
	        });
	        return [passed, failed];
	    };
	    /**
	     * Applies given function against an accumulator and each operation to reduce to a single value.
	     *
	     * @param {Function} predicate Function to call per iteration, returning an accumulated value
	     * @param {*} initial Initial value to pass to first call to predicate
	     * @returns {*} The accumulated value
	     */
	    Delta.prototype.reduce = function (predicate, initial) {
	        return this.ops.reduce(predicate, initial);
	    };
	    Delta.prototype.changeLength = function () {
	        return this.reduce(function (length, entry) {
	            if (entry.insert) {
	                return length + getOpLength(entry);
	            }
	            else if (entry["delete"]) {
	                return length - entry["delete"];
	            }
	            return length;
	        }, 0);
	    };
	    /**
	     * Returns length of a Delta, which is the sum of the lengths of its operations.
	     *
	     * @returns {Number} The length of this delta
	     */
	    Delta.prototype.length = function () {
	        return this.reduce(function (length, entry) {
	            return length + getOpLength(entry);
	        }, 0);
	    };
	    /**
	     * Returns copy of delta with subset of operations.
	     *
	     * @param {Number} start Start index of subset, defaults to 0
	     * @param {Number} end End index of subset, defaults to rest of operations
	     * @returns {Array} An array slice of the operations
	     */
	    Delta.prototype.slice = function (start, end) {
	        if (start === void 0) { start = 0; }
	        if (typeof end !== 'number')
	            end = Infinity;
	        var ops = [];
	        var iter = this.iterator();
	        var index = 0;
	        while (index < end && iter.hasNext()) {
	            var nextOp;
	            if (index < start) {
	                nextOp = iter.next(start - index);
	            }
	            else {
	                nextOp = iter.next(end - index);
	                ops.push(nextOp);
	            }
	            index += getOpLength(nextOp);
	        }
	        return new Delta(ops);
	    };
	    /**
	     * Returns a Delta that is equivalent to applying the operations of own Delta, followed by another Delta.
	     *
	     * @param {Delta} other Delta to compose
	     */
	    Delta.prototype.compose = function (other) {
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        var delta = new Delta();
	        while (thisIter.hasNext() || otherIter.hasNext()) {
	            if (otherIter.peekType() === 'insert') {
	                delta._push(otherIter.next());
	            }
	            else if (thisIter.peekType() === 'delete') {
	                delta._push(thisIter.next());
	            }
	            else {
	                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
	                var thisOp = thisIter.next(length);
	                var otherOp = otherIter.next(length);
	                if (typeof otherOp.retain === 'number') {
	                    var newOp = {};
	                    if (typeof thisOp.retain === 'number') {
	                        newOp.retain = length;
	                    }
	                    else {
	                        newOp.insert = thisOp.insert;
	                    }
	                    // Preserve null when composing with a retain, otherwise remove it for inserts
	                    var attributes = composeAttributes(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');
	                    if (attributes)
	                        newOp.attributes = attributes;
	                    delta._push(newOp);
	                    // Optimization if rest of other is just retain
	                    if (!otherIter.hasNext() && deepEqual(delta.ops[delta.ops.length - 1], newOp)) {
	                        var rest = new Delta(thisIter.rest());
	                        return delta.concat(rest).chop();
	                    }
	                    // Other op should be delete, we could be an insert or retain
	                    // Insert + delete cancels out
	                }
	                else if (typeof otherOp["delete"] === 'number' && typeof thisOp.retain === 'number') {
	                    delta._push(otherOp);
	                }
	            }
	        }
	        return delta.chop();
	    };
	    /**
	     * Returns a new Delta representing the concatenation of this and another document Delta's operations.
	     *
	     * @param {Delta} other Document Delta to concatenate
	     * @returns {Delta} Concatenated document Delta
	     */
	    Delta.prototype.concat = function (other) {
	        var delta = new Delta(this.ops.slice());
	        if (other.ops.length > 0) {
	            delta._push(other.ops[0]);
	            delta.ops = delta.ops.concat(other.ops.slice(1));
	        }
	        return delta;
	    };
	    /**
	     * Returns a Delta representing the difference between two documents. Optionally, accepts a suggested index where
	     * change took place, often representing a cursor position before change.
	     *
	     * @param {Delta} other Document Delta to diff against
	     * @param {Number} index Suggested index where change took place
	     * @returns {Delta} Difference between the two documents
	     */
	    Delta.prototype.diff = function (other, index) {
	        if (this.ops === other.ops) {
	            return new Delta();
	        }
	        var strings = [this, other].map(function (delta) {
	            return delta.map(function (op) {
	                if (op.insert != null) {
	                    return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;
	                }
	                var prep = (delta === other) ? 'on' : 'with';
	                throw new Error('diff() called ' + prep + ' non-document');
	            }).join('');
	        });
	        var delta = new Delta();
	        var diffResult = diff(strings[0], strings[1], index);
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        diffResult.forEach(function (component) {
	            var length = component[1].length;
	            while (length > 0) {
	                var opLength = 0;
	                switch (component[0]) {
	                    case diff.INSERT:
	                        opLength = Math.min(otherIter.peekLength(), length);
	                        delta._push(otherIter.next(opLength));
	                        break;
	                    case diff.DELETE:
	                        opLength = Math.min(length, thisIter.peekLength());
	                        thisIter.next(opLength);
	                        delta["delete"](opLength);
	                        break;
	                    case diff.EQUAL:
	                        opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
	                        var thisOp = thisIter.next(opLength);
	                        var otherOp = otherIter.next(opLength);
	                        if (deepEqual(thisOp.insert, otherOp.insert)) {
	                            delta.retain(opLength, diffAttributes(thisOp.attributes, otherOp.attributes));
	                        }
	                        else {
	                            delta._push(otherOp)["delete"](opLength);
	                        }
	                        break;
	                }
	                length -= opLength;
	            }
	        });
	        return delta.chop();
	    };
	    /**
	     * Iterates through document Delta, calling a given function with a Delta and attributes object, representing the line
	     * segment.
	     *
	     * @param {Function} predicate Function to call on each line group
	     * @param {String} newline Newline character, defaults to \n
	     */
	    Delta.prototype.eachLine = function (predicate, newline) {
	        if (newline === void 0) { newline = '\n'; }
	        var iter = this.iterator();
	        var ops = new Delta();
	        var index = 0;
	        var lineStart = 0;
	        var currentIndex = 0;
	        while (iter.hasNext()) {
	            if (iter.peekType() !== 'insert')
	                return;
	            var op = iter.peek();
	            var nextLength = iter.peekLength();
	            var start = getOpLength(op) - nextLength;
	            var newlineIndex = typeof op.insert === 'string' ? op.insert.indexOf(newline, start) - start : -1;
	            if (newlineIndex < 0) {
	                currentIndex += nextLength;
	                ops._push(iter.next());
	            }
	            else if (newlineIndex > 0) {
	                currentIndex += newlineIndex;
	                ops._push(iter.next(newlineIndex));
	            }
	            else {
	                currentIndex += 1;
	                var attributes = iter.next(1).attributes || {};
	                var line = { ops: ops, attributes: attributes, start: lineStart, end: currentIndex, index: index };
	                if (predicate(line, index) === false) {
	                    return;
	                }
	                index += 1;
	                lineStart = currentIndex;
	                ops = new Delta();
	            }
	        }
	        if (ops.length() > 0) {
	            var line_1 = { ops: ops, attributes: {}, start: lineStart, end: currentIndex, index: index };
	            predicate(line_1, index);
	        }
	    };
	    // Extends Delta, get the lines from `from` to `to`.
	    Delta.prototype.getLines = function (from, to, newline) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = Infinity; }
	        var lines = [];
	        this.eachLine(function (line) {
	            if (line.start > to || (line.start === to && from !== to))
	                return false;
	            if (line.end > from) {
	                lines.push(line);
	            }
	        }, newline);
	        return lines;
	    };
	    // Extends Delta, get the line at `at`.
	    Delta.prototype.getLine = function (at, newline) {
	        return this.getLines(at, at, newline)[0];
	    };
	    // Extends Delta, get the ops from `from` to `to`.
	    Delta.prototype.getOps = function (from, to) {
	        var start = 0;
	        var ops = [];
	        this.ops.some(function (op) {
	            if (start >= to)
	                return true;
	            var end = start + getOpLength(op);
	            if (end > from || (from === to && end === to)) {
	                ops.push({ op: op, start: start, end: end });
	            }
	            start = end;
	        });
	        return ops;
	    };
	    // Extends Delta, get the op at `at`.
	    Delta.prototype.getOp = function (at) {
	        return this.getOps(at, at)[0];
	    };
	    /**
	     * Transform given Delta against own operations. Used as an alias for transformPosition when called with a number.
	     *
	     * @param {Delta} other Delta to transform
	     * @param {Boolean} priority Boolean used to break ties. If true, then this takes priority over other, that is, its
	     *                           actions are considered to happen "first."
	     * @returns {Delta} Transformed Delta
	     */
	    Delta.prototype.transform = function (other, priority) {
	        if (priority === void 0) { priority = false; }
	        if (typeof other === 'number') {
	            return this.transformPosition(other, priority);
	        }
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        var delta = new Delta();
	        while (thisIter.hasNext() || otherIter.hasNext()) {
	            if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {
	                delta.retain(getOpLength(thisIter.next()));
	            }
	            else if (otherIter.peekType() === 'insert') {
	                delta._push(otherIter.next());
	            }
	            else {
	                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
	                var thisOp = thisIter.next(length);
	                var otherOp = otherIter.next(length);
	                if (thisOp["delete"]) {
	                    // Our delete either makes their delete redundant or removes their retain
	                    continue;
	                }
	                else if (otherOp["delete"]) {
	                    delta._push(otherOp);
	                }
	                else {
	                    // We retain either their retain or insert
	                    delta.retain(length, transformAttributes(thisOp.attributes, otherOp.attributes, priority));
	                }
	            }
	        }
	        return delta.chop();
	    };
	    /**
	     * Transform an index against the delta. Useful for representing cursor/selection positions.
	     *
	     * @param {Number} index Index to transform
	     * @param {Boolean} priority Boolean used to break ties. If true, then this takes priority over other, that is, its
	     *                           actions are considered to happen "first."
	     * @returns {Number} Transformed index
	     */
	    Delta.prototype.transformPosition = function (index, priority) {
	        if (priority === void 0) { priority = false; }
	        var thisIter = this.iterator();
	        var offset = 0;
	        while (thisIter.hasNext() && offset <= index) {
	            var length = thisIter.peekLength();
	            var nextType = thisIter.peekType();
	            thisIter.next();
	            if (nextType === 'delete') {
	                index -= Math.min(length, index - offset);
	                continue;
	            }
	            else if (nextType === 'insert' && (offset < index || !priority)) {
	                index += length;
	            }
	            offset += length;
	        }
	        return index;
	    };
	    return Delta;
	}());
	/**
	 * Create an attributes object that is equivalent to applying the attributes of the target followed by the source.
	 *
	 * @param {Object} target Target attributes object which will have the source applied to
	 * @param {Object} source Source attributes object being applied to the target
	 * @param {Boolean} keepNull Whether to keep null values from source
	 * @returns {Object} A new attributes object (or undefined if empty) with both
	 */
	function composeAttributes(target, source, keepNull) {
	    if (target === void 0) { target = {}; }
	    if (source === void 0) { source = {}; }
	    var attributes = __assign({}, target, source);
	    if (!keepNull)
	        Object.keys(attributes).forEach(function (key) {
	            if (attributes[key] == null)
	                delete attributes[key];
	        });
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Finds the difference between two attributes objects. Returns the source attributes that are different from the
	 * target attributes.
	 *
	 * @param {Object} target An attributes object
	 * @param {Object} source An attributes object
	 * @returns {Object} The difference between the two attribute objects or undefined if there is none
	 */
	function diffAttributes(target, source) {
	    if (target === void 0) { target = {}; }
	    if (source === void 0) { source = {}; }
	    var attributes = Object.keys(target).concat(Object.keys(source)).reduce(function (attributes, key) {
	        if (!deepEqual(target[key], source[key])) {
	            attributes[key] = source[key] === undefined ? null : source[key];
	        }
	        return attributes;
	    }, {});
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Transforms the attributes of source over target (or the other way around if priority is set). Will return an
	 * attributes object which has all the values from source if priority if false or will have the values from source that
	 * are set on target.
	 *
	 * @param {Object} target An attributes object
	 * @param {Object} source An attributes object
	 * @param {Boolean} priority If target has priority over source
	 */
	function transformAttributes(target, source, priority) {
	    if (typeof target !== 'object')
	        return source;
	    if (typeof source !== 'object')
	        return undefined;
	    if (!priority)
	        return source; // b simply overwrites us without priority
	    var attributes = Object.keys(source).reduce(function (attributes, key) {
	        if (target[key] === undefined)
	            attributes[key] = source[key]; // null is a valid value
	        return attributes;
	    }, {});
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Determines the length of a Delta operation.
	 *
	 * @param {Object} op An operation entry from a Delta object
	 * @returns {Number} The length of the op
	 */
	function getOpLength(op) {
	    if (typeof op["delete"] === 'number') {
	        return op["delete"];
	    }
	    else if (typeof op.retain === 'number') {
	        return op.retain;
	    }
	    else {
	        return typeof op.insert === 'string' ? op.insert.length : 1;
	    }
	}
	/**
	 * An iterator to handle iterating over a list of Delta operations efficiently.
	 */
	var Iterator = /** @class */ (function () {
	    function Iterator(ops) {
	        this.ops = ops;
	        this.index = 0;
	        this.offset = 0;
	    }
	    /**
	     * Determine if there will be another operation returned by `next`.
	     *
	     * @returns {Boolean} Whether there are more operations to iterate over
	     */
	    Iterator.prototype.hasNext = function () {
	        return this.peekLength() < Infinity;
	    };
	    /**
	     * Get the next operation, optionally limited/sliced by length. If an operation is sliced by length, the next call to
	     * `next` will return more of that operation until it is returned in full.
	     *
	     * @param {Number} length Optionally limit the returned operation by length, slicing it down as needed
	     */
	    Iterator.prototype.next = function (length) {
	        if (length === void 0) { length = Infinity; }
	        var nextOp = this.ops[this.index];
	        if (!nextOp)
	            return { retain: Infinity };
	        var offset = this.offset;
	        var opLength = getOpLength(nextOp);
	        // Update index and offset
	        if (length >= opLength - offset) {
	            length = opLength - offset;
	            this.index += 1;
	            this.offset = 0;
	        }
	        else {
	            this.offset += length;
	        }
	        if (typeof nextOp["delete"] === 'number') {
	            return { "delete": length };
	        }
	        else {
	            var retOp = {};
	            if (nextOp.attributes) {
	                retOp.attributes = nextOp.attributes;
	            }
	            if (typeof nextOp.retain === 'number') {
	                retOp.retain = length;
	            }
	            else if (typeof nextOp.insert === 'string') {
	                retOp.insert = nextOp.insert.substr(offset, length);
	            }
	            else {
	                // offset should === 0, length should === 1
	                retOp.insert = nextOp.insert;
	            }
	            return retOp;
	        }
	    };
	    /**
	     * Return the next entry.
	     *
	     * @returns {Object} The next entry in the ops array.
	     */
	    Iterator.prototype.peek = function () {
	        return this.ops[this.index];
	    };
	    /**
	     * Check the length of the next entry.
	     *
	     * @returns {Number} The length of the next entry or Infinity if there is no next entry
	     */
	    Iterator.prototype.peekLength = function () {
	        if (this.ops[this.index]) {
	            // Should never return 0 if our index is being managed correctly
	            return getOpLength(this.ops[this.index]) - this.offset;
	        }
	        else {
	            return Infinity;
	        }
	    };
	    /**
	     * Check the type of the next entry, delete, retain, or insert.
	     *
	     * @returns {String} The type of the next entry
	     */
	    Iterator.prototype.peekType = function () {
	        if (this.ops[this.index]) {
	            if (typeof this.ops[this.index]["delete"] === 'number') {
	                return 'delete';
	            }
	            else if (typeof this.ops[this.index].retain === 'number') {
	                return 'retain';
	            }
	            else {
	                return 'insert';
	            }
	        }
	        return 'retain';
	    };
	    Iterator.prototype.rest = function () {
	        if (!this.hasNext()) {
	            return [];
	        }
	        else if (this.offset === 0) {
	            return this.ops.slice(this.index);
	        }
	        else {
	            var offset = this.offset;
	            var index = this.index;
	            var next = this.next();
	            var rest = this.ops.slice(this.index);
	            this.offset = offset;
	            this.index = index;
	            return [next].concat(rest);
	        }
	    };
	    return Iterator;
	}());

	var SOURCE_API = 'api';
	var SOURCE_USER = 'user';
	var SOURCE_SILENT = 'silent';
	var empty = {};
	/**
	 * Event for text changes, called before the change has occurred. If a listener returns false the change will be
	 * canceled and not committed.
	 *
	 * @event Editor#text-changing
	 * @type  {Object}
	 * @property {Delta} change       The change which is being applied to the content
	 * @property {Delta} content      The new content after the change
	 * @property {Delta} oldContent   The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * Event for text changes, called after the change has occurred.
	 *
	 * @event Editor#text-change
	 * @type  {Object}
	 * @property {Delta} change       The change which is being applied to the content
	 * @property {Delta} content      The new content after the change
	 * @property {Delta} oldContent   The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * Event for selection changes. If part of a text change the `change`, `content`, and `oldContent` properties will be
	 * set. Otherwise they will not be set.
	 *
	 * @event Editor#selection-change
	 * @type  {Object}
	 * @property {Delta} change       [ Optional ] The change which is being applied to the content
	 * @property {Delta} content      [ Optional ] The new content after the change
	 * @property {Delta} oldContent   [ Optional ] The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * A Typewriter Editor handles the logic for selection and editing of contents. It has no dependency on browser APIs
	 * and can be used in Node.js as easily as the browser. It has no logic to limit formatting (i.e. it does not disallow
	 * using bold, headers, links, or FOOBAR), that will need to be limited outside of the editor itself.
	 *
	 * @fires Editor#text-changing
	 * @fires Editor#text-change
	 * @fires Editor#selection-change
	 *
	 * @readonly @property {Delta}  contents      The data model for the text editor
	 * @readonly @property {Number} length        The length of the contents
	 * @readonly @property {String} text          The text of the contents
	 * @readonly @property {Array}  selection     The current editor selection, a tuple of `[ from, to ]` or `null`
	 * @readonly @property {Object} activeFormats The currently active formats (formats that will apply on the next insert)
	 */
	var Editor = /** @class */ (function (_super) {
	    __extends(Editor, _super);
	    /**
	     * Create a new Typewriter editor.
	     *
	     * @param {Object} options Options for this editor include initial `contents` and `modules`:
	     * @param {Delta}  options.contents The initial contents of this editor
	     */
	    function Editor(options) {
	        if (options === void 0) { options = {}; }
	        var _this = _super.call(this) || this;
	        _this.contents = null;
	        _this.length = 0;
	        _this.selection = null;
	        _this.activeFormats = empty;
	        setContents(_this, options.contents || _this.delta().insert('\n'));
	        _this._queuedEvents = []; // Event queuing ensure they are fired in order
	        return _this;
	    }
	    /**
	     * Convenience method for creating a new delta.
	     *
	     * @param {Array} ops [Optional] The initial ops for the delta
	     * @returns {Delta}   A new Delta object
	     */
	    Editor.prototype.delta = function (ops) {
	        return new Delta(ops);
	    };
	    /**
	     * Returns the contents or a slice of them.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {Delta}     The contents of this editor
	     */
	    Editor.prototype.getContents = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.contents.slice(from, to);
	    };
	    /**
	     * Returns the text for the editor or a slice of it.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {String}    The text in the editor
	     */
	    Editor.prototype.getText = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length - 1; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.getContents(from, to)
	            .filter(function (op) { return typeof op.insert === 'string'; })
	            .map(function (op) { return op.insert; })
	            .join('');
	    };
	    /**
	     * Returns the text for the editor with null characters in place of embeds. This can be used to determine the index of
	     * given words or lines of text within the contents.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {String}    The text in the editor with embed spaces
	     */
	    Editor.prototype.getExactText = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length - 1; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.getContents(from, to)
	            .map(function (op) { return typeof op.insert === 'string' ? op.insert : '\0'; })
	            .join('');
	    };
	    /**
	     * Set the selection to a new location (or null for no selection). Will return false if the new selection is the same
	     * as the old selection. Dispatches "selection-change" once the selection is changed. This "selection-change" event
	     * won't have { contents, oldContnts, change } in it since the selection is changing without any content updates.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Boolean}        Whether the selection changed or not
	     */
	    Editor.prototype.setSelection = function (from, to, source) {
	        var _this = this;
	        if (source === void 0) { source = SOURCE_USER; }
	        var _a;
	        var oldSelection = this.selection;
	        var selection;
	        if (from === null) {
	            selection = null;
	            if (typeof to === 'string')
	                source = to;
	        }
	        else {
	            _a = this._normalizeSelection(from, to, source), from = _a[0], to = _a[1], source = _a[2];
	            selection = [from, to].map(function (i) { return Math.min(i, _this.length - 1); });
	        }
	        if (shallowEqual(oldSelection, selection))
	            return false;
	        // Reset the active formats when selection changes (do this before setting selection)
	        this.activeFormats = selection ? this.getTextFormat(Math.min(selection[0], selection[1])) : empty;
	        this.selection = selection;
	        var event = { selection: selection, oldSelection: oldSelection, source: source };
	        if (source !== SOURCE_SILENT)
	            this.fire('selection-change', event);
	        this.fire('editor-change', event);
	        return true;
	    };
	    /**
	     * The method that all other methods use to update the contents (even setContents & setText). This method will
	     * dispatch the event "text-changing". If a listener returns `false` then the change will be canceled and null will
	     * be returned. Otherwise, the change will be successful and if the `source` is not "silent" a "text-change" event
	     * will be fired with an event object containing `{ contents, oldContents, selection, oldSelection, source }`. If the
	     * selection has changed as part of this update a "selection-change" event will also be fired with the same event
	     * object.
	     *
	     * @param {Delta} change    A delta change to the document
	     * @param {String} source   The source of the change, user, api, or silent
	     * @param {Array} selection Optional selection after the change has been applied
	     * @returns {Delta}         Returns the change when successful, or null if not
	     */
	    Editor.prototype.updateContents = function (change, source, selection) {
	        if (source === void 0) { source = SOURCE_API; }
	        if (!change.chop().ops.length)
	            return null;
	        if (typeof selection === 'number')
	            selection = [selection, selection];
	        var oldContents = this.contents;
	        var contents = normalizeContents(oldContents.compose(change));
	        var length = contents.length();
	        var oldSelection = this.selection;
	        if (!selection)
	            selection = oldSelection ? oldSelection.map(function (i) { return change.transform(i); }) : oldSelection;
	        selection = selection && this.getSelectedRange(selection, length - 1);
	        var changeEvent = { contents: contents, oldContents: oldContents, change: change, selection: selection, oldSelection: oldSelection, source: source };
	        var selectionChanged = !shallowEqual(oldSelection, selection);
	        if (!this.fire('text-changing', changeEvent))
	            return null;
	        setContents(this, contents);
	        if (selection) {
	            // Reset the active formats when selection changes (do this before setting selection)
	            this.activeFormats = selection ? this.getTextFormat(Math.min(selection[0], selection[1])) : empty;
	            this.selection = selection;
	        }
	        var events = [];
	        if (source !== SOURCE_SILENT) {
	            events.push(['text-change', changeEvent]);
	            if (selectionChanged)
	                events.push(['selection-change', changeEvent]);
	        }
	        events.push(['editor-change', changeEvent]);
	        this._queueEvents(events);
	        return change;
	    };
	    /**
	     * Sets the entire contents of the editor. This will calculate the difference between the old content and the new and
	     * only apply the difference, if any.
	     *
	     * @param {Delta} newContents The contents of the editor, as a delta object
	     * @param {String} source     The source of the change, user, api, or silent
	     * @param {Array} selection   Optional selection after the change has been applied
	     * @returns {Delta}           Returns the change when successful, or null if not
	     */
	    Editor.prototype.setContents = function (newContents, source, selection) {
	        var change = this.contents.diff(normalizeContents(newContents));
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Sets the text content of the editor, removing existing contents and formatting.
	     *
	     * @param {String} text     Set the contents of this editor as text
	     * @param {String} source   The source of the change, user, api, or silent
	     * @param {Array} selection Optional selection after the change has been applied
	     * @returns {Delta}         Returns the change when successful, or null if not
	     */
	    Editor.prototype.setText = function (text, source, selection) {
	        return this.setContents(this.delta().insert(text + '\n'), source, selection);
	    };
	    /**
	     * Inserts text into the content of the editor, removing text between from and to if provided. If `text` is a newline
	     * ("\n") then the formats will apply to the line, otherwise they will apply to the text only (even if there are
	     * newlines in the text).
	     *
	     * @param {Number} from      Insert the text at this index, can also be a range Array tuple, default 0
	     * @param {Number} to        If provided and not equal to `from` will delete the text between `from` and `to`
	     * @param {String} text      The text to insert into the editor's contents
	     * @param {Object} formats   The formats of the inserted text. If null the formats at `from` will be used.
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.insertText = function (from, to, text, formats, source, selection) {
	        var _a, _b, _c;
	        _a = this._normalizeRange(from, to, text, formats, source, selection), from = _a[0], to = _a[1], text = _a[2], formats = _a[3], source = _a[4], selection = _a[5];
	        // If we are not inserting a newline, make sure from and to are within the selectable range
	        if (text !== '\n')
	            _b = this.getSelectedRange([from, to]), from = _b[0], to = _b[1];
	        if (typeof formats === 'string')
	            _c = [null, formats, source], formats = _c[0], source = _c[1], selection = _c[2];
	        if (selection == null && this.selection !== null)
	            selection = from + text.length;
	        var change = this.delta().retain(from)["delete"](to - from);
	        if (text === '\n') {
	            change.insert('\n', formats || this.getLineFormat(from));
	        }
	        else {
	            var lineFormat_1 = text.indexOf('\n') === -1 ? null : this.getLineFormat(from);
	            var textFormat_1 = formats || this.getTextFormat(from);
	            text.split('\n').forEach(function (line, i) {
	                if (i)
	                    change.insert('\n', lineFormat_1);
	                line.length && change.insert(line, textFormat_1);
	            });
	        }
	        change = cleanDelete(this, from, to, change);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Inserts an embed into the content of the editor, removing text between from and to if provided.
	     *
	     * @param {Number} from      Insert the embed at this index, can also be a range Array tuple, default 0
	     * @param {Number} to        If provided and not equal to `from` will delete the text between `from` and `to`
	     * @param {String} embed     Insert the text into the editor's contents
	     * @param {mixed}  value     Insert the text into the editor's contents
	     * @param {String} formats   The formats of the inserted text. If null the formats at `from` will be used.
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.insertEmbed = function (from, to, embed, value, formats, source, selection) {
	        var _a, _b, _c;
	        _a = this._normalizeRange(from, to, embed, value, source, selection), from = _a[0], to = _a[1], embed = _a[2], value = _a[3], source = _a[4], selection = _a[5];
	        if (typeof formats === 'string')
	            _b = [null, formats, source], formats = _b[0], source = _b[1], selection = _b[2];
	        if (from >= this.length)
	            from = this.length - 1;
	        if (to >= this.length)
	            to = this.length - 1;
	        if (selection == null && this.selection !== null)
	            selection = from + 1;
	        var textFormat = formats || this.getTextFormat(from);
	        var change = this.delta().retain(from)["delete"](to - from).insert((_c = {}, _c[embed] = value, _c), textFormat);
	        change = cleanDelete(this, from, to, change);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Deletes text from `from` to `to`.
	     *
	     * @param {Number} from      Insert the text as this index, can also be a range Array tuple, default 0
	     * @param {Number} to        Will delete the text between `from` and `to`
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.deleteText = function (from, to, source, selection) {
	        var _a;
	        _a = this._normalizeRange(from, to, source, selection), from = _a[0], to = _a[1], source = _a[2], selection = _a[3];
	        if (from === to)
	            return null;
	        if (selection == null && this.selection !== null)
	            selection = from;
	        var change = this.delta().retain(from)["delete"](to - from);
	        change = cleanDelete(this, from, to, change);
	        // Keep the active format of the text to the right of the cursor when deleting
	        var activeFormats;
	        if (selection === from)
	            activeFormats = this.getTextFormat(from, from + 1);
	        var result = this.updateContents(change, source, selection);
	        if (result && activeFormats)
	            this.activeFormats = activeFormats;
	        return result;
	    };
	    /**
	     * Get the line formats for the line that `from` is in to the line that `to` is in. Returns only the common formats
	     * between all the lines. If `from` equals `to` (or `to` is not provided) the formats will be all of those for the
	     * line `from` is on. If two lines are touched and they have different formats, an empty object will be returned.
	     *
	     * @param {Number} from Getting line formats starting at `from`
	     * @param {Number} to   Getting line formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the lines which intersect from and to
	     */
	    Editor.prototype.getLineFormat = function (from, to) {
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        var formats;
	        this.contents.getLines(from, to).forEach(function (line) {
	            if (!line.attributes)
	                formats = {};
	            else if (!formats)
	                formats = __assign({}, line.attributes);
	            else
	                formats = combineFormats(formats, line.attributes);
	        });
	        return formats;
	    };
	    /**
	     * Get the text formats for all the text from `from` to `to`. Returns only the common formats between the two indexes.
	     * Will also return the `activeFormats`. Active formats are those which are toggled on when the selection is collapsed
	     * (from and to are equal) indicating inserted text should use (or not use) those formats.
	     *
	     * @param {Number} from Getting text formats starting at `from`
	     * @param {Number} to   Getting text formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the text
	     */
	    Editor.prototype.getTextFormat = function (from, to) {
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        var formats;
	        // optimize for current selection
	        var seleciton = this.selection;
	        if (from === to && shallowEqual(this.selection, [from, to])) {
	            return this.activeFormats;
	        }
	        this.contents.getOps(from, to).forEach(function (_a) {
	            var op = _a.op;
	            if (/^\n+$/.test(op.insert))
	                return;
	            if (!op.attributes)
	                formats = {};
	            else if (!formats)
	                formats = __assign({}, op.attributes);
	            else
	                formats = combineFormats(formats, op.attributes);
	        });
	        if (!formats)
	            formats = {};
	        return formats;
	    };
	    /**
	     * Get the text and line formats for all the lines and text from `from` to `to`.
	     *
	     * @param {Number} from Getting line and text formats starting at `from`
	     * @param {Number} to   Getting line and text formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the lines and text which intersect from and to
	     */
	    Editor.prototype.getFormat = function (from, to) {
	        return __assign({}, this.getTextFormat(from, to), this.getLineFormat(from, to));
	    };
	    /**
	     * Formats the lines intersected by `from` and `to` with the given line formats. To remove an existing format pass in
	     * `null` or `false` to turn it off (e.g. `{ blockquote: false }`).
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the line
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.formatLine = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var change = this.delta();
	        this.contents.getLines(from, to).forEach(function (line) {
	            if (!change.ops.length)
	                change.retain(line.end - 1);
	            else
	                change.retain(line.end - line.start - 1);
	            // Clear out old formats on the line
	            Object.keys(line.attributes).forEach(function (name) { return !formats[name] && (formats[name] = null); });
	            change.retain(1, formats);
	        });
	        change.chop();
	        return change.ops.length ? this.updateContents(change, source) : null;
	    };
	    /**
	     * Formats the text from `from` to `to` with the given text formats. To remove an existing format pass in `null` or
	     * `false` to turn it off (e.g. `{ bold: false }`).
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the text
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.formatText = function (from, to, formats, source) {
	        var _this = this;
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        if (from === to) {
	            if (this.activeFormats === empty)
	                this.activeFormats = {};
	            Object.keys(formats).forEach(function (key) {
	                var value = formats[key];
	                if (value == null || value === false)
	                    delete _this.activeFormats[key];
	                else
	                    _this.activeFormats[key] = value;
	            });
	            return;
	        }
	        Object.keys(formats).forEach(function (name) { return formats[name] === false && (formats[name] = null); });
	        var change = this.delta().retain(from);
	        this.getText(from, to).split('\n').forEach(function (line) {
	            line.length && change.retain(line.length, formats);
	            change.retain(1);
	        });
	        change.chop();
	        return this.updateContents(change, source);
	    };
	    /**
	     * Toggles the line formats from `from` to `to` with the given line formats. If the line has the exact formats already
	     * they will be removed, otherwise they will be added.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the line
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.toggleLineFormat = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var existing = this.getLineFormat(from, to);
	        if (deepEqual(existing, formats)) {
	            Object.keys(formats).forEach(function (key) { return formats[key] = null; });
	        }
	        return this.formatLine(from, to, formats, source);
	    };
	    /**
	     * Toggles the text formats from `from` to `to` with the given text formats. If the text has the exact formats already
	     * they will be removed, otherwise they will be added.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the text
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.toggleTextFormat = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var existing = this.getTextFormat(from, to);
	        var isSame = Object.keys(formats).every(function (key) { return formats[key] === existing[key]; });
	        if (isSame) {
	            Object.keys(formats).forEach(function (key) { return formats[key] = null; });
	        }
	        return this.formatText(from, to, formats, source);
	    };
	    /**
	     * Removes all formatting, text and line formats, for the text and lines from `from` to `to`.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.removeFormats = function (from, to, source) {
	        var _this = this;
	        var _a;
	        _a = this._normalizeRange(from, to, source), from = _a[0], to = _a[1], source = _a[2];
	        var formats = {};
	        this.contents.getOps(from, to).forEach(function (_a) {
	            var op = _a.op;
	            op.attributes && Object.keys(op.attributes).forEach(function (key) { return formats[key] = null; });
	        });
	        var change = this.delta().retain(from).retain(to - from, formats);
	        // If the last block was not captured be sure to clear that too
	        this.contents.getLines(from, to).forEach(function (line) {
	            var formats = {};
	            Object.keys(line.attributes).forEach(function (key) { return formats[key] = null; });
	            change = change.compose(_this.delta().retain(line.end - 1).retain(1, formats));
	        });
	        return this.updateContents(change, source);
	    };
	    /**
	     * Create a change delta calling one or more methods on the editor. The changes will not be applied as normal but will
	     * be collated into a single change delta and returned from this methnod. Example:
	     * ```js
	     * var change = editor.getChange(function() {
	     *   editor.deleteText(0, 5);
	     *   editor.insertText('\n', { blockquote: true });
	     *   editor.formatText(10, 20, { bold: true });
	     * });
	     *
	     * editor.updateContents(change, 'user');
	     * ```
	     *
	     * @param {Function} producer A function in which to call methods on the editor to produce a change
	     * @returns {Delta}           The sum of all the changes made within the producer
	     */
	    Editor.prototype.getChange = function (producer) {
	        var change = this.delta();
	        this.updateContents = function (singleChange) {
	            if (singleChange.ops.length) {
	                change = change.compose(singleChange);
	                return singleChange;
	            }
	            else {
	                return null;
	            }
	        };
	        producer(this);
	        delete this.updateContents;
	        return change;
	    };
	    /**
	     * Make several changes to the editor apply all at one in one commit. Changes made with the transaction will be
	     * applied all together and the "text-changing", "text-change", and "selection-change" events will be dispatched only
	     * once. Use this to combine multiple changes into one.
	     *
	     * @param {Function} producer A function which should make changes with the editor
	     * @param {String} source     The source of the change, user, api, or silent
	     * @param {Array} selection   Optional selection after the change has been applied
	     * @returns {Delta}           Returns the change when successful, or null if not
	     */
	    Editor.prototype.transaction = function (producer, source, selection) {
	        var change = this.getChange(producer);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Returns the selected range (or the provided range) in index order (lowest number first) and within the bounds of
	     * the content, between 0 and content.length() - 1 (the selection cannot be past the trailing newline).
	     *
	     * @param {Array} range Optional range, defaults to current selection
	     * @param {Number} max  The maxium number the range can be
	     */
	    Editor.prototype.getSelectedRange = function (range, max) {
	        if (range === void 0) { range = this.selection; }
	        if (max === void 0) { max = this.length - 1; }
	        var _a;
	        if (range == null)
	            return range;
	        if (typeof range === 'number')
	            range = [range, range];
	        if (range[0] > range[1])
	            _a = [range[1], range[0]], range[0] = _a[0], range[1] = _a[1];
	        return range.map(function (index) { return Math.max(0, Math.min(max, index)); });
	    };
	    Editor.prototype._queueEvents = function (events) {
	        var _a;
	        var alreadyRunning = this._queuedEvents.length;
	        (_a = this._queuedEvents).push.apply(_a, events);
	        if (alreadyRunning)
	            return;
	        while (this._queuedEvents.length) {
	            var event = this._queuedEvents.shift();
	            this.fire.apply(this, event);
	        }
	    };
	    /**
	     * Normalizes range values to a proper range if it is not already. A range is a `from` and a `to` index, e.g. 0, 4.
	     * This will ensure the lower index is first. Example usage:
	     * editor._normalizeRange(5); // [5, 5]
	     * editor._normalizeRange(-4, 100); // for a doc with length 10, [0, 10]
	     * editor._normalizeRange(25, 18); // [18, 25]
	     * editor._normalizeRange([12, 13]); // [12, 13]
	     * editor._normalizeRange(5, { bold: true }); // [5, 5, { bold: true }]
	     */
	    Editor.prototype._normalizeRange = function (from, to) {
	        var rest = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            rest[_i - 2] = arguments[_i];
	        }
	        var _a;
	        _a = this._normalizeSelection.apply(this, [from, to].concat(rest)), from = _a[0], to = _a[1], rest = _a.slice(2);
	        if (from > to) {
	            var toValue = from;
	            from = to;
	            to = toValue;
	        }
	        return [from, to].concat(rest);
	    };
	    Editor.prototype._normalizeSelection = function (from, to) {
	        var rest = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            rest[_i - 2] = arguments[_i];
	        }
	        var _a;
	        if (Array.isArray(from)) {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            _a = from, from = _a[0], to = _a[1];
	            if (to === undefined)
	                to = from;
	        }
	        else if (typeof from !== 'number') {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            if (from !== undefined || rest.length)
	                rest.unshift(from);
	            from = to = 0;
	        }
	        else if (typeof to !== 'number') {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            to = from;
	        }
	        from = Math.max(0, Math.min(this.length, Math.floor(from)));
	        to = Math.max(0, Math.min(this.length, Math.floor(to)));
	        return [from, to].concat(rest);
	    };
	    return Editor;
	}(EventDispatcher));
	// Ensures the format for the current line in a delete remains the same when multiple lines are deleted. This is needed
	// because the last line holds the formatting after a delete, but the first line is expected to be the retained format
	function cleanDelete(editor, from, to, change) {
	    if (from !== to) {
	        var line = editor.contents.getLine(from);
	        if (!line.ops.length() && to === from + 1)
	            return change;
	        var lineFormat_2 = editor.getLineFormat(from);
	        if (!deepEqual(lineFormat_2, editor.getLineFormat(to))) {
	            var lineChange = editor.getChange(function () { return editor.formatLine(to, lineFormat_2); });
	            change = change.compose(change.transform(lineChange));
	        }
	    }
	    return change;
	}
	// Ensures contents end with a newline
	function normalizeContents(contents) {
	    // Contents only have inserts. Deletes and retains belong to changes only.
	    contents.ops = contents.ops.filter(function (op) { return op.insert; });
	    var lastOp = contents.ops[contents.ops.length - 1];
	    if (!lastOp || typeof lastOp.insert !== 'string' || lastOp.insert.slice(-1) !== '\n')
	        contents.insert('\n');
	    return contents;
	}
	// Sets the contents onto the editor after ensuring they end in a newline, freezes the contents from change, and
	// updates the length and text of the editor to the latest
	function setContents(editor, contents) {
	    contents = normalizeContents(contents);
	    contents.freeze();
	    editor.contents = contents;
	    editor.length = contents.length();
	}
	// Combine formats removing ones that don't exist in both and creating an array for those with multiple values
	function combineFormats(formats, combined) {
	    return Object.keys(combined).reduce(function (merged, name) {
	        if (formats[name] == null)
	            return merged;
	        if (combined[name] === formats[name]) {
	            merged[name] = combined[name];
	        }
	        else if (Array.isArray(combined[name])) {
	            if (combined[name].indexOf(formats[name]) < 0) {
	                merged[name] = combined[name].concat([formats[name]]);
	            }
	        }
	        else {
	            merged[name] = [combined[name], formats[name]];
	        }
	        return merged;
	    }, {});
	}

	/**
	 * Defines the blocks, marks, and embeds that can be used in a Typewriter document.
	 */
	var Paper = /** @class */ (function () {
	    function Paper(types) {
	        this.subscribers = [];
	        this.blocks = new Types(this, types && types.blocks);
	        this.marks = new Types(this, types && types.marks);
	        this.embeds = new Types(this, types && types.embeds);
	    }
	    Paper.prototype.subscribe = function (run) {
	        var _this = this;
	        this.subscribers.push(run);
	        run(this);
	        return function () {
	            var index = _this.subscribers.indexOf(run);
	            if (index !== -1)
	                _this.subscribers.splice(index, 1);
	        };
	    };
	    Paper.prototype.updated = function () {
	        var _this = this;
	        this.subscribers.forEach(function (run) { return run(_this); });
	    };
	    return Paper;
	}());
	/**
	 * A type store to hold types and make it easy to manage them.
	 */
	var Types = /** @class */ (function () {
	    function Types(paper, types) {
	        var _this = this;
	        this.paper = paper;
	        this.selector = '';
	        this.types = {};
	        this.list = [];
	        this.priorities = {};
	        if (types)
	            types.forEach(function (type) { return _this.add(type, undefined, true); });
	    }
	    // Add a type to the store, optionally by priority (zero being highest priority, and the default type).
	    Types.prototype.add = function (type, priority, skipUpdate) {
	        var _this = this;
	        if (skipUpdate === void 0) { skipUpdate = false; }
	        if (!type.name || !type.selector) {
	            throw new Error('Paper Type definitions must include a name and selector');
	        }
	        if (this.types[type.name])
	            this.remove(type.name);
	        this.selector += (this.selector ? ', ' : '') + type.selector;
	        this.types[type.name] = type;
	        if (priority === undefined) {
	            this.priorities[type.name] = this.list.length;
	            this.list.push(type);
	        }
	        else {
	            this.list.splice(priority, 0, type);
	            this.list.forEach(function (_a, i) {
	                var name = _a.name;
	                return _this.priorities[name] = i;
	            });
	        }
	        if (!skipUpdate)
	            this.paper.updated();
	    };
	    // Remove a type from the store
	    Types.prototype.remove = function (name) {
	        var _this = this;
	        if (!this.types[name])
	            return;
	        delete this.types[name];
	        this.list = this.list.filter(function (type) { return type.name !== name; });
	        this.list.forEach(function (_a, i) {
	            var name = _a.name;
	            return _this.priorities[name] = i;
	        });
	        this.selector = this.list.map(function (type) { return type.selector; }).join(', ');
	        this.paper.updated();
	    };
	    // Clear all types from the store
	    Types.prototype.clear = function () {
	        this.selector = '';
	        this.types = {};
	        this.list = [];
	        this.priorities = {};
	        this.paper.updated();
	    };
	    // Get a types from the store
	    Types.prototype.get = function (name) {
	        return this.types[name];
	    };
	    // Get a type's priority
	    Types.prototype.priority = function (name) {
	        return this.priorities[name];
	    };
	    // Get the default type, also the one with highest priority
	    Types.prototype.getDefault = function () {
	        return this.list[0];
	    };
	    // Whether or not the provided element is one of our types
	    Types.prototype.matches = function (node) {
	        if (!node.nodeType)
	            throw new Error('Cannot match against ' + node);
	        if (node.nodeType === Node.ELEMENT_NODE) {
	            return this.selector ? node.matches(this.selector) : false;
	        }
	    };
	    // Find the first type by priority that matches this element
	    Types.prototype.findByNode = function (node, fallbackToDefault) {
	        if (fallbackToDefault === void 0) { fallbackToDefault = false; }
	        if (node.nodeType !== Node.ELEMENT_NODE)
	            return;
	        var i = this.list.length;
	        while (i--) {
	            var type = this.list[i];
	            if (node.matches(type.selector))
	                return type;
	        }
	        if (fallbackToDefault)
	            return this.getDefault();
	    };
	    // Find the first type by priority that matches this attributes object. Can return the default for no match.
	    Types.prototype.findByAttributes = function (attributes, fallbackToDefault) {
	        var _this = this;
	        if (fallbackToDefault === void 0) { fallbackToDefault = false; }
	        var keys = attributes && Object.keys(attributes);
	        var type;
	        keys && keys.every(function (name) { return !(type = _this.get(name)); });
	        return type || (fallbackToDefault ? this.getDefault() : undefined);
	    };
	    return Types;
	}());

	var dispatcherEvents$1 = new WeakMap();
	var EventDispatcher$1 = /** @class */ (function () {
	    function EventDispatcher() {
	    }
	    EventDispatcher.prototype.on = function (type, listener) {
	        getEventListeners$1(this, type, true).add(listener);
	    };
	    EventDispatcher.prototype.off = function (type, listener) {
	        var events = getEventListeners$1(this, type);
	        events && events["delete"](listener);
	    };
	    EventDispatcher.prototype.once = function (type, listener) {
	        function once() {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            this.off(type, once);
	            listener.apply(this, args);
	        }
	        this.on(type, once);
	    };
	    EventDispatcher.prototype.fire = function (type) {
	        var _this = this;
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        var uncanceled = true;
	        var events = getEventListeners$1(this, type);
	        if (events)
	            events.forEach(function (listener) {
	                uncanceled && listener.apply(_this, args) !== false || (uncanceled = false);
	            });
	        return uncanceled;
	    };
	    return EventDispatcher;
	}());
	function getEventListeners$1(obj, type, autocreate) {
	    if (autocreate === void 0) { autocreate = false; }
	    var events = dispatcherEvents$1.get(obj);
	    if (!events && autocreate)
	        dispatcherEvents$1.set(obj, events = Object.create(null));
	    return events && events[type] || autocreate && (events[type] = new Set());
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics$1 = function(d, b) {
	    extendStatics$1 = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return extendStatics$1(d, b);
	};

	function __extends$1(d, b) {
	    extendStatics$1(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign$1 = function() {
	    __assign$1 = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1.apply(this, arguments);
	};

	/**
	 * This library modifies the diff-patch-match library by Neil Fraser
	 * by removing the patch and match functionality and certain advanced
	 * options in the diff function. The original license is as follows:
	 *
	 * ===
	 *
	 * Diff Match and Patch
	 *
	 * Copyright 2006 Google Inc.
	 * http://code.google.com/p/google-diff-match-patch/
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * The data structure representing a diff is an array of tuples:
	 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
	 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
	 */
	var DIFF_DELETE$1 = -1;
	var DIFF_INSERT$1 = 1;
	var DIFF_EQUAL$1 = 0;
	/**
	 * Find the differences between two texts.  Simplifies the problem by stripping
	 * any common prefix or suffix off the texts before diffing.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {Int} cursor_pos Expected edit position in text1 (optional)
	 * @return {Array} Array of diff tuples.
	 */
	function diff$1(text1, text2, cursor_pos) {
	    // Check for equality (speedup).
	    if (text1 == text2) {
	        if (text1) {
	            return [[DIFF_EQUAL$1, text1]];
	        }
	        return [];
	    }
	    // Check cursor_pos within bounds
	    if (cursor_pos < 0 || text1.length < cursor_pos) {
	        cursor_pos = null;
	    }
	    // Trim off common prefix (speedup).
	    var commonlength = diff_commonPrefix$1(text1, text2);
	    var commonprefix = text1.substring(0, commonlength);
	    text1 = text1.substring(commonlength);
	    text2 = text2.substring(commonlength);
	    // Trim off common suffix (speedup).
	    commonlength = diff_commonSuffix$1(text1, text2);
	    var commonsuffix = text1.substring(text1.length - commonlength);
	    text1 = text1.substring(0, text1.length - commonlength);
	    text2 = text2.substring(0, text2.length - commonlength);
	    // Compute the diff on the middle block.
	    var diffs = diff_compute_$1(text1, text2);
	    // Restore the prefix and suffix.
	    if (commonprefix) {
	        diffs.unshift([DIFF_EQUAL$1, commonprefix]);
	    }
	    if (commonsuffix) {
	        diffs.push([DIFF_EQUAL$1, commonsuffix]);
	    }
	    diff_cleanupMerge$1(diffs);
	    if (cursor_pos != null) {
	        diffs = fix_cursor$1(diffs, cursor_pos);
	    }
	    diffs = fix_emoji$1(diffs);
	    return diffs;
	}
	/**
	 * Find the differences between two texts.  Assumes that the texts do not
	 * have any common prefix or suffix.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @return {Array} Array of diff tuples.
	 */
	function diff_compute_$1(text1, text2) {
	    var diffs;
	    if (!text1) {
	        // Just add some text (speedup).
	        return [[DIFF_INSERT$1, text2]];
	    }
	    if (!text2) {
	        // Just delete some text (speedup).
	        return [[DIFF_DELETE$1, text1]];
	    }
	    var longtext = text1.length > text2.length ? text1 : text2;
	    var shorttext = text1.length > text2.length ? text2 : text1;
	    var i = longtext.indexOf(shorttext);
	    if (i != -1) {
	        // Shorter text is inside the longer text (speedup).
	        diffs = [[DIFF_INSERT$1, longtext.substring(0, i)],
	            [DIFF_EQUAL$1, shorttext],
	            [DIFF_INSERT$1, longtext.substring(i + shorttext.length)]];
	        // Swap insertions for deletions if diff is reversed.
	        if (text1.length > text2.length) {
	            diffs[0][0] = diffs[2][0] = DIFF_DELETE$1;
	        }
	        return diffs;
	    }
	    if (shorttext.length == 1) {
	        // Single character string.
	        // After the previous speedup, the character can't be an equality.
	        return [[DIFF_DELETE$1, text1], [DIFF_INSERT$1, text2]];
	    }
	    // Check to see if the problem can be split in two.
	    var hm = diff_halfMatch_$1(text1, text2);
	    if (hm) {
	        // A half-match was found, sort out the return data.
	        var text1_a = hm[0];
	        var text1_b = hm[1];
	        var text2_a = hm[2];
	        var text2_b = hm[3];
	        var mid_common = hm[4];
	        // Send both pairs off for separate processing.
	        var diffs_a = diff$1(text1_a, text2_a);
	        var diffs_b = diff$1(text1_b, text2_b);
	        // Merge the results.
	        return diffs_a.concat([[DIFF_EQUAL$1, mid_common]], diffs_b);
	    }
	    return diff_bisect_$1(text1, text2);
	}
	/**
	 * Find the 'middle snake' of a diff, split the problem in two
	 * and return the recursively constructed diff.
	 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @return {Array} Array of diff tuples.
	 * @private
	 */
	function diff_bisect_$1(text1, text2) {
	    // Cache the text lengths to prevent multiple calls.
	    var text1_length = text1.length;
	    var text2_length = text2.length;
	    var max_d = Math.ceil((text1_length + text2_length) / 2);
	    var v_offset = max_d;
	    var v_length = 2 * max_d;
	    var v1 = new Array(v_length);
	    var v2 = new Array(v_length);
	    // Setting all elements to -1 is faster in Chrome & Firefox than mixing
	    // integers and undefined.
	    for (var x = 0; x < v_length; x++) {
	        v1[x] = -1;
	        v2[x] = -1;
	    }
	    v1[v_offset + 1] = 0;
	    v2[v_offset + 1] = 0;
	    var delta = text1_length - text2_length;
	    // If the total number of characters is odd, then the front path will collide
	    // with the reverse path.
	    var front = (delta % 2 != 0);
	    // Offsets for start and end of k loop.
	    // Prevents mapping of space beyond the grid.
	    var k1start = 0;
	    var k1end = 0;
	    var k2start = 0;
	    var k2end = 0;
	    for (var d = 0; d < max_d; d++) {
	        // Walk the front path one step.
	        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
	            var k1_offset = v_offset + k1;
	            var x1;
	            if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
	                x1 = v1[k1_offset + 1];
	            }
	            else {
	                x1 = v1[k1_offset - 1] + 1;
	            }
	            var y1 = x1 - k1;
	            while (x1 < text1_length && y1 < text2_length &&
	                text1.charAt(x1) == text2.charAt(y1)) {
	                x1++;
	                y1++;
	            }
	            v1[k1_offset] = x1;
	            if (x1 > text1_length) {
	                // Ran off the right of the graph.
	                k1end += 2;
	            }
	            else if (y1 > text2_length) {
	                // Ran off the bottom of the graph.
	                k1start += 2;
	            }
	            else if (front) {
	                var k2_offset = v_offset + delta - k1;
	                if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
	                    // Mirror x2 onto top-left coordinate system.
	                    var x2 = text1_length - v2[k2_offset];
	                    if (x1 >= x2) {
	                        // Overlap detected.
	                        return diff_bisectSplit_$1(text1, text2, x1, y1);
	                    }
	                }
	            }
	        }
	        // Walk the reverse path one step.
	        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
	            var k2_offset = v_offset + k2;
	            var x2;
	            if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
	                x2 = v2[k2_offset + 1];
	            }
	            else {
	                x2 = v2[k2_offset - 1] + 1;
	            }
	            var y2 = x2 - k2;
	            while (x2 < text1_length && y2 < text2_length &&
	                text1.charAt(text1_length - x2 - 1) ==
	                    text2.charAt(text2_length - y2 - 1)) {
	                x2++;
	                y2++;
	            }
	            v2[k2_offset] = x2;
	            if (x2 > text1_length) {
	                // Ran off the left of the graph.
	                k2end += 2;
	            }
	            else if (y2 > text2_length) {
	                // Ran off the top of the graph.
	                k2start += 2;
	            }
	            else if (!front) {
	                var k1_offset = v_offset + delta - k2;
	                if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
	                    var x1 = v1[k1_offset];
	                    var y1 = v_offset + x1 - k1_offset;
	                    // Mirror x2 onto top-left coordinate system.
	                    x2 = text1_length - x2;
	                    if (x1 >= x2) {
	                        // Overlap detected.
	                        return diff_bisectSplit_$1(text1, text2, x1, y1);
	                    }
	                }
	            }
	        }
	    }
	    // Diff took too long and hit the deadline or
	    // number of diffs equals number of characters, no commonality at all.
	    return [[DIFF_DELETE$1, text1], [DIFF_INSERT$1, text2]];
	}
	/**
	 * Given the location of the 'middle snake', split the diff in two parts
	 * and recurse.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} x Index of split point in text1.
	 * @param {number} y Index of split point in text2.
	 * @return {Array} Array of diff tuples.
	 */
	function diff_bisectSplit_$1(text1, text2, x, y) {
	    var text1a = text1.substring(0, x);
	    var text2a = text2.substring(0, y);
	    var text1b = text1.substring(x);
	    var text2b = text2.substring(y);
	    // Compute both diffs serially.
	    var diffs = diff$1(text1a, text2a);
	    var diffsb = diff$1(text1b, text2b);
	    return diffs.concat(diffsb);
	}
	/**
	 * Determine the common prefix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the start of each
	 *     string.
	 */
	function diff_commonPrefix$1(text1, text2) {
	    // Quick check for common null cases.
	    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
	        return 0;
	    }
	    // Binary search.
	    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	    var pointermin = 0;
	    var pointermax = Math.min(text1.length, text2.length);
	    var pointermid = pointermax;
	    var pointerstart = 0;
	    while (pointermin < pointermid) {
	        if (text1.substring(pointerstart, pointermid) ==
	            text2.substring(pointerstart, pointermid)) {
	            pointermin = pointermid;
	            pointerstart = pointermin;
	        }
	        else {
	            pointermax = pointermid;
	        }
	        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }
	    return pointermid;
	}
	/**
	 * Determine the common suffix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the end of each string.
	 */
	function diff_commonSuffix$1(text1, text2) {
	    // Quick check for common null cases.
	    if (!text1 || !text2 ||
	        text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
	        return 0;
	    }
	    // Binary search.
	    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	    var pointermin = 0;
	    var pointermax = Math.min(text1.length, text2.length);
	    var pointermid = pointermax;
	    var pointerend = 0;
	    while (pointermin < pointermid) {
	        if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
	            text2.substring(text2.length - pointermid, text2.length - pointerend)) {
	            pointermin = pointermid;
	            pointerend = pointermin;
	        }
	        else {
	            pointermax = pointermid;
	        }
	        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }
	    return pointermid;
	}
	/**
	 * Do the two texts share a substring which is at least half the length of the
	 * longer text?
	 * This speedup can produce non-minimal diffs.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {Array.<string>} Five element Array, containing the prefix of
	 *     text1, the suffix of text1, the prefix of text2, the suffix of
	 *     text2 and the common middle.  Or null if there was no match.
	 */
	function diff_halfMatch_$1(text1, text2) {
	    var longtext = text1.length > text2.length ? text1 : text2;
	    var shorttext = text1.length > text2.length ? text2 : text1;
	    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
	        return null; // Pointless.
	    }
	    /**
	     * Does a substring of shorttext exist within longtext such that the substring
	     * is at least half the length of longtext?
	     * Closure, but does not reference any external variables.
	     * @param {string} longtext Longer string.
	     * @param {string} shorttext Shorter string.
	     * @param {number} i Start index of quarter length substring within longtext.
	     * @return {Array.<string>} Five element Array, containing the prefix of
	     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
	     *     of shorttext and the common middle.  Or null if there was no match.
	     * @private
	     */
	    function diff_halfMatchI_(longtext, shorttext, i) {
	        // Start with a 1/4 length substring at position i as a seed.
	        var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
	        var j = -1;
	        var best_common = '';
	        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
	        while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
	            var prefixLength = diff_commonPrefix$1(longtext.substring(i), shorttext.substring(j));
	            var suffixLength = diff_commonSuffix$1(longtext.substring(0, i), shorttext.substring(0, j));
	            if (best_common.length < suffixLength + prefixLength) {
	                best_common = shorttext.substring(j - suffixLength, j) +
	                    shorttext.substring(j, j + prefixLength);
	                best_longtext_a = longtext.substring(0, i - suffixLength);
	                best_longtext_b = longtext.substring(i + prefixLength);
	                best_shorttext_a = shorttext.substring(0, j - suffixLength);
	                best_shorttext_b = shorttext.substring(j + prefixLength);
	            }
	        }
	        if (best_common.length * 2 >= longtext.length) {
	            return [best_longtext_a, best_longtext_b,
	                best_shorttext_a, best_shorttext_b, best_common];
	        }
	        else {
	            return null;
	        }
	    }
	    // First check if the second quarter is the seed for a half-match.
	    var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
	    // Check again based on the third quarter.
	    var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
	    var hm;
	    if (!hm1 && !hm2) {
	        return null;
	    }
	    else if (!hm2) {
	        hm = hm1;
	    }
	    else if (!hm1) {
	        hm = hm2;
	    }
	    else {
	        // Both matched.  Select the longest.
	        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
	    }
	    // A half-match was found, sort out the return data.
	    var text1_a, text1_b, text2_a, text2_b;
	    if (text1.length > text2.length) {
	        text1_a = hm[0];
	        text1_b = hm[1];
	        text2_a = hm[2];
	        text2_b = hm[3];
	    }
	    else {
	        text2_a = hm[0];
	        text2_b = hm[1];
	        text1_a = hm[2];
	        text1_b = hm[3];
	    }
	    var mid_common = hm[4];
	    return [text1_a, text1_b, text2_a, text2_b, mid_common];
	}
	/**
	 * Reorder and merge like edit sections.  Merge equalities.
	 * Any edit section can move as long as it doesn't cross an equality.
	 * @param {Array} diffs Array of diff tuples.
	 */
	function diff_cleanupMerge$1(diffs) {
	    diffs.push([DIFF_EQUAL$1, '']); // Add a dummy entry at the end.
	    var pointer = 0;
	    var count_delete = 0;
	    var count_insert = 0;
	    var text_delete = '';
	    var text_insert = '';
	    var commonlength;
	    while (pointer < diffs.length) {
	        switch (diffs[pointer][0]) {
	            case DIFF_INSERT$1:
	                count_insert++;
	                text_insert += diffs[pointer][1];
	                pointer++;
	                break;
	            case DIFF_DELETE$1:
	                count_delete++;
	                text_delete += diffs[pointer][1];
	                pointer++;
	                break;
	            case DIFF_EQUAL$1:
	                // Upon reaching an equality, check for prior redundancies.
	                if (count_delete + count_insert > 1) {
	                    if (count_delete !== 0 && count_insert !== 0) {
	                        // Factor out any common prefixies.
	                        commonlength = diff_commonPrefix$1(text_insert, text_delete);
	                        if (commonlength !== 0) {
	                            if ((pointer - count_delete - count_insert) > 0 &&
	                                diffs[pointer - count_delete - count_insert - 1][0] ==
	                                    DIFF_EQUAL$1) {
	                                diffs[pointer - count_delete - count_insert - 1][1] +=
	                                    text_insert.substring(0, commonlength);
	                            }
	                            else {
	                                diffs.splice(0, 0, [DIFF_EQUAL$1,
	                                    text_insert.substring(0, commonlength)]);
	                                pointer++;
	                            }
	                            text_insert = text_insert.substring(commonlength);
	                            text_delete = text_delete.substring(commonlength);
	                        }
	                        // Factor out any common suffixies.
	                        commonlength = diff_commonSuffix$1(text_insert, text_delete);
	                        if (commonlength !== 0) {
	                            diffs[pointer][1] = text_insert.substring(text_insert.length -
	                                commonlength) + diffs[pointer][1];
	                            text_insert = text_insert.substring(0, text_insert.length -
	                                commonlength);
	                            text_delete = text_delete.substring(0, text_delete.length -
	                                commonlength);
	                        }
	                    }
	                    // Delete the offending records and add the merged ones.
	                    if (count_delete === 0) {
	                        diffs.splice(pointer - count_insert, count_delete + count_insert, [DIFF_INSERT$1, text_insert]);
	                    }
	                    else if (count_insert === 0) {
	                        diffs.splice(pointer - count_delete, count_delete + count_insert, [DIFF_DELETE$1, text_delete]);
	                    }
	                    else {
	                        diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [DIFF_DELETE$1, text_delete], [DIFF_INSERT$1, text_insert]);
	                    }
	                    pointer = pointer - count_delete - count_insert +
	                        (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
	                }
	                else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL$1) {
	                    // Merge this equality with the previous one.
	                    diffs[pointer - 1][1] += diffs[pointer][1];
	                    diffs.splice(pointer, 1);
	                }
	                else {
	                    pointer++;
	                }
	                count_insert = 0;
	                count_delete = 0;
	                text_delete = '';
	                text_insert = '';
	                break;
	        }
	    }
	    if (diffs[diffs.length - 1][1] === '') {
	        diffs.pop(); // Remove the dummy entry at the end.
	    }
	    // Second pass: look for single edits surrounded on both sides by equalities
	    // which can be shifted sideways to eliminate an equality.
	    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
	    var changes = false;
	    pointer = 1;
	    // Intentionally ignore the first and last element (don't need checking).
	    while (pointer < diffs.length - 1) {
	        if (diffs[pointer - 1][0] == DIFF_EQUAL$1 &&
	            diffs[pointer + 1][0] == DIFF_EQUAL$1) {
	            // This is a single edit surrounded by equalities.
	            if (diffs[pointer][1].substring(diffs[pointer][1].length -
	                diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
	                // Shift the edit over the previous equality.
	                diffs[pointer][1] = diffs[pointer - 1][1] +
	                    diffs[pointer][1].substring(0, diffs[pointer][1].length -
	                        diffs[pointer - 1][1].length);
	                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
	                diffs.splice(pointer - 1, 1);
	                changes = true;
	            }
	            else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
	                diffs[pointer + 1][1]) {
	                // Shift the edit over the next equality.
	                diffs[pointer - 1][1] += diffs[pointer + 1][1];
	                diffs[pointer][1] =
	                    diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
	                        diffs[pointer + 1][1];
	                diffs.splice(pointer + 1, 1);
	                changes = true;
	            }
	        }
	        pointer++;
	    }
	    // If shifts were made, the diff needs reordering and another shift sweep.
	    if (changes) {
	        diff_cleanupMerge$1(diffs);
	    }
	}
	diff$1.INSERT = DIFF_INSERT$1;
	diff$1.DELETE = DIFF_DELETE$1;
	diff$1.EQUAL = DIFF_EQUAL$1;
	/*
	 * Modify a diff such that the cursor position points to the start of a change:
	 * E.g.
	 *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)
	 *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]
	 *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)
	 *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
	 * @return {Array} A tuple [cursor location in the modified diff, modified diff]
	 */
	function cursor_normalize_diff$1(diffs, cursor_pos) {
	    if (cursor_pos === 0) {
	        return [DIFF_EQUAL$1, diffs];
	    }
	    for (var current_pos = 0, i = 0; i < diffs.length; i++) {
	        var d = diffs[i];
	        if (d[0] === DIFF_DELETE$1 || d[0] === DIFF_EQUAL$1) {
	            var next_pos = current_pos + d[1].length;
	            if (cursor_pos === next_pos) {
	                return [i + 1, diffs];
	            }
	            else if (cursor_pos < next_pos) {
	                // copy to prevent side effects
	                diffs = diffs.slice();
	                // split d into two diff changes
	                var split_pos = cursor_pos - current_pos;
	                var d_left = [d[0], d[1].slice(0, split_pos)];
	                var d_right = [d[0], d[1].slice(split_pos)];
	                diffs.splice(i, 1, d_left, d_right);
	                return [i + 1, diffs];
	            }
	            else {
	                current_pos = next_pos;
	            }
	        }
	    }
	    throw new Error('cursor_pos is out of bounds!');
	}
	/*
	 * Modify a diff such that the edit position is "shifted" to the proposed edit location (cursor_position).
	 *
	 * Case 1)
	 *   Check if a naive shift is possible:
	 *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)
	 *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result
	 * Case 2)
	 *   Check if the following shifts are possible:
	 *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']
	 *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']
	 *         ^            ^
	 *         d          d_next
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
	 * @return {Array} Array of diff tuples
	 */
	function fix_cursor$1(diffs, cursor_pos) {
	    var norm = cursor_normalize_diff$1(diffs, cursor_pos);
	    var ndiffs = norm[1];
	    var cursor_pointer = norm[0];
	    var d = ndiffs[cursor_pointer];
	    var d_next = ndiffs[cursor_pointer + 1];
	    if (d == null) {
	        // Text was deleted from end of original string,
	        // cursor is now out of bounds in new string
	        return diffs;
	    }
	    else if (d[0] !== DIFF_EQUAL$1) {
	        // A modification happened at the cursor location.
	        // This is the expected outcome, so we can return the original diff.
	        return diffs;
	    }
	    else {
	        if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
	            // Case 1)
	            // It is possible to perform a naive shift
	            ndiffs.splice(cursor_pointer, 2, d_next, d);
	            return merge_tuples$1(ndiffs, cursor_pointer, 2);
	        }
	        else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
	            // Case 2)
	            // d[1] is a prefix of d_next[1]
	            // We can assume that d_next[0] !== 0, since d[0] === 0
	            // Shift edit locations..
	            ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
	            var suffix = d_next[1].slice(d[1].length);
	            if (suffix.length > 0) {
	                ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
	            }
	            return merge_tuples$1(ndiffs, cursor_pointer, 3);
	        }
	        else {
	            // Not possible to perform any modification
	            return diffs;
	        }
	    }
	}
	/*
	 * Check diff did not split surrogate pairs.
	 * Ex. [0, '\uD83D'], [-1, '\uDC36'], [1, '\uDC2F'] -> [-1, '\uD83D\uDC36'], [1, '\uD83D\uDC2F']
	 *     '\uD83D\uDC36' === '🐶', '\uD83D\uDC2F' === '🐯'
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @return {Array} Array of diff tuples
	 */
	function fix_emoji$1(diffs) {
	    var compact = false;
	    var starts_with_pair_end = function (str) {
	        return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;
	    };
	    var ends_with_pair_start = function (str) {
	        return str.charCodeAt(str.length - 1) >= 0xD800 && str.charCodeAt(str.length - 1) <= 0xDBFF;
	    };
	    for (var i = 2; i < diffs.length; i += 1) {
	        if (diffs[i - 2][0] === DIFF_EQUAL$1 && ends_with_pair_start(diffs[i - 2][1]) &&
	            diffs[i - 1][0] === DIFF_DELETE$1 && starts_with_pair_end(diffs[i - 1][1]) &&
	            diffs[i][0] === DIFF_INSERT$1 && starts_with_pair_end(diffs[i][1])) {
	            compact = true;
	            diffs[i - 1][1] = diffs[i - 2][1].slice(-1) + diffs[i - 1][1];
	            diffs[i][1] = diffs[i - 2][1].slice(-1) + diffs[i][1];
	            diffs[i - 2][1] = diffs[i - 2][1].slice(0, -1);
	        }
	    }
	    if (!compact) {
	        return diffs;
	    }
	    var fixed_diffs = [];
	    for (var i = 0; i < diffs.length; i += 1) {
	        if (diffs[i][1].length > 0) {
	            fixed_diffs.push(diffs[i]);
	        }
	    }
	    return fixed_diffs;
	}
	/*
	 * Try to merge tuples with their neigbors in a given range.
	 * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']
	 *
	 * @param {Array} diffs Array of diff tuples.
	 * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).
	 * @param {Int} length Number of consecutive elements to check.
	 * @return {Array} Array of merged diff tuples.
	 */
	function merge_tuples$1(diffs, start, length) {
	    // Check from (start-1) to (start+length).
	    for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {
	        if (i + 1 < diffs.length) {
	            var left_d = diffs[i];
	            var right_d = diffs[i + 1];
	            if (left_d[0] === right_d[1]) {
	                diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
	            }
	        }
	    }
	    return diffs;
	}

	function shallowEqual$1(valueA, valueB) {
	    return valueEqual$1(valueA, valueB, strictEqual$1);
	}
	function deepEqual$1(valueA, valueB) {
	    return valueEqual$1(valueA, valueB, valueEqual$1);
	}
	function strictEqual$1(valueA, valueB) {
	    return valueA === valueB;
	}
	function valueEqual$1(valueA, valueB, propEqual) {
	    if (valueA === valueB)
	        return true;
	    if (valueA instanceof Date && valueB instanceof Date)
	        return valueA.getTime() === valueB.getTime();
	    if (!valueA || !valueB || typeof valueA !== 'object' && typeof valueB !== 'object')
	        return valueA === valueB;
	    return objectEqual$1(valueA, valueB, propEqual);
	}
	function objectEqual$1(objA, objB, propEqual) {
	    if (objA.prototype !== objB.prototype)
	        return false;
	    var keysA = Object.keys(objA);
	    var keysB = Object.keys(objB);
	    if (keysA.length !== keysB.length)
	        return false;
	    return keysA.every(function (key, i) { return key === keysB[i] && propEqual(objA[key], objB[key], propEqual); });
	}

	var NULL_CHARACTER$1 = String.fromCharCode(0); // Placeholder char for embed in diff()
	var Delta$1 = /** @class */ (function () {
	    function Delta(ops) {
	        if (ops === void 0) { ops = []; }
	        this.ops = ops;
	    }
	    /**
	     * Appends an insert operation. Returns this for chainability.
	     *
	     * @param {String|Object} text Represents text or embed to insert
	     * @param {Object} attributes Optional attributes to apply
	     */
	    Delta.prototype.insert = function (text, attributes) {
	        var newOp = {};
	        if (text.length === 0)
	            return this;
	        newOp.insert = text;
	        if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
	            newOp.attributes = attributes;
	        }
	        return this._push(newOp);
	    };
	    /**
	     * Appends a delete operation. Returns this for chainability.
	     *
	     * @param {Number} length Number of characters to delete
	     */
	    Delta.prototype["delete"] = function (length) {
	        if (length <= 0)
	            return this;
	        return this._push({ "delete": length });
	    };
	    /**
	     * Appends a retain operation. Returns this for chainability.
	     *
	     * @param {Number} length Number of characters to retain
	     * @param {Object} attributes Optional attributes to apply
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.retain = function (length, attributes) {
	        if (length <= 0)
	            return this;
	        var newOp = { retain: length };
	        if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
	            newOp.attributes = attributes;
	        }
	        return this._push(newOp);
	    };
	    /**
	     * Freezes delta from future modifications. Returns this for chainability.
	     *
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.freeze = function () {
	        var _this = this;
	        this._push = function () { return _this; };
	        return this;
	    };
	    /**
	     * Adds a new operation. Returns this for chainability.
	     *
	     * @param {Object} newOp A new operation
	     * @returns {Delta} This delta
	     */
	    Delta.prototype._push = function (newOp) {
	        var index = this.ops.length;
	        var lastOp = this.ops[index - 1];
	        if (typeof lastOp === 'object') {
	            if (typeof newOp["delete"] === 'number' && typeof lastOp["delete"] === 'number') {
	                this.ops[index - 1] = { "delete": lastOp["delete"] + newOp["delete"] };
	                return this;
	            }
	            // Since it does not matter if we insert before or after deleting at the same index,
	            // always prefer to insert first
	            if (typeof lastOp["delete"] === 'number' && newOp.insert != null) {
	                index -= 1;
	                lastOp = this.ops[index - 1];
	                if (typeof lastOp !== 'object') {
	                    this.ops.unshift(newOp);
	                    return this;
	                }
	            }
	            if (deepEqual$1(newOp.attributes, lastOp.attributes)) {
	                if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {
	                    this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };
	                    if (typeof newOp.attributes === 'object')
	                        this.ops[index - 1].attributes = newOp.attributes;
	                    return this;
	                }
	                else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {
	                    this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };
	                    if (typeof newOp.attributes === 'object')
	                        this.ops[index - 1].attributes = newOp.attributes;
	                    return this;
	                }
	            }
	        }
	        if (index === this.ops.length) {
	            this.ops.push(newOp);
	        }
	        else {
	            this.ops.splice(index, 0, newOp);
	        }
	        return this;
	    };
	    /**
	     * Chops off trailing retain instructions to make the delta concise.
	     *
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.chop = function () {
	        var lastOp = this.ops[this.ops.length - 1];
	        if (lastOp && lastOp.retain && !lastOp.attributes) {
	            this.ops.pop();
	        }
	        return this;
	    };
	    /**
	     * Returns an iterator to iterate over the operations of this delta.
	     *
	     * @returns {Iterator} An operation iterator with methods hasNext, next, peek, peekLength, & peekType
	     */
	    Delta.prototype.iterator = function () {
	        return new Iterator$1(this.ops);
	    };
	    /**
	     * Returns an array of operations that passes a given function.
	     *
	     * @param {Function} predicate Function to test each operation against. Return true to keep the operation, false
	     *                             otherwise
	     * @returns {Array} Filtered resulting array
	     */
	    Delta.prototype.filter = function (predicate) {
	        return this.ops.filter(predicate);
	    };
	    /**
	     * Iterates through operations, calling the provided function for each operation.
	     *
	     * @param {Function} predicate Function to call during iteration, passing in the current operation
	     */
	    Delta.prototype.forEach = function (predicate) {
	        this.ops.forEach(predicate);
	    };
	    /**
	     * Returns a new array with the results of calling provided function on each operation.
	     *
	     * @param {Function} predicate Function to call, passing in the current operation, returning an element of the new
	     *                             array to be returned
	     * @returns {Array} A new array with each element being the result of the given function
	     */
	    Delta.prototype.map = function (predicate) {
	        return this.ops.map(predicate);
	    };
	    /**
	     * Create an array of two arrays, the first with operations that pass the given function, the other that failed.
	     *
	     * @param {Function} predicate Function to call, passing in the current operation, returning whether that operation
	     *                             passed
	     * @returns {Array} A new array of two Arrays, the first with passed operations, the other with failed operations
	     */
	    Delta.prototype.partition = function (predicate) {
	        var passed = [], failed = [];
	        this.forEach(function (op) {
	            var target = predicate(op) ? passed : failed;
	            target.push(op);
	        });
	        return [passed, failed];
	    };
	    /**
	     * Applies given function against an accumulator and each operation to reduce to a single value.
	     *
	     * @param {Function} predicate Function to call per iteration, returning an accumulated value
	     * @param {*} initial Initial value to pass to first call to predicate
	     * @returns {*} The accumulated value
	     */
	    Delta.prototype.reduce = function (predicate, initial) {
	        return this.ops.reduce(predicate, initial);
	    };
	    Delta.prototype.changeLength = function () {
	        return this.reduce(function (length, entry) {
	            if (entry.insert) {
	                return length + getOpLength$1(entry);
	            }
	            else if (entry["delete"]) {
	                return length - entry["delete"];
	            }
	            return length;
	        }, 0);
	    };
	    /**
	     * Returns length of a Delta, which is the sum of the lengths of its operations.
	     *
	     * @returns {Number} The length of this delta
	     */
	    Delta.prototype.length = function () {
	        return this.reduce(function (length, entry) {
	            return length + getOpLength$1(entry);
	        }, 0);
	    };
	    /**
	     * Returns copy of delta with subset of operations.
	     *
	     * @param {Number} start Start index of subset, defaults to 0
	     * @param {Number} end End index of subset, defaults to rest of operations
	     * @returns {Array} An array slice of the operations
	     */
	    Delta.prototype.slice = function (start, end) {
	        if (start === void 0) { start = 0; }
	        if (typeof end !== 'number')
	            end = Infinity;
	        var ops = [];
	        var iter = this.iterator();
	        var index = 0;
	        while (index < end && iter.hasNext()) {
	            var nextOp;
	            if (index < start) {
	                nextOp = iter.next(start - index);
	            }
	            else {
	                nextOp = iter.next(end - index);
	                ops.push(nextOp);
	            }
	            index += getOpLength$1(nextOp);
	        }
	        return new Delta(ops);
	    };
	    /**
	     * Returns a Delta that is equivalent to applying the operations of own Delta, followed by another Delta.
	     *
	     * @param {Delta} other Delta to compose
	     */
	    Delta.prototype.compose = function (other) {
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        var delta = new Delta();
	        while (thisIter.hasNext() || otherIter.hasNext()) {
	            if (otherIter.peekType() === 'insert') {
	                delta._push(otherIter.next());
	            }
	            else if (thisIter.peekType() === 'delete') {
	                delta._push(thisIter.next());
	            }
	            else {
	                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
	                var thisOp = thisIter.next(length);
	                var otherOp = otherIter.next(length);
	                if (typeof otherOp.retain === 'number') {
	                    var newOp = {};
	                    if (typeof thisOp.retain === 'number') {
	                        newOp.retain = length;
	                    }
	                    else {
	                        newOp.insert = thisOp.insert;
	                    }
	                    // Preserve null when composing with a retain, otherwise remove it for inserts
	                    var attributes = composeAttributes$1(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');
	                    if (attributes)
	                        newOp.attributes = attributes;
	                    delta._push(newOp);
	                    // Optimization if rest of other is just retain
	                    if (!otherIter.hasNext() && deepEqual$1(delta.ops[delta.ops.length - 1], newOp)) {
	                        var rest = new Delta(thisIter.rest());
	                        return delta.concat(rest).chop();
	                    }
	                    // Other op should be delete, we could be an insert or retain
	                    // Insert + delete cancels out
	                }
	                else if (typeof otherOp["delete"] === 'number' && typeof thisOp.retain === 'number') {
	                    delta._push(otherOp);
	                }
	            }
	        }
	        return delta.chop();
	    };
	    /**
	     * Returns a new Delta representing the concatenation of this and another document Delta's operations.
	     *
	     * @param {Delta} other Document Delta to concatenate
	     * @returns {Delta} Concatenated document Delta
	     */
	    Delta.prototype.concat = function (other) {
	        var delta = new Delta(this.ops.slice());
	        if (other.ops.length > 0) {
	            delta._push(other.ops[0]);
	            delta.ops = delta.ops.concat(other.ops.slice(1));
	        }
	        return delta;
	    };
	    /**
	     * Returns a Delta representing the difference between two documents. Optionally, accepts a suggested index where
	     * change took place, often representing a cursor position before change.
	     *
	     * @param {Delta} other Document Delta to diff against
	     * @param {Number} index Suggested index where change took place
	     * @returns {Delta} Difference between the two documents
	     */
	    Delta.prototype.diff = function (other, index) {
	        if (this.ops === other.ops) {
	            return new Delta();
	        }
	        var strings = [this, other].map(function (delta) {
	            return delta.map(function (op) {
	                if (op.insert != null) {
	                    return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER$1;
	                }
	                var prep = (delta === other) ? 'on' : 'with';
	                throw new Error('diff() called ' + prep + ' non-document');
	            }).join('');
	        });
	        var delta = new Delta();
	        var diffResult = diff$1(strings[0], strings[1], index);
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        diffResult.forEach(function (component) {
	            var length = component[1].length;
	            while (length > 0) {
	                var opLength = 0;
	                switch (component[0]) {
	                    case diff$1.INSERT:
	                        opLength = Math.min(otherIter.peekLength(), length);
	                        delta._push(otherIter.next(opLength));
	                        break;
	                    case diff$1.DELETE:
	                        opLength = Math.min(length, thisIter.peekLength());
	                        thisIter.next(opLength);
	                        delta["delete"](opLength);
	                        break;
	                    case diff$1.EQUAL:
	                        opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
	                        var thisOp = thisIter.next(opLength);
	                        var otherOp = otherIter.next(opLength);
	                        if (deepEqual$1(thisOp.insert, otherOp.insert)) {
	                            delta.retain(opLength, diffAttributes$1(thisOp.attributes, otherOp.attributes));
	                        }
	                        else {
	                            delta._push(otherOp)["delete"](opLength);
	                        }
	                        break;
	                }
	                length -= opLength;
	            }
	        });
	        return delta.chop();
	    };
	    /**
	     * Iterates through document Delta, calling a given function with a Delta and attributes object, representing the line
	     * segment.
	     *
	     * @param {Function} predicate Function to call on each line group
	     * @param {String} newline Newline character, defaults to \n
	     */
	    Delta.prototype.eachLine = function (predicate, newline) {
	        if (newline === void 0) { newline = '\n'; }
	        var iter = this.iterator();
	        var ops = new Delta();
	        var index = 0;
	        var lineStart = 0;
	        var currentIndex = 0;
	        while (iter.hasNext()) {
	            if (iter.peekType() !== 'insert')
	                return;
	            var op = iter.peek();
	            var nextLength = iter.peekLength();
	            var start = getOpLength$1(op) - nextLength;
	            var newlineIndex = typeof op.insert === 'string' ? op.insert.indexOf(newline, start) - start : -1;
	            if (newlineIndex < 0) {
	                currentIndex += nextLength;
	                ops._push(iter.next());
	            }
	            else if (newlineIndex > 0) {
	                currentIndex += newlineIndex;
	                ops._push(iter.next(newlineIndex));
	            }
	            else {
	                currentIndex += 1;
	                var attributes = iter.next(1).attributes || {};
	                var line = { ops: ops, attributes: attributes, start: lineStart, end: currentIndex, index: index };
	                if (predicate(line, index) === false) {
	                    return;
	                }
	                index += 1;
	                lineStart = currentIndex;
	                ops = new Delta();
	            }
	        }
	        if (ops.length() > 0) {
	            var line_1 = { ops: ops, attributes: {}, start: lineStart, end: currentIndex, index: index };
	            predicate(line_1, index);
	        }
	    };
	    // Extends Delta, get the lines from `from` to `to`.
	    Delta.prototype.getLines = function (from, to, newline) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = Infinity; }
	        var lines = [];
	        this.eachLine(function (line) {
	            if (line.start > to || (line.start === to && from !== to))
	                return false;
	            if (line.end > from) {
	                lines.push(line);
	            }
	        }, newline);
	        return lines;
	    };
	    // Extends Delta, get the line at `at`.
	    Delta.prototype.getLine = function (at, newline) {
	        return this.getLines(at, at, newline)[0];
	    };
	    // Extends Delta, get the ops from `from` to `to`.
	    Delta.prototype.getOps = function (from, to) {
	        var start = 0;
	        var ops = [];
	        this.ops.some(function (op) {
	            if (start >= to)
	                return true;
	            var end = start + getOpLength$1(op);
	            if (end > from || (from === to && end === to)) {
	                ops.push({ op: op, start: start, end: end });
	            }
	            start = end;
	        });
	        return ops;
	    };
	    // Extends Delta, get the op at `at`.
	    Delta.prototype.getOp = function (at) {
	        return this.getOps(at, at)[0];
	    };
	    /**
	     * Transform given Delta against own operations. Used as an alias for transformPosition when called with a number.
	     *
	     * @param {Delta} other Delta to transform
	     * @param {Boolean} priority Boolean used to break ties. If true, then this takes priority over other, that is, its
	     *                           actions are considered to happen "first."
	     * @returns {Delta} Transformed Delta
	     */
	    Delta.prototype.transform = function (other, priority) {
	        if (priority === void 0) { priority = false; }
	        if (typeof other === 'number') {
	            return this.transformPosition(other, priority);
	        }
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        var delta = new Delta();
	        while (thisIter.hasNext() || otherIter.hasNext()) {
	            if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {
	                delta.retain(getOpLength$1(thisIter.next()));
	            }
	            else if (otherIter.peekType() === 'insert') {
	                delta._push(otherIter.next());
	            }
	            else {
	                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
	                var thisOp = thisIter.next(length);
	                var otherOp = otherIter.next(length);
	                if (thisOp["delete"]) {
	                    // Our delete either makes their delete redundant or removes their retain
	                    continue;
	                }
	                else if (otherOp["delete"]) {
	                    delta._push(otherOp);
	                }
	                else {
	                    // We retain either their retain or insert
	                    delta.retain(length, transformAttributes$1(thisOp.attributes, otherOp.attributes, priority));
	                }
	            }
	        }
	        return delta.chop();
	    };
	    /**
	     * Transform an index against the delta. Useful for representing cursor/selection positions.
	     *
	     * @param {Number} index Index to transform
	     * @param {Boolean} priority Boolean used to break ties. If true, then this takes priority over other, that is, its
	     *                           actions are considered to happen "first."
	     * @returns {Number} Transformed index
	     */
	    Delta.prototype.transformPosition = function (index, priority) {
	        if (priority === void 0) { priority = false; }
	        var thisIter = this.iterator();
	        var offset = 0;
	        while (thisIter.hasNext() && offset <= index) {
	            var length = thisIter.peekLength();
	            var nextType = thisIter.peekType();
	            thisIter.next();
	            if (nextType === 'delete') {
	                index -= Math.min(length, index - offset);
	                continue;
	            }
	            else if (nextType === 'insert' && (offset < index || !priority)) {
	                index += length;
	            }
	            offset += length;
	        }
	        return index;
	    };
	    return Delta;
	}());
	/**
	 * Create an attributes object that is equivalent to applying the attributes of the target followed by the source.
	 *
	 * @param {Object} target Target attributes object which will have the source applied to
	 * @param {Object} source Source attributes object being applied to the target
	 * @param {Boolean} keepNull Whether to keep null values from source
	 * @returns {Object} A new attributes object (or undefined if empty) with both
	 */
	function composeAttributes$1(target, source, keepNull) {
	    if (target === void 0) { target = {}; }
	    if (source === void 0) { source = {}; }
	    var attributes = __assign$1({}, target, source);
	    if (!keepNull)
	        Object.keys(attributes).forEach(function (key) {
	            if (attributes[key] == null)
	                delete attributes[key];
	        });
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Finds the difference between two attributes objects. Returns the source attributes that are different from the
	 * target attributes.
	 *
	 * @param {Object} target An attributes object
	 * @param {Object} source An attributes object
	 * @returns {Object} The difference between the two attribute objects or undefined if there is none
	 */
	function diffAttributes$1(target, source) {
	    if (target === void 0) { target = {}; }
	    if (source === void 0) { source = {}; }
	    var attributes = Object.keys(target).concat(Object.keys(source)).reduce(function (attributes, key) {
	        if (!deepEqual$1(target[key], source[key])) {
	            attributes[key] = source[key] === undefined ? null : source[key];
	        }
	        return attributes;
	    }, {});
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Transforms the attributes of source over target (or the other way around if priority is set). Will return an
	 * attributes object which has all the values from source if priority if false or will have the values from source that
	 * are set on target.
	 *
	 * @param {Object} target An attributes object
	 * @param {Object} source An attributes object
	 * @param {Boolean} priority If target has priority over source
	 */
	function transformAttributes$1(target, source, priority) {
	    if (typeof target !== 'object')
	        return source;
	    if (typeof source !== 'object')
	        return undefined;
	    if (!priority)
	        return source; // b simply overwrites us without priority
	    var attributes = Object.keys(source).reduce(function (attributes, key) {
	        if (target[key] === undefined)
	            attributes[key] = source[key]; // null is a valid value
	        return attributes;
	    }, {});
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Determines the length of a Delta operation.
	 *
	 * @param {Object} op An operation entry from a Delta object
	 * @returns {Number} The length of the op
	 */
	function getOpLength$1(op) {
	    if (typeof op["delete"] === 'number') {
	        return op["delete"];
	    }
	    else if (typeof op.retain === 'number') {
	        return op.retain;
	    }
	    else {
	        return typeof op.insert === 'string' ? op.insert.length : 1;
	    }
	}
	/**
	 * An iterator to handle iterating over a list of Delta operations efficiently.
	 */
	var Iterator$1 = /** @class */ (function () {
	    function Iterator(ops) {
	        this.ops = ops;
	        this.index = 0;
	        this.offset = 0;
	    }
	    /**
	     * Determine if there will be another operation returned by `next`.
	     *
	     * @returns {Boolean} Whether there are more operations to iterate over
	     */
	    Iterator.prototype.hasNext = function () {
	        return this.peekLength() < Infinity;
	    };
	    /**
	     * Get the next operation, optionally limited/sliced by length. If an operation is sliced by length, the next call to
	     * `next` will return more of that operation until it is returned in full.
	     *
	     * @param {Number} length Optionally limit the returned operation by length, slicing it down as needed
	     */
	    Iterator.prototype.next = function (length) {
	        if (length === void 0) { length = Infinity; }
	        var nextOp = this.ops[this.index];
	        if (!nextOp)
	            return { retain: Infinity };
	        var offset = this.offset;
	        var opLength = getOpLength$1(nextOp);
	        // Update index and offset
	        if (length >= opLength - offset) {
	            length = opLength - offset;
	            this.index += 1;
	            this.offset = 0;
	        }
	        else {
	            this.offset += length;
	        }
	        if (typeof nextOp["delete"] === 'number') {
	            return { "delete": length };
	        }
	        else {
	            var retOp = {};
	            if (nextOp.attributes) {
	                retOp.attributes = nextOp.attributes;
	            }
	            if (typeof nextOp.retain === 'number') {
	                retOp.retain = length;
	            }
	            else if (typeof nextOp.insert === 'string') {
	                retOp.insert = nextOp.insert.substr(offset, length);
	            }
	            else {
	                // offset should === 0, length should === 1
	                retOp.insert = nextOp.insert;
	            }
	            return retOp;
	        }
	    };
	    /**
	     * Return the next entry.
	     *
	     * @returns {Object} The next entry in the ops array.
	     */
	    Iterator.prototype.peek = function () {
	        return this.ops[this.index];
	    };
	    /**
	     * Check the length of the next entry.
	     *
	     * @returns {Number} The length of the next entry or Infinity if there is no next entry
	     */
	    Iterator.prototype.peekLength = function () {
	        if (this.ops[this.index]) {
	            // Should never return 0 if our index is being managed correctly
	            return getOpLength$1(this.ops[this.index]) - this.offset;
	        }
	        else {
	            return Infinity;
	        }
	    };
	    /**
	     * Check the type of the next entry, delete, retain, or insert.
	     *
	     * @returns {String} The type of the next entry
	     */
	    Iterator.prototype.peekType = function () {
	        if (this.ops[this.index]) {
	            if (typeof this.ops[this.index]["delete"] === 'number') {
	                return 'delete';
	            }
	            else if (typeof this.ops[this.index].retain === 'number') {
	                return 'retain';
	            }
	            else {
	                return 'insert';
	            }
	        }
	        return 'retain';
	    };
	    Iterator.prototype.rest = function () {
	        if (!this.hasNext()) {
	            return [];
	        }
	        else if (this.offset === 0) {
	            return this.ops.slice(this.index);
	        }
	        else {
	            var offset = this.offset;
	            var index = this.index;
	            var next = this.next();
	            var rest = this.ops.slice(this.index);
	            this.offset = offset;
	            this.index = index;
	            return [next].concat(rest);
	        }
	    };
	    return Iterator;
	}());

	var SOURCE_API$1 = 'api';
	var SOURCE_USER$1 = 'user';
	var SOURCE_SILENT$1 = 'silent';
	var empty$1 = {};
	/**
	 * Event for text changes, called before the change has occurred. If a listener returns false the change will be
	 * canceled and not committed.
	 *
	 * @event Editor#text-changing
	 * @type  {Object}
	 * @property {Delta} change       The change which is being applied to the content
	 * @property {Delta} content      The new content after the change
	 * @property {Delta} oldContent   The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * Event for text changes, called after the change has occurred.
	 *
	 * @event Editor#text-change
	 * @type  {Object}
	 * @property {Delta} change       The change which is being applied to the content
	 * @property {Delta} content      The new content after the change
	 * @property {Delta} oldContent   The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * Event for selection changes. If part of a text change the `change`, `content`, and `oldContent` properties will be
	 * set. Otherwise they will not be set.
	 *
	 * @event Editor#selection-change
	 * @type  {Object}
	 * @property {Delta} change       [ Optional ] The change which is being applied to the content
	 * @property {Delta} content      [ Optional ] The new content after the change
	 * @property {Delta} oldContent   [ Optional ] The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * A Typewriter Editor handles the logic for selection and editing of contents. It has no dependency on browser APIs
	 * and can be used in Node.js as easily as the browser. It has no logic to limit formatting (i.e. it does not disallow
	 * using bold, headers, links, or FOOBAR), that will need to be limited outside of the editor itself.
	 *
	 * @fires Editor#text-changing
	 * @fires Editor#text-change
	 * @fires Editor#selection-change
	 *
	 * @readonly @property {Delta}  contents      The data model for the text editor
	 * @readonly @property {Number} length        The length of the contents
	 * @readonly @property {String} text          The text of the contents
	 * @readonly @property {Array}  selection     The current editor selection, a tuple of `[ from, to ]` or `null`
	 * @readonly @property {Object} activeFormats The currently active formats (formats that will apply on the next insert)
	 */
	var Editor$1 = /** @class */ (function (_super) {
	    __extends$1(Editor, _super);
	    /**
	     * Create a new Typewriter editor.
	     *
	     * @param {Object} options Options for this editor include initial `contents` and `modules`:
	     * @param {Delta}  options.contents The initial contents of this editor
	     */
	    function Editor(options) {
	        if (options === void 0) { options = {}; }
	        var _this = _super.call(this) || this;
	        _this.contents = null;
	        _this.length = 0;
	        _this.selection = null;
	        _this.activeFormats = empty$1;
	        setContents$1(_this, options.contents || _this.delta().insert('\n'));
	        _this._queuedEvents = []; // Event queuing ensure they are fired in order
	        return _this;
	    }
	    /**
	     * Convenience method for creating a new delta.
	     *
	     * @param {Array} ops [Optional] The initial ops for the delta
	     * @returns {Delta}   A new Delta object
	     */
	    Editor.prototype.delta = function (ops) {
	        return new Delta$1(ops);
	    };
	    /**
	     * Returns the contents or a slice of them.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {Delta}     The contents of this editor
	     */
	    Editor.prototype.getContents = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.contents.slice(from, to);
	    };
	    /**
	     * Returns the text for the editor or a slice of it.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {String}    The text in the editor
	     */
	    Editor.prototype.getText = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length - 1; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.getContents(from, to)
	            .filter(function (op) { return typeof op.insert === 'string'; })
	            .map(function (op) { return op.insert; })
	            .join('');
	    };
	    /**
	     * Returns the text for the editor with null characters in place of embeds. This can be used to determine the index of
	     * given words or lines of text within the contents.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {String}    The text in the editor with embed spaces
	     */
	    Editor.prototype.getExactText = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length - 1; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.getContents(from, to)
	            .map(function (op) { return typeof op.insert === 'string' ? op.insert : '\0'; })
	            .join('');
	    };
	    /**
	     * Set the selection to a new location (or null for no selection). Will return false if the new selection is the same
	     * as the old selection. Dispatches "selection-change" once the selection is changed. This "selection-change" event
	     * won't have { contents, oldContnts, change } in it since the selection is changing without any content updates.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Boolean}        Whether the selection changed or not
	     */
	    Editor.prototype.setSelection = function (from, to, source) {
	        var _this = this;
	        if (source === void 0) { source = SOURCE_USER$1; }
	        var _a;
	        var oldSelection = this.selection;
	        var selection;
	        if (from === null) {
	            selection = null;
	            if (typeof to === 'string')
	                source = to;
	        }
	        else {
	            _a = this._normalizeSelection(from, to, source), from = _a[0], to = _a[1], source = _a[2];
	            selection = [from, to].map(function (i) { return Math.min(i, _this.length - 1); });
	        }
	        if (shallowEqual$1(oldSelection, selection))
	            return false;
	        // Reset the active formats when selection changes (do this before setting selection)
	        this.activeFormats = selection ? this.getTextFormat(Math.min(selection[0], selection[1])) : empty$1;
	        this.selection = selection;
	        var event = { selection: selection, oldSelection: oldSelection, source: source };
	        if (source !== SOURCE_SILENT$1)
	            this.fire('selection-change', event);
	        this.fire('editor-change', event);
	        return true;
	    };
	    /**
	     * The method that all other methods use to update the contents (even setContents & setText). This method will
	     * dispatch the event "text-changing". If a listener returns `false` then the change will be canceled and null will
	     * be returned. Otherwise, the change will be successful and if the `source` is not "silent" a "text-change" event
	     * will be fired with an event object containing `{ contents, oldContents, selection, oldSelection, source }`. If the
	     * selection has changed as part of this update a "selection-change" event will also be fired with the same event
	     * object.
	     *
	     * @param {Delta} change    A delta change to the document
	     * @param {String} source   The source of the change, user, api, or silent
	     * @param {Array} selection Optional selection after the change has been applied
	     * @returns {Delta}         Returns the change when successful, or null if not
	     */
	    Editor.prototype.updateContents = function (change, source, selection) {
	        if (source === void 0) { source = SOURCE_API$1; }
	        if (!change.chop().ops.length)
	            return null;
	        if (typeof selection === 'number')
	            selection = [selection, selection];
	        var oldContents = this.contents;
	        var contents = normalizeContents$1(oldContents.compose(change));
	        var length = contents.length();
	        var oldSelection = this.selection;
	        if (!selection)
	            selection = oldSelection ? oldSelection.map(function (i) { return change.transform(i); }) : oldSelection;
	        selection = selection && this.getSelectedRange(selection, length - 1);
	        var changeEvent = { contents: contents, oldContents: oldContents, change: change, selection: selection, oldSelection: oldSelection, source: source };
	        var selectionChanged = !shallowEqual$1(oldSelection, selection);
	        if (!this.fire('text-changing', changeEvent))
	            return null;
	        setContents$1(this, contents);
	        if (selection) {
	            // Reset the active formats when selection changes (do this before setting selection)
	            this.activeFormats = selection ? this.getTextFormat(Math.min(selection[0], selection[1])) : empty$1;
	            this.selection = selection;
	        }
	        var events = [];
	        if (source !== SOURCE_SILENT$1) {
	            events.push(['text-change', changeEvent]);
	            if (selectionChanged)
	                events.push(['selection-change', changeEvent]);
	        }
	        events.push(['editor-change', changeEvent]);
	        this._queueEvents(events);
	        return change;
	    };
	    /**
	     * Sets the entire contents of the editor. This will calculate the difference between the old content and the new and
	     * only apply the difference, if any.
	     *
	     * @param {Delta} newContents The contents of the editor, as a delta object
	     * @param {String} source     The source of the change, user, api, or silent
	     * @param {Array} selection   Optional selection after the change has been applied
	     * @returns {Delta}           Returns the change when successful, or null if not
	     */
	    Editor.prototype.setContents = function (newContents, source, selection) {
	        var change = this.contents.diff(normalizeContents$1(newContents));
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Sets the text content of the editor, removing existing contents and formatting.
	     *
	     * @param {String} text     Set the contents of this editor as text
	     * @param {String} source   The source of the change, user, api, or silent
	     * @param {Array} selection Optional selection after the change has been applied
	     * @returns {Delta}         Returns the change when successful, or null if not
	     */
	    Editor.prototype.setText = function (text, source, selection) {
	        return this.setContents(this.delta().insert(text + '\n'), source, selection);
	    };
	    /**
	     * Inserts text into the content of the editor, removing text between from and to if provided. If `text` is a newline
	     * ("\n") then the formats will apply to the line, otherwise they will apply to the text only (even if there are
	     * newlines in the text).
	     *
	     * @param {Number} from      Insert the text at this index, can also be a range Array tuple, default 0
	     * @param {Number} to        If provided and not equal to `from` will delete the text between `from` and `to`
	     * @param {String} text      The text to insert into the editor's contents
	     * @param {Object} formats   The formats of the inserted text. If null the formats at `from` will be used.
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.insertText = function (from, to, text, formats, source, selection) {
	        var _a, _b, _c;
	        _a = this._normalizeRange(from, to, text, formats, source, selection), from = _a[0], to = _a[1], text = _a[2], formats = _a[3], source = _a[4], selection = _a[5];
	        // If we are not inserting a newline, make sure from and to are within the selectable range
	        if (text !== '\n')
	            _b = this.getSelectedRange([from, to]), from = _b[0], to = _b[1];
	        if (typeof formats === 'string')
	            _c = [null, formats, source], formats = _c[0], source = _c[1], selection = _c[2];
	        if (selection == null && this.selection !== null)
	            selection = from + text.length;
	        var change = this.delta().retain(from)["delete"](to - from);
	        if (text === '\n') {
	            change.insert('\n', formats || this.getLineFormat(from));
	        }
	        else {
	            var lineFormat_1 = text.indexOf('\n') === -1 ? null : this.getLineFormat(from);
	            var textFormat_1 = formats || this.getTextFormat(from);
	            text.split('\n').forEach(function (line, i) {
	                if (i)
	                    change.insert('\n', lineFormat_1);
	                line.length && change.insert(line, textFormat_1);
	            });
	        }
	        change = cleanDelete$1(this, from, to, change);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Inserts an embed into the content of the editor, removing text between from and to if provided.
	     *
	     * @param {Number} from      Insert the embed at this index, can also be a range Array tuple, default 0
	     * @param {Number} to        If provided and not equal to `from` will delete the text between `from` and `to`
	     * @param {String} embed     Insert the text into the editor's contents
	     * @param {mixed}  value     Insert the text into the editor's contents
	     * @param {String} formats   The formats of the inserted text. If null the formats at `from` will be used.
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.insertEmbed = function (from, to, embed, value, formats, source, selection) {
	        var _a, _b, _c;
	        _a = this._normalizeRange(from, to, embed, value, source, selection), from = _a[0], to = _a[1], embed = _a[2], value = _a[3], source = _a[4], selection = _a[5];
	        if (typeof formats === 'string')
	            _b = [null, formats, source], formats = _b[0], source = _b[1], selection = _b[2];
	        if (from >= this.length)
	            from = this.length - 1;
	        if (to >= this.length)
	            to = this.length - 1;
	        if (selection == null && this.selection !== null)
	            selection = from + 1;
	        var textFormat = formats || this.getTextFormat(from);
	        var change = this.delta().retain(from)["delete"](to - from).insert((_c = {}, _c[embed] = value, _c), textFormat);
	        change = cleanDelete$1(this, from, to, change);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Deletes text from `from` to `to`.
	     *
	     * @param {Number} from      Insert the text as this index, can also be a range Array tuple, default 0
	     * @param {Number} to        Will delete the text between `from` and `to`
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.deleteText = function (from, to, source, selection) {
	        var _a;
	        _a = this._normalizeRange(from, to, source, selection), from = _a[0], to = _a[1], source = _a[2], selection = _a[3];
	        if (from === to)
	            return null;
	        if (selection == null && this.selection !== null)
	            selection = from;
	        var change = this.delta().retain(from)["delete"](to - from);
	        change = cleanDelete$1(this, from, to, change);
	        // Keep the active format of the text to the right of the cursor when deleting
	        var activeFormats;
	        if (selection === from)
	            activeFormats = this.getTextFormat(from, from + 1);
	        var result = this.updateContents(change, source, selection);
	        if (result && activeFormats)
	            this.activeFormats = activeFormats;
	        return result;
	    };
	    /**
	     * Get the line formats for the line that `from` is in to the line that `to` is in. Returns only the common formats
	     * between all the lines. If `from` equals `to` (or `to` is not provided) the formats will be all of those for the
	     * line `from` is on. If two lines are touched and they have different formats, an empty object will be returned.
	     *
	     * @param {Number} from Getting line formats starting at `from`
	     * @param {Number} to   Getting line formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the lines which intersect from and to
	     */
	    Editor.prototype.getLineFormat = function (from, to) {
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        var formats;
	        this.contents.getLines(from, to).forEach(function (line) {
	            if (!line.attributes)
	                formats = {};
	            else if (!formats)
	                formats = __assign$1({}, line.attributes);
	            else
	                formats = combineFormats$1(formats, line.attributes);
	        });
	        return formats;
	    };
	    /**
	     * Get the text formats for all the text from `from` to `to`. Returns only the common formats between the two indexes.
	     * Will also return the `activeFormats`. Active formats are those which are toggled on when the selection is collapsed
	     * (from and to are equal) indicating inserted text should use (or not use) those formats.
	     *
	     * @param {Number} from Getting text formats starting at `from`
	     * @param {Number} to   Getting text formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the text
	     */
	    Editor.prototype.getTextFormat = function (from, to) {
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        var formats;
	        // optimize for current selection
	        var seleciton = this.selection;
	        if (from === to && shallowEqual$1(this.selection, [from, to])) {
	            return this.activeFormats;
	        }
	        this.contents.getOps(from, to).forEach(function (_a) {
	            var op = _a.op;
	            if (/^\n+$/.test(op.insert))
	                return;
	            if (!op.attributes)
	                formats = {};
	            else if (!formats)
	                formats = __assign$1({}, op.attributes);
	            else
	                formats = combineFormats$1(formats, op.attributes);
	        });
	        if (!formats)
	            formats = {};
	        return formats;
	    };
	    /**
	     * Get the text and line formats for all the lines and text from `from` to `to`.
	     *
	     * @param {Number} from Getting line and text formats starting at `from`
	     * @param {Number} to   Getting line and text formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the lines and text which intersect from and to
	     */
	    Editor.prototype.getFormat = function (from, to) {
	        return __assign$1({}, this.getTextFormat(from, to), this.getLineFormat(from, to));
	    };
	    /**
	     * Formats the lines intersected by `from` and `to` with the given line formats. To remove an existing format pass in
	     * `null` or `false` to turn it off (e.g. `{ blockquote: false }`).
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the line
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.formatLine = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var change = this.delta();
	        this.contents.getLines(from, to).forEach(function (line) {
	            if (!change.ops.length)
	                change.retain(line.end - 1);
	            else
	                change.retain(line.end - line.start - 1);
	            // Clear out old formats on the line
	            Object.keys(line.attributes).forEach(function (name) { return !formats[name] && (formats[name] = null); });
	            change.retain(1, formats);
	        });
	        change.chop();
	        return change.ops.length ? this.updateContents(change, source) : null;
	    };
	    /**
	     * Formats the text from `from` to `to` with the given text formats. To remove an existing format pass in `null` or
	     * `false` to turn it off (e.g. `{ bold: false }`).
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the text
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.formatText = function (from, to, formats, source) {
	        var _this = this;
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        if (from === to) {
	            if (this.activeFormats === empty$1)
	                this.activeFormats = {};
	            Object.keys(formats).forEach(function (key) {
	                var value = formats[key];
	                if (value == null || value === false)
	                    delete _this.activeFormats[key];
	                else
	                    _this.activeFormats[key] = value;
	            });
	            return;
	        }
	        Object.keys(formats).forEach(function (name) { return formats[name] === false && (formats[name] = null); });
	        var change = this.delta().retain(from);
	        this.getText(from, to).split('\n').forEach(function (line) {
	            line.length && change.retain(line.length, formats);
	            change.retain(1);
	        });
	        change.chop();
	        return this.updateContents(change, source);
	    };
	    /**
	     * Toggles the line formats from `from` to `to` with the given line formats. If the line has the exact formats already
	     * they will be removed, otherwise they will be added.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the line
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.toggleLineFormat = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var existing = this.getLineFormat(from, to);
	        if (deepEqual$1(existing, formats)) {
	            Object.keys(formats).forEach(function (key) { return formats[key] = null; });
	        }
	        return this.formatLine(from, to, formats, source);
	    };
	    /**
	     * Toggles the text formats from `from` to `to` with the given text formats. If the text has the exact formats already
	     * they will be removed, otherwise they will be added.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the text
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.toggleTextFormat = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var existing = this.getTextFormat(from, to);
	        var isSame = Object.keys(formats).every(function (key) { return formats[key] === existing[key]; });
	        if (isSame) {
	            Object.keys(formats).forEach(function (key) { return formats[key] = null; });
	        }
	        return this.formatText(from, to, formats, source);
	    };
	    /**
	     * Removes all formatting, text and line formats, for the text and lines from `from` to `to`.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.removeFormats = function (from, to, source) {
	        var _this = this;
	        var _a;
	        _a = this._normalizeRange(from, to, source), from = _a[0], to = _a[1], source = _a[2];
	        var formats = {};
	        this.contents.getOps(from, to).forEach(function (_a) {
	            var op = _a.op;
	            op.attributes && Object.keys(op.attributes).forEach(function (key) { return formats[key] = null; });
	        });
	        var change = this.delta().retain(from).retain(to - from, formats);
	        // If the last block was not captured be sure to clear that too
	        this.contents.getLines(from, to).forEach(function (line) {
	            var formats = {};
	            Object.keys(line.attributes).forEach(function (key) { return formats[key] = null; });
	            change = change.compose(_this.delta().retain(line.end - 1).retain(1, formats));
	        });
	        return this.updateContents(change, source);
	    };
	    /**
	     * Create a change delta calling one or more methods on the editor. The changes will not be applied as normal but will
	     * be collated into a single change delta and returned from this methnod. Example:
	     * ```js
	     * var change = editor.getChange(function() {
	     *   editor.deleteText(0, 5);
	     *   editor.insertText('\n', { blockquote: true });
	     *   editor.formatText(10, 20, { bold: true });
	     * });
	     *
	     * editor.updateContents(change, 'user');
	     * ```
	     *
	     * @param {Function} producer A function in which to call methods on the editor to produce a change
	     * @returns {Delta}           The sum of all the changes made within the producer
	     */
	    Editor.prototype.getChange = function (producer) {
	        var change = this.delta();
	        this.updateContents = function (singleChange) {
	            if (singleChange.ops.length) {
	                change = change.compose(singleChange);
	                return singleChange;
	            }
	            else {
	                return null;
	            }
	        };
	        producer(this);
	        delete this.updateContents;
	        return change;
	    };
	    /**
	     * Make several changes to the editor apply all at one in one commit. Changes made with the transaction will be
	     * applied all together and the "text-changing", "text-change", and "selection-change" events will be dispatched only
	     * once. Use this to combine multiple changes into one.
	     *
	     * @param {Function} producer A function which should make changes with the editor
	     * @param {String} source     The source of the change, user, api, or silent
	     * @param {Array} selection   Optional selection after the change has been applied
	     * @returns {Delta}           Returns the change when successful, or null if not
	     */
	    Editor.prototype.transaction = function (producer, source, selection) {
	        var change = this.getChange(producer);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Returns the selected range (or the provided range) in index order (lowest number first) and within the bounds of
	     * the content, between 0 and content.length() - 1 (the selection cannot be past the trailing newline).
	     *
	     * @param {Array} range Optional range, defaults to current selection
	     * @param {Number} max  The maxium number the range can be
	     */
	    Editor.prototype.getSelectedRange = function (range, max) {
	        if (range === void 0) { range = this.selection; }
	        if (max === void 0) { max = this.length - 1; }
	        var _a;
	        if (range == null)
	            return range;
	        if (typeof range === 'number')
	            range = [range, range];
	        if (range[0] > range[1])
	            _a = [range[1], range[0]], range[0] = _a[0], range[1] = _a[1];
	        return range.map(function (index) { return Math.max(0, Math.min(max, index)); });
	    };
	    Editor.prototype._queueEvents = function (events) {
	        var _a;
	        var alreadyRunning = this._queuedEvents.length;
	        (_a = this._queuedEvents).push.apply(_a, events);
	        if (alreadyRunning)
	            return;
	        while (this._queuedEvents.length) {
	            var event = this._queuedEvents.shift();
	            this.fire.apply(this, event);
	        }
	    };
	    /**
	     * Normalizes range values to a proper range if it is not already. A range is a `from` and a `to` index, e.g. 0, 4.
	     * This will ensure the lower index is first. Example usage:
	     * editor._normalizeRange(5); // [5, 5]
	     * editor._normalizeRange(-4, 100); // for a doc with length 10, [0, 10]
	     * editor._normalizeRange(25, 18); // [18, 25]
	     * editor._normalizeRange([12, 13]); // [12, 13]
	     * editor._normalizeRange(5, { bold: true }); // [5, 5, { bold: true }]
	     */
	    Editor.prototype._normalizeRange = function (from, to) {
	        var rest = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            rest[_i - 2] = arguments[_i];
	        }
	        var _a;
	        _a = this._normalizeSelection.apply(this, [from, to].concat(rest)), from = _a[0], to = _a[1], rest = _a.slice(2);
	        if (from > to) {
	            var toValue = from;
	            from = to;
	            to = toValue;
	        }
	        return [from, to].concat(rest);
	    };
	    Editor.prototype._normalizeSelection = function (from, to) {
	        var rest = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            rest[_i - 2] = arguments[_i];
	        }
	        var _a;
	        if (Array.isArray(from)) {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            _a = from, from = _a[0], to = _a[1];
	            if (to === undefined)
	                to = from;
	        }
	        else if (typeof from !== 'number') {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            if (from !== undefined || rest.length)
	                rest.unshift(from);
	            from = to = 0;
	        }
	        else if (typeof to !== 'number') {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            to = from;
	        }
	        from = Math.max(0, Math.min(this.length, Math.floor(from)));
	        to = Math.max(0, Math.min(this.length, Math.floor(to)));
	        return [from, to].concat(rest);
	    };
	    return Editor;
	}(EventDispatcher$1));
	// Ensures the format for the current line in a delete remains the same when multiple lines are deleted. This is needed
	// because the last line holds the formatting after a delete, but the first line is expected to be the retained format
	function cleanDelete$1(editor, from, to, change) {
	    if (from !== to) {
	        var line = editor.contents.getLine(from);
	        if (!line.ops.length() && to === from + 1)
	            return change;
	        var lineFormat_2 = editor.getLineFormat(from);
	        if (!deepEqual$1(lineFormat_2, editor.getLineFormat(to))) {
	            var lineChange = editor.getChange(function () { return editor.formatLine(to, lineFormat_2); });
	            change = change.compose(change.transform(lineChange));
	        }
	    }
	    return change;
	}
	// Ensures contents end with a newline
	function normalizeContents$1(contents) {
	    // Contents only have inserts. Deletes and retains belong to changes only.
	    contents.ops = contents.ops.filter(function (op) { return op.insert; });
	    var lastOp = contents.ops[contents.ops.length - 1];
	    if (!lastOp || typeof lastOp.insert !== 'string' || lastOp.insert.slice(-1) !== '\n')
	        contents.insert('\n');
	    return contents;
	}
	// Sets the contents onto the editor after ensuring they end in a newline, freezes the contents from change, and
	// updates the length and text of the editor to the latest
	function setContents$1(editor, contents) {
	    contents = normalizeContents$1(contents);
	    contents.freeze();
	    editor.contents = contents;
	    editor.length = contents.length();
	}
	// Combine formats removing ones that don't exist in both and creating an array for those with multiple values
	function combineFormats$1(formats, combined) {
	    return Object.keys(combined).reduce(function (merged, name) {
	        if (formats[name] == null)
	            return merged;
	        if (combined[name] === formats[name]) {
	            merged[name] = combined[name];
	        }
	        else if (Array.isArray(combined[name])) {
	            if (combined[name].indexOf(formats[name]) < 0) {
	                merged[name] = combined[name].concat([formats[name]]);
	            }
	        }
	        else {
	            merged[name] = [combined[name], formats[name]];
	        }
	        return merged;
	    }, {});
	}
	var isMac = navigator.userAgent.indexOf('Macintosh') !== -1;

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */

	function __rest(s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
	            t[p[i]] = s[p[i]];
	    return t;
	}

	function getDefaultPaper() {
	    return new Paper({
	        blocks: [paragraph, header, list, blockquote, codeblock, hr],
	        marks: [link, decorator, bold, italic, code],
	        embeds: [image, br, decorator]
	    });
	}
	var paragraph = {
	    name: 'paragraph',
	    selector: 'p'
	};
	var header = {
	    name: 'header',
	    selector: 'h1, h2, h3, h4, h5, h6',
	    defaultFollows: true,
	    fromDom: function (node) { return ({ header: parseInt(node.nodeName.replace('H', '')) }); }
	};
	var list = {
	    name: 'list',
	    selector: 'ul > li, ol > li',
	    indentable: true,
	    fromDom: function (node) {
	        var indent = -1, parent = node.parentNode;
	        var list = parent.nodeName === 'OL' ? 'ordered' : 'bullet';
	        while (parent) {
	            if (/^UL|OL$/.test(parent.nodeName))
	                indent++;
	            else if (parent.nodeName !== 'LI')
	                break;
	            parent = parent.parentNode;
	        }
	        var attr = { list: list };
	        if (indent)
	            attr.indent = indent;
	        return attr;
	    },
	    getNextLineAttributes: function (attrs) {
	        var start = attrs.start, rest = __rest(attrs, ["start"]);
	        return rest;
	    }
	};
	var blockquote = {
	    name: 'blockquote',
	    selector: 'blockquote p'
	};
	var codeblock = {
	    name: 'code-block',
	    selector: 'pre code, pre'
	};
	var hr = {
	    name: 'hr',
	    selector: 'hr'
	};
	var bold = {
	    name: 'bold',
	    selector: 'strong, b',
	    styleSelector: '[style*="bold"]'
	};
	var italic = {
	    name: 'italic',
	    selector: 'em, i',
	    styleSelector: '[style*="italic"]'
	};
	var code = {
	    name: 'code',
	    selector: 'code'
	};
	var link = {
	    name: 'link',
	    selector: 'a[href]',
	    fromDom: function (node) { return node.href; }
	};
	var image = {
	    name: 'image',
	    selector: 'img',
	    fromDom: function (node) { return node.src; }
	};
	var br = {
	    name: 'br',
	    selector: 'br'
	};
	// Decorators are not part of the content
	var decorator = {
	    name: 'decorator',
	    selector: 'span.decorator'
	};

	/**
	 * Defines the blocks, marks, and embeds that can be used in a Typewriter document.
	 */

	// Determines if a <br> in the editable area is part of the document or a doorstop at the end of a block.
	function isBRPlaceholder(paper, node) {
	    if (node.nodeName !== 'BR')
	        return false;
	    var blocks = paper.blocks;
	    var next = node.nextSibling;
	    while (next && next.nodeValue === '')
	        next = next.nextSibling;
	    if (next) {
	        return next.nodeType === Node.ELEMENT_NODE && blocks.matches(next);
	    }
	    return blocks.matches(node.parentNode);
	}

	var dispatcherEvents$2 = new WeakMap();
	var EventDispatcher$2 = /** @class */ (function () {
	    function EventDispatcher() {
	    }
	    EventDispatcher.prototype.on = function (type, listener) {
	        getEventListeners$2(this, type, true).add(listener);
	    };
	    EventDispatcher.prototype.off = function (type, listener) {
	        var events = getEventListeners$2(this, type);
	        events && events["delete"](listener);
	    };
	    EventDispatcher.prototype.once = function (type, listener) {
	        function once() {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            this.off(type, once);
	            listener.apply(this, args);
	        }
	        this.on(type, once);
	    };
	    EventDispatcher.prototype.fire = function (type) {
	        var _this = this;
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        var uncanceled = true;
	        var events = getEventListeners$2(this, type);
	        if (events)
	            events.forEach(function (listener) {
	                uncanceled && listener.apply(_this, args) !== false || (uncanceled = false);
	            });
	        return uncanceled;
	    };
	    return EventDispatcher;
	}());
	function getEventListeners$2(obj, type, autocreate) {
	    if (autocreate === void 0) { autocreate = false; }
	    var events = dispatcherEvents$2.get(obj);
	    if (!events && autocreate)
	        dispatcherEvents$2.set(obj, events = Object.create(null));
	    return events && events[type] || autocreate && (events[type] = new Set());
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics$2 = function(d, b) {
	    extendStatics$2 = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return extendStatics$2(d, b);
	};

	function __extends$2(d, b) {
	    extendStatics$2(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign$2 = function() {
	    __assign$2 = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2.apply(this, arguments);
	};

	/**
	 * This library modifies the diff-patch-match library by Neil Fraser
	 * by removing the patch and match functionality and certain advanced
	 * options in the diff function. The original license is as follows:
	 *
	 * ===
	 *
	 * Diff Match and Patch
	 *
	 * Copyright 2006 Google Inc.
	 * http://code.google.com/p/google-diff-match-patch/
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * The data structure representing a diff is an array of tuples:
	 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
	 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
	 */
	var DIFF_DELETE$2 = -1;
	var DIFF_INSERT$2 = 1;
	var DIFF_EQUAL$2 = 0;
	/**
	 * Find the differences between two texts.  Simplifies the problem by stripping
	 * any common prefix or suffix off the texts before diffing.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {Int} cursor_pos Expected edit position in text1 (optional)
	 * @return {Array} Array of diff tuples.
	 */
	function diff$2(text1, text2, cursor_pos) {
	    // Check for equality (speedup).
	    if (text1 == text2) {
	        if (text1) {
	            return [[DIFF_EQUAL$2, text1]];
	        }
	        return [];
	    }
	    // Check cursor_pos within bounds
	    if (cursor_pos < 0 || text1.length < cursor_pos) {
	        cursor_pos = null;
	    }
	    // Trim off common prefix (speedup).
	    var commonlength = diff_commonPrefix$2(text1, text2);
	    var commonprefix = text1.substring(0, commonlength);
	    text1 = text1.substring(commonlength);
	    text2 = text2.substring(commonlength);
	    // Trim off common suffix (speedup).
	    commonlength = diff_commonSuffix$2(text1, text2);
	    var commonsuffix = text1.substring(text1.length - commonlength);
	    text1 = text1.substring(0, text1.length - commonlength);
	    text2 = text2.substring(0, text2.length - commonlength);
	    // Compute the diff on the middle block.
	    var diffs = diff_compute_$2(text1, text2);
	    // Restore the prefix and suffix.
	    if (commonprefix) {
	        diffs.unshift([DIFF_EQUAL$2, commonprefix]);
	    }
	    if (commonsuffix) {
	        diffs.push([DIFF_EQUAL$2, commonsuffix]);
	    }
	    diff_cleanupMerge$2(diffs);
	    if (cursor_pos != null) {
	        diffs = fix_cursor$2(diffs, cursor_pos);
	    }
	    diffs = fix_emoji$2(diffs);
	    return diffs;
	}
	/**
	 * Find the differences between two texts.  Assumes that the texts do not
	 * have any common prefix or suffix.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @return {Array} Array of diff tuples.
	 */
	function diff_compute_$2(text1, text2) {
	    var diffs;
	    if (!text1) {
	        // Just add some text (speedup).
	        return [[DIFF_INSERT$2, text2]];
	    }
	    if (!text2) {
	        // Just delete some text (speedup).
	        return [[DIFF_DELETE$2, text1]];
	    }
	    var longtext = text1.length > text2.length ? text1 : text2;
	    var shorttext = text1.length > text2.length ? text2 : text1;
	    var i = longtext.indexOf(shorttext);
	    if (i != -1) {
	        // Shorter text is inside the longer text (speedup).
	        diffs = [[DIFF_INSERT$2, longtext.substring(0, i)],
	            [DIFF_EQUAL$2, shorttext],
	            [DIFF_INSERT$2, longtext.substring(i + shorttext.length)]];
	        // Swap insertions for deletions if diff is reversed.
	        if (text1.length > text2.length) {
	            diffs[0][0] = diffs[2][0] = DIFF_DELETE$2;
	        }
	        return diffs;
	    }
	    if (shorttext.length == 1) {
	        // Single character string.
	        // After the previous speedup, the character can't be an equality.
	        return [[DIFF_DELETE$2, text1], [DIFF_INSERT$2, text2]];
	    }
	    // Check to see if the problem can be split in two.
	    var hm = diff_halfMatch_$2(text1, text2);
	    if (hm) {
	        // A half-match was found, sort out the return data.
	        var text1_a = hm[0];
	        var text1_b = hm[1];
	        var text2_a = hm[2];
	        var text2_b = hm[3];
	        var mid_common = hm[4];
	        // Send both pairs off for separate processing.
	        var diffs_a = diff$2(text1_a, text2_a);
	        var diffs_b = diff$2(text1_b, text2_b);
	        // Merge the results.
	        return diffs_a.concat([[DIFF_EQUAL$2, mid_common]], diffs_b);
	    }
	    return diff_bisect_$2(text1, text2);
	}
	/**
	 * Find the 'middle snake' of a diff, split the problem in two
	 * and return the recursively constructed diff.
	 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @return {Array} Array of diff tuples.
	 * @private
	 */
	function diff_bisect_$2(text1, text2) {
	    // Cache the text lengths to prevent multiple calls.
	    var text1_length = text1.length;
	    var text2_length = text2.length;
	    var max_d = Math.ceil((text1_length + text2_length) / 2);
	    var v_offset = max_d;
	    var v_length = 2 * max_d;
	    var v1 = new Array(v_length);
	    var v2 = new Array(v_length);
	    // Setting all elements to -1 is faster in Chrome & Firefox than mixing
	    // integers and undefined.
	    for (var x = 0; x < v_length; x++) {
	        v1[x] = -1;
	        v2[x] = -1;
	    }
	    v1[v_offset + 1] = 0;
	    v2[v_offset + 1] = 0;
	    var delta = text1_length - text2_length;
	    // If the total number of characters is odd, then the front path will collide
	    // with the reverse path.
	    var front = (delta % 2 != 0);
	    // Offsets for start and end of k loop.
	    // Prevents mapping of space beyond the grid.
	    var k1start = 0;
	    var k1end = 0;
	    var k2start = 0;
	    var k2end = 0;
	    for (var d = 0; d < max_d; d++) {
	        // Walk the front path one step.
	        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
	            var k1_offset = v_offset + k1;
	            var x1;
	            if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
	                x1 = v1[k1_offset + 1];
	            }
	            else {
	                x1 = v1[k1_offset - 1] + 1;
	            }
	            var y1 = x1 - k1;
	            while (x1 < text1_length && y1 < text2_length &&
	                text1.charAt(x1) == text2.charAt(y1)) {
	                x1++;
	                y1++;
	            }
	            v1[k1_offset] = x1;
	            if (x1 > text1_length) {
	                // Ran off the right of the graph.
	                k1end += 2;
	            }
	            else if (y1 > text2_length) {
	                // Ran off the bottom of the graph.
	                k1start += 2;
	            }
	            else if (front) {
	                var k2_offset = v_offset + delta - k1;
	                if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
	                    // Mirror x2 onto top-left coordinate system.
	                    var x2 = text1_length - v2[k2_offset];
	                    if (x1 >= x2) {
	                        // Overlap detected.
	                        return diff_bisectSplit_$2(text1, text2, x1, y1);
	                    }
	                }
	            }
	        }
	        // Walk the reverse path one step.
	        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
	            var k2_offset = v_offset + k2;
	            var x2;
	            if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
	                x2 = v2[k2_offset + 1];
	            }
	            else {
	                x2 = v2[k2_offset - 1] + 1;
	            }
	            var y2 = x2 - k2;
	            while (x2 < text1_length && y2 < text2_length &&
	                text1.charAt(text1_length - x2 - 1) ==
	                    text2.charAt(text2_length - y2 - 1)) {
	                x2++;
	                y2++;
	            }
	            v2[k2_offset] = x2;
	            if (x2 > text1_length) {
	                // Ran off the left of the graph.
	                k2end += 2;
	            }
	            else if (y2 > text2_length) {
	                // Ran off the top of the graph.
	                k2start += 2;
	            }
	            else if (!front) {
	                var k1_offset = v_offset + delta - k2;
	                if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
	                    var x1 = v1[k1_offset];
	                    var y1 = v_offset + x1 - k1_offset;
	                    // Mirror x2 onto top-left coordinate system.
	                    x2 = text1_length - x2;
	                    if (x1 >= x2) {
	                        // Overlap detected.
	                        return diff_bisectSplit_$2(text1, text2, x1, y1);
	                    }
	                }
	            }
	        }
	    }
	    // Diff took too long and hit the deadline or
	    // number of diffs equals number of characters, no commonality at all.
	    return [[DIFF_DELETE$2, text1], [DIFF_INSERT$2, text2]];
	}
	/**
	 * Given the location of the 'middle snake', split the diff in two parts
	 * and recurse.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} x Index of split point in text1.
	 * @param {number} y Index of split point in text2.
	 * @return {Array} Array of diff tuples.
	 */
	function diff_bisectSplit_$2(text1, text2, x, y) {
	    var text1a = text1.substring(0, x);
	    var text2a = text2.substring(0, y);
	    var text1b = text1.substring(x);
	    var text2b = text2.substring(y);
	    // Compute both diffs serially.
	    var diffs = diff$2(text1a, text2a);
	    var diffsb = diff$2(text1b, text2b);
	    return diffs.concat(diffsb);
	}
	/**
	 * Determine the common prefix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the start of each
	 *     string.
	 */
	function diff_commonPrefix$2(text1, text2) {
	    // Quick check for common null cases.
	    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
	        return 0;
	    }
	    // Binary search.
	    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	    var pointermin = 0;
	    var pointermax = Math.min(text1.length, text2.length);
	    var pointermid = pointermax;
	    var pointerstart = 0;
	    while (pointermin < pointermid) {
	        if (text1.substring(pointerstart, pointermid) ==
	            text2.substring(pointerstart, pointermid)) {
	            pointermin = pointermid;
	            pointerstart = pointermin;
	        }
	        else {
	            pointermax = pointermid;
	        }
	        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }
	    return pointermid;
	}
	/**
	 * Determine the common suffix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the end of each string.
	 */
	function diff_commonSuffix$2(text1, text2) {
	    // Quick check for common null cases.
	    if (!text1 || !text2 ||
	        text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
	        return 0;
	    }
	    // Binary search.
	    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	    var pointermin = 0;
	    var pointermax = Math.min(text1.length, text2.length);
	    var pointermid = pointermax;
	    var pointerend = 0;
	    while (pointermin < pointermid) {
	        if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
	            text2.substring(text2.length - pointermid, text2.length - pointerend)) {
	            pointermin = pointermid;
	            pointerend = pointermin;
	        }
	        else {
	            pointermax = pointermid;
	        }
	        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }
	    return pointermid;
	}
	/**
	 * Do the two texts share a substring which is at least half the length of the
	 * longer text?
	 * This speedup can produce non-minimal diffs.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {Array.<string>} Five element Array, containing the prefix of
	 *     text1, the suffix of text1, the prefix of text2, the suffix of
	 *     text2 and the common middle.  Or null if there was no match.
	 */
	function diff_halfMatch_$2(text1, text2) {
	    var longtext = text1.length > text2.length ? text1 : text2;
	    var shorttext = text1.length > text2.length ? text2 : text1;
	    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
	        return null; // Pointless.
	    }
	    /**
	     * Does a substring of shorttext exist within longtext such that the substring
	     * is at least half the length of longtext?
	     * Closure, but does not reference any external variables.
	     * @param {string} longtext Longer string.
	     * @param {string} shorttext Shorter string.
	     * @param {number} i Start index of quarter length substring within longtext.
	     * @return {Array.<string>} Five element Array, containing the prefix of
	     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
	     *     of shorttext and the common middle.  Or null if there was no match.
	     * @private
	     */
	    function diff_halfMatchI_(longtext, shorttext, i) {
	        // Start with a 1/4 length substring at position i as a seed.
	        var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
	        var j = -1;
	        var best_common = '';
	        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
	        while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
	            var prefixLength = diff_commonPrefix$2(longtext.substring(i), shorttext.substring(j));
	            var suffixLength = diff_commonSuffix$2(longtext.substring(0, i), shorttext.substring(0, j));
	            if (best_common.length < suffixLength + prefixLength) {
	                best_common = shorttext.substring(j - suffixLength, j) +
	                    shorttext.substring(j, j + prefixLength);
	                best_longtext_a = longtext.substring(0, i - suffixLength);
	                best_longtext_b = longtext.substring(i + prefixLength);
	                best_shorttext_a = shorttext.substring(0, j - suffixLength);
	                best_shorttext_b = shorttext.substring(j + prefixLength);
	            }
	        }
	        if (best_common.length * 2 >= longtext.length) {
	            return [best_longtext_a, best_longtext_b,
	                best_shorttext_a, best_shorttext_b, best_common];
	        }
	        else {
	            return null;
	        }
	    }
	    // First check if the second quarter is the seed for a half-match.
	    var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
	    // Check again based on the third quarter.
	    var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
	    var hm;
	    if (!hm1 && !hm2) {
	        return null;
	    }
	    else if (!hm2) {
	        hm = hm1;
	    }
	    else if (!hm1) {
	        hm = hm2;
	    }
	    else {
	        // Both matched.  Select the longest.
	        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
	    }
	    // A half-match was found, sort out the return data.
	    var text1_a, text1_b, text2_a, text2_b;
	    if (text1.length > text2.length) {
	        text1_a = hm[0];
	        text1_b = hm[1];
	        text2_a = hm[2];
	        text2_b = hm[3];
	    }
	    else {
	        text2_a = hm[0];
	        text2_b = hm[1];
	        text1_a = hm[2];
	        text1_b = hm[3];
	    }
	    var mid_common = hm[4];
	    return [text1_a, text1_b, text2_a, text2_b, mid_common];
	}
	/**
	 * Reorder and merge like edit sections.  Merge equalities.
	 * Any edit section can move as long as it doesn't cross an equality.
	 * @param {Array} diffs Array of diff tuples.
	 */
	function diff_cleanupMerge$2(diffs) {
	    diffs.push([DIFF_EQUAL$2, '']); // Add a dummy entry at the end.
	    var pointer = 0;
	    var count_delete = 0;
	    var count_insert = 0;
	    var text_delete = '';
	    var text_insert = '';
	    var commonlength;
	    while (pointer < diffs.length) {
	        switch (diffs[pointer][0]) {
	            case DIFF_INSERT$2:
	                count_insert++;
	                text_insert += diffs[pointer][1];
	                pointer++;
	                break;
	            case DIFF_DELETE$2:
	                count_delete++;
	                text_delete += diffs[pointer][1];
	                pointer++;
	                break;
	            case DIFF_EQUAL$2:
	                // Upon reaching an equality, check for prior redundancies.
	                if (count_delete + count_insert > 1) {
	                    if (count_delete !== 0 && count_insert !== 0) {
	                        // Factor out any common prefixies.
	                        commonlength = diff_commonPrefix$2(text_insert, text_delete);
	                        if (commonlength !== 0) {
	                            if ((pointer - count_delete - count_insert) > 0 &&
	                                diffs[pointer - count_delete - count_insert - 1][0] ==
	                                    DIFF_EQUAL$2) {
	                                diffs[pointer - count_delete - count_insert - 1][1] +=
	                                    text_insert.substring(0, commonlength);
	                            }
	                            else {
	                                diffs.splice(0, 0, [DIFF_EQUAL$2,
	                                    text_insert.substring(0, commonlength)]);
	                                pointer++;
	                            }
	                            text_insert = text_insert.substring(commonlength);
	                            text_delete = text_delete.substring(commonlength);
	                        }
	                        // Factor out any common suffixies.
	                        commonlength = diff_commonSuffix$2(text_insert, text_delete);
	                        if (commonlength !== 0) {
	                            diffs[pointer][1] = text_insert.substring(text_insert.length -
	                                commonlength) + diffs[pointer][1];
	                            text_insert = text_insert.substring(0, text_insert.length -
	                                commonlength);
	                            text_delete = text_delete.substring(0, text_delete.length -
	                                commonlength);
	                        }
	                    }
	                    // Delete the offending records and add the merged ones.
	                    if (count_delete === 0) {
	                        diffs.splice(pointer - count_insert, count_delete + count_insert, [DIFF_INSERT$2, text_insert]);
	                    }
	                    else if (count_insert === 0) {
	                        diffs.splice(pointer - count_delete, count_delete + count_insert, [DIFF_DELETE$2, text_delete]);
	                    }
	                    else {
	                        diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [DIFF_DELETE$2, text_delete], [DIFF_INSERT$2, text_insert]);
	                    }
	                    pointer = pointer - count_delete - count_insert +
	                        (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
	                }
	                else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL$2) {
	                    // Merge this equality with the previous one.
	                    diffs[pointer - 1][1] += diffs[pointer][1];
	                    diffs.splice(pointer, 1);
	                }
	                else {
	                    pointer++;
	                }
	                count_insert = 0;
	                count_delete = 0;
	                text_delete = '';
	                text_insert = '';
	                break;
	        }
	    }
	    if (diffs[diffs.length - 1][1] === '') {
	        diffs.pop(); // Remove the dummy entry at the end.
	    }
	    // Second pass: look for single edits surrounded on both sides by equalities
	    // which can be shifted sideways to eliminate an equality.
	    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
	    var changes = false;
	    pointer = 1;
	    // Intentionally ignore the first and last element (don't need checking).
	    while (pointer < diffs.length - 1) {
	        if (diffs[pointer - 1][0] == DIFF_EQUAL$2 &&
	            diffs[pointer + 1][0] == DIFF_EQUAL$2) {
	            // This is a single edit surrounded by equalities.
	            if (diffs[pointer][1].substring(diffs[pointer][1].length -
	                diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
	                // Shift the edit over the previous equality.
	                diffs[pointer][1] = diffs[pointer - 1][1] +
	                    diffs[pointer][1].substring(0, diffs[pointer][1].length -
	                        diffs[pointer - 1][1].length);
	                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
	                diffs.splice(pointer - 1, 1);
	                changes = true;
	            }
	            else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
	                diffs[pointer + 1][1]) {
	                // Shift the edit over the next equality.
	                diffs[pointer - 1][1] += diffs[pointer + 1][1];
	                diffs[pointer][1] =
	                    diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
	                        diffs[pointer + 1][1];
	                diffs.splice(pointer + 1, 1);
	                changes = true;
	            }
	        }
	        pointer++;
	    }
	    // If shifts were made, the diff needs reordering and another shift sweep.
	    if (changes) {
	        diff_cleanupMerge$2(diffs);
	    }
	}
	diff$2.INSERT = DIFF_INSERT$2;
	diff$2.DELETE = DIFF_DELETE$2;
	diff$2.EQUAL = DIFF_EQUAL$2;
	/*
	 * Modify a diff such that the cursor position points to the start of a change:
	 * E.g.
	 *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)
	 *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]
	 *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)
	 *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
	 * @return {Array} A tuple [cursor location in the modified diff, modified diff]
	 */
	function cursor_normalize_diff$2(diffs, cursor_pos) {
	    if (cursor_pos === 0) {
	        return [DIFF_EQUAL$2, diffs];
	    }
	    for (var current_pos = 0, i = 0; i < diffs.length; i++) {
	        var d = diffs[i];
	        if (d[0] === DIFF_DELETE$2 || d[0] === DIFF_EQUAL$2) {
	            var next_pos = current_pos + d[1].length;
	            if (cursor_pos === next_pos) {
	                return [i + 1, diffs];
	            }
	            else if (cursor_pos < next_pos) {
	                // copy to prevent side effects
	                diffs = diffs.slice();
	                // split d into two diff changes
	                var split_pos = cursor_pos - current_pos;
	                var d_left = [d[0], d[1].slice(0, split_pos)];
	                var d_right = [d[0], d[1].slice(split_pos)];
	                diffs.splice(i, 1, d_left, d_right);
	                return [i + 1, diffs];
	            }
	            else {
	                current_pos = next_pos;
	            }
	        }
	    }
	    throw new Error('cursor_pos is out of bounds!');
	}
	/*
	 * Modify a diff such that the edit position is "shifted" to the proposed edit location (cursor_position).
	 *
	 * Case 1)
	 *   Check if a naive shift is possible:
	 *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)
	 *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result
	 * Case 2)
	 *   Check if the following shifts are possible:
	 *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']
	 *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']
	 *         ^            ^
	 *         d          d_next
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
	 * @return {Array} Array of diff tuples
	 */
	function fix_cursor$2(diffs, cursor_pos) {
	    var norm = cursor_normalize_diff$2(diffs, cursor_pos);
	    var ndiffs = norm[1];
	    var cursor_pointer = norm[0];
	    var d = ndiffs[cursor_pointer];
	    var d_next = ndiffs[cursor_pointer + 1];
	    if (d == null) {
	        // Text was deleted from end of original string,
	        // cursor is now out of bounds in new string
	        return diffs;
	    }
	    else if (d[0] !== DIFF_EQUAL$2) {
	        // A modification happened at the cursor location.
	        // This is the expected outcome, so we can return the original diff.
	        return diffs;
	    }
	    else {
	        if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
	            // Case 1)
	            // It is possible to perform a naive shift
	            ndiffs.splice(cursor_pointer, 2, d_next, d);
	            return merge_tuples$2(ndiffs, cursor_pointer, 2);
	        }
	        else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
	            // Case 2)
	            // d[1] is a prefix of d_next[1]
	            // We can assume that d_next[0] !== 0, since d[0] === 0
	            // Shift edit locations..
	            ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
	            var suffix = d_next[1].slice(d[1].length);
	            if (suffix.length > 0) {
	                ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
	            }
	            return merge_tuples$2(ndiffs, cursor_pointer, 3);
	        }
	        else {
	            // Not possible to perform any modification
	            return diffs;
	        }
	    }
	}
	/*
	 * Check diff did not split surrogate pairs.
	 * Ex. [0, '\uD83D'], [-1, '\uDC36'], [1, '\uDC2F'] -> [-1, '\uD83D\uDC36'], [1, '\uD83D\uDC2F']
	 *     '\uD83D\uDC36' === '🐶', '\uD83D\uDC2F' === '🐯'
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @return {Array} Array of diff tuples
	 */
	function fix_emoji$2(diffs) {
	    var compact = false;
	    var starts_with_pair_end = function (str) {
	        return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;
	    };
	    var ends_with_pair_start = function (str) {
	        return str.charCodeAt(str.length - 1) >= 0xD800 && str.charCodeAt(str.length - 1) <= 0xDBFF;
	    };
	    for (var i = 2; i < diffs.length; i += 1) {
	        if (diffs[i - 2][0] === DIFF_EQUAL$2 && ends_with_pair_start(diffs[i - 2][1]) &&
	            diffs[i - 1][0] === DIFF_DELETE$2 && starts_with_pair_end(diffs[i - 1][1]) &&
	            diffs[i][0] === DIFF_INSERT$2 && starts_with_pair_end(diffs[i][1])) {
	            compact = true;
	            diffs[i - 1][1] = diffs[i - 2][1].slice(-1) + diffs[i - 1][1];
	            diffs[i][1] = diffs[i - 2][1].slice(-1) + diffs[i][1];
	            diffs[i - 2][1] = diffs[i - 2][1].slice(0, -1);
	        }
	    }
	    if (!compact) {
	        return diffs;
	    }
	    var fixed_diffs = [];
	    for (var i = 0; i < diffs.length; i += 1) {
	        if (diffs[i][1].length > 0) {
	            fixed_diffs.push(diffs[i]);
	        }
	    }
	    return fixed_diffs;
	}
	/*
	 * Try to merge tuples with their neigbors in a given range.
	 * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']
	 *
	 * @param {Array} diffs Array of diff tuples.
	 * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).
	 * @param {Int} length Number of consecutive elements to check.
	 * @return {Array} Array of merged diff tuples.
	 */
	function merge_tuples$2(diffs, start, length) {
	    // Check from (start-1) to (start+length).
	    for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {
	        if (i + 1 < diffs.length) {
	            var left_d = diffs[i];
	            var right_d = diffs[i + 1];
	            if (left_d[0] === right_d[1]) {
	                diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
	            }
	        }
	    }
	    return diffs;
	}

	function shallowEqual$2(valueA, valueB) {
	    return valueEqual$2(valueA, valueB, strictEqual$2);
	}
	function deepEqual$2(valueA, valueB) {
	    return valueEqual$2(valueA, valueB, valueEqual$2);
	}
	function strictEqual$2(valueA, valueB) {
	    return valueA === valueB;
	}
	function valueEqual$2(valueA, valueB, propEqual) {
	    if (valueA === valueB)
	        return true;
	    if (valueA instanceof Date && valueB instanceof Date)
	        return valueA.getTime() === valueB.getTime();
	    if (!valueA || !valueB || typeof valueA !== 'object' && typeof valueB !== 'object')
	        return valueA === valueB;
	    return objectEqual$2(valueA, valueB, propEqual);
	}
	function objectEqual$2(objA, objB, propEqual) {
	    if (objA.prototype !== objB.prototype)
	        return false;
	    var keysA = Object.keys(objA);
	    var keysB = Object.keys(objB);
	    if (keysA.length !== keysB.length)
	        return false;
	    return keysA.every(function (key, i) { return key === keysB[i] && propEqual(objA[key], objB[key], propEqual); });
	}

	var NULL_CHARACTER$2 = String.fromCharCode(0); // Placeholder char for embed in diff()
	var Delta$2 = /** @class */ (function () {
	    function Delta(ops) {
	        if (ops === void 0) { ops = []; }
	        this.ops = ops;
	    }
	    /**
	     * Appends an insert operation. Returns this for chainability.
	     *
	     * @param {String|Object} text Represents text or embed to insert
	     * @param {Object} attributes Optional attributes to apply
	     */
	    Delta.prototype.insert = function (text, attributes) {
	        var newOp = {};
	        if (text.length === 0)
	            return this;
	        newOp.insert = text;
	        if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
	            newOp.attributes = attributes;
	        }
	        return this._push(newOp);
	    };
	    /**
	     * Appends a delete operation. Returns this for chainability.
	     *
	     * @param {Number} length Number of characters to delete
	     */
	    Delta.prototype["delete"] = function (length) {
	        if (length <= 0)
	            return this;
	        return this._push({ "delete": length });
	    };
	    /**
	     * Appends a retain operation. Returns this for chainability.
	     *
	     * @param {Number} length Number of characters to retain
	     * @param {Object} attributes Optional attributes to apply
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.retain = function (length, attributes) {
	        if (length <= 0)
	            return this;
	        var newOp = { retain: length };
	        if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
	            newOp.attributes = attributes;
	        }
	        return this._push(newOp);
	    };
	    /**
	     * Freezes delta from future modifications. Returns this for chainability.
	     *
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.freeze = function () {
	        var _this = this;
	        this._push = function () { return _this; };
	        return this;
	    };
	    /**
	     * Adds a new operation. Returns this for chainability.
	     *
	     * @param {Object} newOp A new operation
	     * @returns {Delta} This delta
	     */
	    Delta.prototype._push = function (newOp) {
	        var index = this.ops.length;
	        var lastOp = this.ops[index - 1];
	        if (typeof lastOp === 'object') {
	            if (typeof newOp["delete"] === 'number' && typeof lastOp["delete"] === 'number') {
	                this.ops[index - 1] = { "delete": lastOp["delete"] + newOp["delete"] };
	                return this;
	            }
	            // Since it does not matter if we insert before or after deleting at the same index,
	            // always prefer to insert first
	            if (typeof lastOp["delete"] === 'number' && newOp.insert != null) {
	                index -= 1;
	                lastOp = this.ops[index - 1];
	                if (typeof lastOp !== 'object') {
	                    this.ops.unshift(newOp);
	                    return this;
	                }
	            }
	            if (deepEqual$2(newOp.attributes, lastOp.attributes)) {
	                if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {
	                    this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };
	                    if (typeof newOp.attributes === 'object')
	                        this.ops[index - 1].attributes = newOp.attributes;
	                    return this;
	                }
	                else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {
	                    this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };
	                    if (typeof newOp.attributes === 'object')
	                        this.ops[index - 1].attributes = newOp.attributes;
	                    return this;
	                }
	            }
	        }
	        if (index === this.ops.length) {
	            this.ops.push(newOp);
	        }
	        else {
	            this.ops.splice(index, 0, newOp);
	        }
	        return this;
	    };
	    /**
	     * Chops off trailing retain instructions to make the delta concise.
	     *
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.chop = function () {
	        var lastOp = this.ops[this.ops.length - 1];
	        if (lastOp && lastOp.retain && !lastOp.attributes) {
	            this.ops.pop();
	        }
	        return this;
	    };
	    /**
	     * Returns an iterator to iterate over the operations of this delta.
	     *
	     * @returns {Iterator} An operation iterator with methods hasNext, next, peek, peekLength, & peekType
	     */
	    Delta.prototype.iterator = function () {
	        return new Iterator$2(this.ops);
	    };
	    /**
	     * Returns an array of operations that passes a given function.
	     *
	     * @param {Function} predicate Function to test each operation against. Return true to keep the operation, false
	     *                             otherwise
	     * @returns {Array} Filtered resulting array
	     */
	    Delta.prototype.filter = function (predicate) {
	        return this.ops.filter(predicate);
	    };
	    /**
	     * Iterates through operations, calling the provided function for each operation.
	     *
	     * @param {Function} predicate Function to call during iteration, passing in the current operation
	     */
	    Delta.prototype.forEach = function (predicate) {
	        this.ops.forEach(predicate);
	    };
	    /**
	     * Returns a new array with the results of calling provided function on each operation.
	     *
	     * @param {Function} predicate Function to call, passing in the current operation, returning an element of the new
	     *                             array to be returned
	     * @returns {Array} A new array with each element being the result of the given function
	     */
	    Delta.prototype.map = function (predicate) {
	        return this.ops.map(predicate);
	    };
	    /**
	     * Create an array of two arrays, the first with operations that pass the given function, the other that failed.
	     *
	     * @param {Function} predicate Function to call, passing in the current operation, returning whether that operation
	     *                             passed
	     * @returns {Array} A new array of two Arrays, the first with passed operations, the other with failed operations
	     */
	    Delta.prototype.partition = function (predicate) {
	        var passed = [], failed = [];
	        this.forEach(function (op) {
	            var target = predicate(op) ? passed : failed;
	            target.push(op);
	        });
	        return [passed, failed];
	    };
	    /**
	     * Applies given function against an accumulator and each operation to reduce to a single value.
	     *
	     * @param {Function} predicate Function to call per iteration, returning an accumulated value
	     * @param {*} initial Initial value to pass to first call to predicate
	     * @returns {*} The accumulated value
	     */
	    Delta.prototype.reduce = function (predicate, initial) {
	        return this.ops.reduce(predicate, initial);
	    };
	    Delta.prototype.changeLength = function () {
	        return this.reduce(function (length, entry) {
	            if (entry.insert) {
	                return length + getOpLength$2(entry);
	            }
	            else if (entry["delete"]) {
	                return length - entry["delete"];
	            }
	            return length;
	        }, 0);
	    };
	    /**
	     * Returns length of a Delta, which is the sum of the lengths of its operations.
	     *
	     * @returns {Number} The length of this delta
	     */
	    Delta.prototype.length = function () {
	        return this.reduce(function (length, entry) {
	            return length + getOpLength$2(entry);
	        }, 0);
	    };
	    /**
	     * Returns copy of delta with subset of operations.
	     *
	     * @param {Number} start Start index of subset, defaults to 0
	     * @param {Number} end End index of subset, defaults to rest of operations
	     * @returns {Array} An array slice of the operations
	     */
	    Delta.prototype.slice = function (start, end) {
	        if (start === void 0) { start = 0; }
	        if (typeof end !== 'number')
	            end = Infinity;
	        var ops = [];
	        var iter = this.iterator();
	        var index = 0;
	        while (index < end && iter.hasNext()) {
	            var nextOp;
	            if (index < start) {
	                nextOp = iter.next(start - index);
	            }
	            else {
	                nextOp = iter.next(end - index);
	                ops.push(nextOp);
	            }
	            index += getOpLength$2(nextOp);
	        }
	        return new Delta(ops);
	    };
	    /**
	     * Returns a Delta that is equivalent to applying the operations of own Delta, followed by another Delta.
	     *
	     * @param {Delta} other Delta to compose
	     */
	    Delta.prototype.compose = function (other) {
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        var delta = new Delta();
	        while (thisIter.hasNext() || otherIter.hasNext()) {
	            if (otherIter.peekType() === 'insert') {
	                delta._push(otherIter.next());
	            }
	            else if (thisIter.peekType() === 'delete') {
	                delta._push(thisIter.next());
	            }
	            else {
	                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
	                var thisOp = thisIter.next(length);
	                var otherOp = otherIter.next(length);
	                if (typeof otherOp.retain === 'number') {
	                    var newOp = {};
	                    if (typeof thisOp.retain === 'number') {
	                        newOp.retain = length;
	                    }
	                    else {
	                        newOp.insert = thisOp.insert;
	                    }
	                    // Preserve null when composing with a retain, otherwise remove it for inserts
	                    var attributes = composeAttributes$2(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');
	                    if (attributes)
	                        newOp.attributes = attributes;
	                    delta._push(newOp);
	                    // Optimization if rest of other is just retain
	                    if (!otherIter.hasNext() && deepEqual$2(delta.ops[delta.ops.length - 1], newOp)) {
	                        var rest = new Delta(thisIter.rest());
	                        return delta.concat(rest).chop();
	                    }
	                    // Other op should be delete, we could be an insert or retain
	                    // Insert + delete cancels out
	                }
	                else if (typeof otherOp["delete"] === 'number' && typeof thisOp.retain === 'number') {
	                    delta._push(otherOp);
	                }
	            }
	        }
	        return delta.chop();
	    };
	    /**
	     * Returns a new Delta representing the concatenation of this and another document Delta's operations.
	     *
	     * @param {Delta} other Document Delta to concatenate
	     * @returns {Delta} Concatenated document Delta
	     */
	    Delta.prototype.concat = function (other) {
	        var delta = new Delta(this.ops.slice());
	        if (other.ops.length > 0) {
	            delta._push(other.ops[0]);
	            delta.ops = delta.ops.concat(other.ops.slice(1));
	        }
	        return delta;
	    };
	    /**
	     * Returns a Delta representing the difference between two documents. Optionally, accepts a suggested index where
	     * change took place, often representing a cursor position before change.
	     *
	     * @param {Delta} other Document Delta to diff against
	     * @param {Number} index Suggested index where change took place
	     * @returns {Delta} Difference between the two documents
	     */
	    Delta.prototype.diff = function (other, index) {
	        if (this.ops === other.ops) {
	            return new Delta();
	        }
	        var strings = [this, other].map(function (delta) {
	            return delta.map(function (op) {
	                if (op.insert != null) {
	                    return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER$2;
	                }
	                var prep = (delta === other) ? 'on' : 'with';
	                throw new Error('diff() called ' + prep + ' non-document');
	            }).join('');
	        });
	        var delta = new Delta();
	        var diffResult = diff$2(strings[0], strings[1], index);
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        diffResult.forEach(function (component) {
	            var length = component[1].length;
	            while (length > 0) {
	                var opLength = 0;
	                switch (component[0]) {
	                    case diff$2.INSERT:
	                        opLength = Math.min(otherIter.peekLength(), length);
	                        delta._push(otherIter.next(opLength));
	                        break;
	                    case diff$2.DELETE:
	                        opLength = Math.min(length, thisIter.peekLength());
	                        thisIter.next(opLength);
	                        delta["delete"](opLength);
	                        break;
	                    case diff$2.EQUAL:
	                        opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
	                        var thisOp = thisIter.next(opLength);
	                        var otherOp = otherIter.next(opLength);
	                        if (deepEqual$2(thisOp.insert, otherOp.insert)) {
	                            delta.retain(opLength, diffAttributes$2(thisOp.attributes, otherOp.attributes));
	                        }
	                        else {
	                            delta._push(otherOp)["delete"](opLength);
	                        }
	                        break;
	                }
	                length -= opLength;
	            }
	        });
	        return delta.chop();
	    };
	    /**
	     * Iterates through document Delta, calling a given function with a Delta and attributes object, representing the line
	     * segment.
	     *
	     * @param {Function} predicate Function to call on each line group
	     * @param {String} newline Newline character, defaults to \n
	     */
	    Delta.prototype.eachLine = function (predicate, newline) {
	        if (newline === void 0) { newline = '\n'; }
	        var iter = this.iterator();
	        var ops = new Delta();
	        var index = 0;
	        var lineStart = 0;
	        var currentIndex = 0;
	        while (iter.hasNext()) {
	            if (iter.peekType() !== 'insert')
	                return;
	            var op = iter.peek();
	            var nextLength = iter.peekLength();
	            var start = getOpLength$2(op) - nextLength;
	            var newlineIndex = typeof op.insert === 'string' ? op.insert.indexOf(newline, start) - start : -1;
	            if (newlineIndex < 0) {
	                currentIndex += nextLength;
	                ops._push(iter.next());
	            }
	            else if (newlineIndex > 0) {
	                currentIndex += newlineIndex;
	                ops._push(iter.next(newlineIndex));
	            }
	            else {
	                currentIndex += 1;
	                var attributes = iter.next(1).attributes || {};
	                var line = { ops: ops, attributes: attributes, start: lineStart, end: currentIndex, index: index };
	                if (predicate(line, index) === false) {
	                    return;
	                }
	                index += 1;
	                lineStart = currentIndex;
	                ops = new Delta();
	            }
	        }
	        if (ops.length() > 0) {
	            var line_1 = { ops: ops, attributes: {}, start: lineStart, end: currentIndex, index: index };
	            predicate(line_1, index);
	        }
	    };
	    // Extends Delta, get the lines from `from` to `to`.
	    Delta.prototype.getLines = function (from, to, newline) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = Infinity; }
	        var lines = [];
	        this.eachLine(function (line) {
	            if (line.start > to || (line.start === to && from !== to))
	                return false;
	            if (line.end > from) {
	                lines.push(line);
	            }
	        }, newline);
	        return lines;
	    };
	    // Extends Delta, get the line at `at`.
	    Delta.prototype.getLine = function (at, newline) {
	        return this.getLines(at, at, newline)[0];
	    };
	    // Extends Delta, get the ops from `from` to `to`.
	    Delta.prototype.getOps = function (from, to) {
	        var start = 0;
	        var ops = [];
	        this.ops.some(function (op) {
	            if (start >= to)
	                return true;
	            var end = start + getOpLength$2(op);
	            if (end > from || (from === to && end === to)) {
	                ops.push({ op: op, start: start, end: end });
	            }
	            start = end;
	        });
	        return ops;
	    };
	    // Extends Delta, get the op at `at`.
	    Delta.prototype.getOp = function (at) {
	        return this.getOps(at, at)[0];
	    };
	    /**
	     * Transform given Delta against own operations. Used as an alias for transformPosition when called with a number.
	     *
	     * @param {Delta} other Delta to transform
	     * @param {Boolean} priority Boolean used to break ties. If true, then this takes priority over other, that is, its
	     *                           actions are considered to happen "first."
	     * @returns {Delta} Transformed Delta
	     */
	    Delta.prototype.transform = function (other, priority) {
	        if (priority === void 0) { priority = false; }
	        if (typeof other === 'number') {
	            return this.transformPosition(other, priority);
	        }
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        var delta = new Delta();
	        while (thisIter.hasNext() || otherIter.hasNext()) {
	            if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {
	                delta.retain(getOpLength$2(thisIter.next()));
	            }
	            else if (otherIter.peekType() === 'insert') {
	                delta._push(otherIter.next());
	            }
	            else {
	                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
	                var thisOp = thisIter.next(length);
	                var otherOp = otherIter.next(length);
	                if (thisOp["delete"]) {
	                    // Our delete either makes their delete redundant or removes their retain
	                    continue;
	                }
	                else if (otherOp["delete"]) {
	                    delta._push(otherOp);
	                }
	                else {
	                    // We retain either their retain or insert
	                    delta.retain(length, transformAttributes$2(thisOp.attributes, otherOp.attributes, priority));
	                }
	            }
	        }
	        return delta.chop();
	    };
	    /**
	     * Transform an index against the delta. Useful for representing cursor/selection positions.
	     *
	     * @param {Number} index Index to transform
	     * @param {Boolean} priority Boolean used to break ties. If true, then this takes priority over other, that is, its
	     *                           actions are considered to happen "first."
	     * @returns {Number} Transformed index
	     */
	    Delta.prototype.transformPosition = function (index, priority) {
	        if (priority === void 0) { priority = false; }
	        var thisIter = this.iterator();
	        var offset = 0;
	        while (thisIter.hasNext() && offset <= index) {
	            var length = thisIter.peekLength();
	            var nextType = thisIter.peekType();
	            thisIter.next();
	            if (nextType === 'delete') {
	                index -= Math.min(length, index - offset);
	                continue;
	            }
	            else if (nextType === 'insert' && (offset < index || !priority)) {
	                index += length;
	            }
	            offset += length;
	        }
	        return index;
	    };
	    return Delta;
	}());
	/**
	 * Create an attributes object that is equivalent to applying the attributes of the target followed by the source.
	 *
	 * @param {Object} target Target attributes object which will have the source applied to
	 * @param {Object} source Source attributes object being applied to the target
	 * @param {Boolean} keepNull Whether to keep null values from source
	 * @returns {Object} A new attributes object (or undefined if empty) with both
	 */
	function composeAttributes$2(target, source, keepNull) {
	    if (target === void 0) { target = {}; }
	    if (source === void 0) { source = {}; }
	    var attributes = __assign$2({}, target, source);
	    if (!keepNull)
	        Object.keys(attributes).forEach(function (key) {
	            if (attributes[key] == null)
	                delete attributes[key];
	        });
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Finds the difference between two attributes objects. Returns the source attributes that are different from the
	 * target attributes.
	 *
	 * @param {Object} target An attributes object
	 * @param {Object} source An attributes object
	 * @returns {Object} The difference between the two attribute objects or undefined if there is none
	 */
	function diffAttributes$2(target, source) {
	    if (target === void 0) { target = {}; }
	    if (source === void 0) { source = {}; }
	    var attributes = Object.keys(target).concat(Object.keys(source)).reduce(function (attributes, key) {
	        if (!deepEqual$2(target[key], source[key])) {
	            attributes[key] = source[key] === undefined ? null : source[key];
	        }
	        return attributes;
	    }, {});
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Transforms the attributes of source over target (or the other way around if priority is set). Will return an
	 * attributes object which has all the values from source if priority if false or will have the values from source that
	 * are set on target.
	 *
	 * @param {Object} target An attributes object
	 * @param {Object} source An attributes object
	 * @param {Boolean} priority If target has priority over source
	 */
	function transformAttributes$2(target, source, priority) {
	    if (typeof target !== 'object')
	        return source;
	    if (typeof source !== 'object')
	        return undefined;
	    if (!priority)
	        return source; // b simply overwrites us without priority
	    var attributes = Object.keys(source).reduce(function (attributes, key) {
	        if (target[key] === undefined)
	            attributes[key] = source[key]; // null is a valid value
	        return attributes;
	    }, {});
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Determines the length of a Delta operation.
	 *
	 * @param {Object} op An operation entry from a Delta object
	 * @returns {Number} The length of the op
	 */
	function getOpLength$2(op) {
	    if (typeof op["delete"] === 'number') {
	        return op["delete"];
	    }
	    else if (typeof op.retain === 'number') {
	        return op.retain;
	    }
	    else {
	        return typeof op.insert === 'string' ? op.insert.length : 1;
	    }
	}
	/**
	 * An iterator to handle iterating over a list of Delta operations efficiently.
	 */
	var Iterator$2 = /** @class */ (function () {
	    function Iterator(ops) {
	        this.ops = ops;
	        this.index = 0;
	        this.offset = 0;
	    }
	    /**
	     * Determine if there will be another operation returned by `next`.
	     *
	     * @returns {Boolean} Whether there are more operations to iterate over
	     */
	    Iterator.prototype.hasNext = function () {
	        return this.peekLength() < Infinity;
	    };
	    /**
	     * Get the next operation, optionally limited/sliced by length. If an operation is sliced by length, the next call to
	     * `next` will return more of that operation until it is returned in full.
	     *
	     * @param {Number} length Optionally limit the returned operation by length, slicing it down as needed
	     */
	    Iterator.prototype.next = function (length) {
	        if (length === void 0) { length = Infinity; }
	        var nextOp = this.ops[this.index];
	        if (!nextOp)
	            return { retain: Infinity };
	        var offset = this.offset;
	        var opLength = getOpLength$2(nextOp);
	        // Update index and offset
	        if (length >= opLength - offset) {
	            length = opLength - offset;
	            this.index += 1;
	            this.offset = 0;
	        }
	        else {
	            this.offset += length;
	        }
	        if (typeof nextOp["delete"] === 'number') {
	            return { "delete": length };
	        }
	        else {
	            var retOp = {};
	            if (nextOp.attributes) {
	                retOp.attributes = nextOp.attributes;
	            }
	            if (typeof nextOp.retain === 'number') {
	                retOp.retain = length;
	            }
	            else if (typeof nextOp.insert === 'string') {
	                retOp.insert = nextOp.insert.substr(offset, length);
	            }
	            else {
	                // offset should === 0, length should === 1
	                retOp.insert = nextOp.insert;
	            }
	            return retOp;
	        }
	    };
	    /**
	     * Return the next entry.
	     *
	     * @returns {Object} The next entry in the ops array.
	     */
	    Iterator.prototype.peek = function () {
	        return this.ops[this.index];
	    };
	    /**
	     * Check the length of the next entry.
	     *
	     * @returns {Number} The length of the next entry or Infinity if there is no next entry
	     */
	    Iterator.prototype.peekLength = function () {
	        if (this.ops[this.index]) {
	            // Should never return 0 if our index is being managed correctly
	            return getOpLength$2(this.ops[this.index]) - this.offset;
	        }
	        else {
	            return Infinity;
	        }
	    };
	    /**
	     * Check the type of the next entry, delete, retain, or insert.
	     *
	     * @returns {String} The type of the next entry
	     */
	    Iterator.prototype.peekType = function () {
	        if (this.ops[this.index]) {
	            if (typeof this.ops[this.index]["delete"] === 'number') {
	                return 'delete';
	            }
	            else if (typeof this.ops[this.index].retain === 'number') {
	                return 'retain';
	            }
	            else {
	                return 'insert';
	            }
	        }
	        return 'retain';
	    };
	    Iterator.prototype.rest = function () {
	        if (!this.hasNext()) {
	            return [];
	        }
	        else if (this.offset === 0) {
	            return this.ops.slice(this.index);
	        }
	        else {
	            var offset = this.offset;
	            var index = this.index;
	            var next = this.next();
	            var rest = this.ops.slice(this.index);
	            this.offset = offset;
	            this.index = index;
	            return [next].concat(rest);
	        }
	    };
	    return Iterator;
	}());

	var SOURCE_API$2 = 'api';
	var SOURCE_USER$2 = 'user';
	var SOURCE_SILENT$2 = 'silent';
	var empty$2 = {};
	/**
	 * Event for text changes, called before the change has occurred. If a listener returns false the change will be
	 * canceled and not committed.
	 *
	 * @event Editor#text-changing
	 * @type  {Object}
	 * @property {Delta} change       The change which is being applied to the content
	 * @property {Delta} content      The new content after the change
	 * @property {Delta} oldContent   The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * Event for text changes, called after the change has occurred.
	 *
	 * @event Editor#text-change
	 * @type  {Object}
	 * @property {Delta} change       The change which is being applied to the content
	 * @property {Delta} content      The new content after the change
	 * @property {Delta} oldContent   The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * Event for selection changes. If part of a text change the `change`, `content`, and `oldContent` properties will be
	 * set. Otherwise they will not be set.
	 *
	 * @event Editor#selection-change
	 * @type  {Object}
	 * @property {Delta} change       [ Optional ] The change which is being applied to the content
	 * @property {Delta} content      [ Optional ] The new content after the change
	 * @property {Delta} oldContent   [ Optional ] The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * A Typewriter Editor handles the logic for selection and editing of contents. It has no dependency on browser APIs
	 * and can be used in Node.js as easily as the browser. It has no logic to limit formatting (i.e. it does not disallow
	 * using bold, headers, links, or FOOBAR), that will need to be limited outside of the editor itself.
	 *
	 * @fires Editor#text-changing
	 * @fires Editor#text-change
	 * @fires Editor#selection-change
	 *
	 * @readonly @property {Delta}  contents      The data model for the text editor
	 * @readonly @property {Number} length        The length of the contents
	 * @readonly @property {String} text          The text of the contents
	 * @readonly @property {Array}  selection     The current editor selection, a tuple of `[ from, to ]` or `null`
	 * @readonly @property {Object} activeFormats The currently active formats (formats that will apply on the next insert)
	 */
	var Editor$2 = /** @class */ (function (_super) {
	    __extends$2(Editor, _super);
	    /**
	     * Create a new Typewriter editor.
	     *
	     * @param {Object} options Options for this editor include initial `contents` and `modules`:
	     * @param {Delta}  options.contents The initial contents of this editor
	     */
	    function Editor(options) {
	        if (options === void 0) { options = {}; }
	        var _this = _super.call(this) || this;
	        _this.contents = null;
	        _this.length = 0;
	        _this.selection = null;
	        _this.activeFormats = empty$2;
	        setContents$2(_this, options.contents || _this.delta().insert('\n'));
	        _this._queuedEvents = []; // Event queuing ensure they are fired in order
	        return _this;
	    }
	    /**
	     * Convenience method for creating a new delta.
	     *
	     * @param {Array} ops [Optional] The initial ops for the delta
	     * @returns {Delta}   A new Delta object
	     */
	    Editor.prototype.delta = function (ops) {
	        return new Delta$2(ops);
	    };
	    /**
	     * Returns the contents or a slice of them.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {Delta}     The contents of this editor
	     */
	    Editor.prototype.getContents = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.contents.slice(from, to);
	    };
	    /**
	     * Returns the text for the editor or a slice of it.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {String}    The text in the editor
	     */
	    Editor.prototype.getText = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length - 1; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.getContents(from, to)
	            .filter(function (op) { return typeof op.insert === 'string'; })
	            .map(function (op) { return op.insert; })
	            .join('');
	    };
	    /**
	     * Returns the text for the editor with null characters in place of embeds. This can be used to determine the index of
	     * given words or lines of text within the contents.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {String}    The text in the editor with embed spaces
	     */
	    Editor.prototype.getExactText = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length - 1; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.getContents(from, to)
	            .map(function (op) { return typeof op.insert === 'string' ? op.insert : '\0'; })
	            .join('');
	    };
	    /**
	     * Set the selection to a new location (or null for no selection). Will return false if the new selection is the same
	     * as the old selection. Dispatches "selection-change" once the selection is changed. This "selection-change" event
	     * won't have { contents, oldContnts, change } in it since the selection is changing without any content updates.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Boolean}        Whether the selection changed or not
	     */
	    Editor.prototype.setSelection = function (from, to, source) {
	        var _this = this;
	        if (source === void 0) { source = SOURCE_USER$2; }
	        var _a;
	        var oldSelection = this.selection;
	        var selection;
	        if (from === null) {
	            selection = null;
	            if (typeof to === 'string')
	                source = to;
	        }
	        else {
	            _a = this._normalizeSelection(from, to, source), from = _a[0], to = _a[1], source = _a[2];
	            selection = [from, to].map(function (i) { return Math.min(i, _this.length - 1); });
	        }
	        if (shallowEqual$2(oldSelection, selection))
	            return false;
	        // Reset the active formats when selection changes (do this before setting selection)
	        this.activeFormats = selection ? this.getTextFormat(Math.min(selection[0], selection[1])) : empty$2;
	        this.selection = selection;
	        var event = { selection: selection, oldSelection: oldSelection, source: source };
	        if (source !== SOURCE_SILENT$2)
	            this.fire('selection-change', event);
	        this.fire('editor-change', event);
	        return true;
	    };
	    /**
	     * The method that all other methods use to update the contents (even setContents & setText). This method will
	     * dispatch the event "text-changing". If a listener returns `false` then the change will be canceled and null will
	     * be returned. Otherwise, the change will be successful and if the `source` is not "silent" a "text-change" event
	     * will be fired with an event object containing `{ contents, oldContents, selection, oldSelection, source }`. If the
	     * selection has changed as part of this update a "selection-change" event will also be fired with the same event
	     * object.
	     *
	     * @param {Delta} change    A delta change to the document
	     * @param {String} source   The source of the change, user, api, or silent
	     * @param {Array} selection Optional selection after the change has been applied
	     * @returns {Delta}         Returns the change when successful, or null if not
	     */
	    Editor.prototype.updateContents = function (change, source, selection) {
	        if (source === void 0) { source = SOURCE_API$2; }
	        if (!change.chop().ops.length)
	            return null;
	        if (typeof selection === 'number')
	            selection = [selection, selection];
	        var oldContents = this.contents;
	        var contents = normalizeContents$2(oldContents.compose(change));
	        var length = contents.length();
	        var oldSelection = this.selection;
	        if (!selection)
	            selection = oldSelection ? oldSelection.map(function (i) { return change.transform(i); }) : oldSelection;
	        selection = selection && this.getSelectedRange(selection, length - 1);
	        var changeEvent = { contents: contents, oldContents: oldContents, change: change, selection: selection, oldSelection: oldSelection, source: source };
	        var selectionChanged = !shallowEqual$2(oldSelection, selection);
	        if (!this.fire('text-changing', changeEvent))
	            return null;
	        setContents$2(this, contents);
	        if (selection) {
	            // Reset the active formats when selection changes (do this before setting selection)
	            this.activeFormats = selection ? this.getTextFormat(Math.min(selection[0], selection[1])) : empty$2;
	            this.selection = selection;
	        }
	        var events = [];
	        if (source !== SOURCE_SILENT$2) {
	            events.push(['text-change', changeEvent]);
	            if (selectionChanged)
	                events.push(['selection-change', changeEvent]);
	        }
	        events.push(['editor-change', changeEvent]);
	        this._queueEvents(events);
	        return change;
	    };
	    /**
	     * Sets the entire contents of the editor. This will calculate the difference between the old content and the new and
	     * only apply the difference, if any.
	     *
	     * @param {Delta} newContents The contents of the editor, as a delta object
	     * @param {String} source     The source of the change, user, api, or silent
	     * @param {Array} selection   Optional selection after the change has been applied
	     * @returns {Delta}           Returns the change when successful, or null if not
	     */
	    Editor.prototype.setContents = function (newContents, source, selection) {
	        var change = this.contents.diff(normalizeContents$2(newContents));
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Sets the text content of the editor, removing existing contents and formatting.
	     *
	     * @param {String} text     Set the contents of this editor as text
	     * @param {String} source   The source of the change, user, api, or silent
	     * @param {Array} selection Optional selection after the change has been applied
	     * @returns {Delta}         Returns the change when successful, or null if not
	     */
	    Editor.prototype.setText = function (text, source, selection) {
	        return this.setContents(this.delta().insert(text + '\n'), source, selection);
	    };
	    /**
	     * Inserts text into the content of the editor, removing text between from and to if provided. If `text` is a newline
	     * ("\n") then the formats will apply to the line, otherwise they will apply to the text only (even if there are
	     * newlines in the text).
	     *
	     * @param {Number} from      Insert the text at this index, can also be a range Array tuple, default 0
	     * @param {Number} to        If provided and not equal to `from` will delete the text between `from` and `to`
	     * @param {String} text      The text to insert into the editor's contents
	     * @param {Object} formats   The formats of the inserted text. If null the formats at `from` will be used.
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.insertText = function (from, to, text, formats, source, selection) {
	        var _a, _b, _c;
	        _a = this._normalizeRange(from, to, text, formats, source, selection), from = _a[0], to = _a[1], text = _a[2], formats = _a[3], source = _a[4], selection = _a[5];
	        // If we are not inserting a newline, make sure from and to are within the selectable range
	        if (text !== '\n')
	            _b = this.getSelectedRange([from, to]), from = _b[0], to = _b[1];
	        if (typeof formats === 'string')
	            _c = [null, formats, source], formats = _c[0], source = _c[1], selection = _c[2];
	        if (selection == null && this.selection !== null)
	            selection = from + text.length;
	        var change = this.delta().retain(from)["delete"](to - from);
	        if (text === '\n') {
	            change.insert('\n', formats || this.getLineFormat(from));
	        }
	        else {
	            var lineFormat_1 = text.indexOf('\n') === -1 ? null : this.getLineFormat(from);
	            var textFormat_1 = formats || this.getTextFormat(from);
	            text.split('\n').forEach(function (line, i) {
	                if (i)
	                    change.insert('\n', lineFormat_1);
	                line.length && change.insert(line, textFormat_1);
	            });
	        }
	        change = cleanDelete$2(this, from, to, change);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Inserts an embed into the content of the editor, removing text between from and to if provided.
	     *
	     * @param {Number} from      Insert the embed at this index, can also be a range Array tuple, default 0
	     * @param {Number} to        If provided and not equal to `from` will delete the text between `from` and `to`
	     * @param {String} embed     Insert the text into the editor's contents
	     * @param {mixed}  value     Insert the text into the editor's contents
	     * @param {String} formats   The formats of the inserted text. If null the formats at `from` will be used.
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.insertEmbed = function (from, to, embed, value, formats, source, selection) {
	        var _a, _b, _c;
	        _a = this._normalizeRange(from, to, embed, value, source, selection), from = _a[0], to = _a[1], embed = _a[2], value = _a[3], source = _a[4], selection = _a[5];
	        if (typeof formats === 'string')
	            _b = [null, formats, source], formats = _b[0], source = _b[1], selection = _b[2];
	        if (from >= this.length)
	            from = this.length - 1;
	        if (to >= this.length)
	            to = this.length - 1;
	        if (selection == null && this.selection !== null)
	            selection = from + 1;
	        var textFormat = formats || this.getTextFormat(from);
	        var change = this.delta().retain(from)["delete"](to - from).insert((_c = {}, _c[embed] = value, _c), textFormat);
	        change = cleanDelete$2(this, from, to, change);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Deletes text from `from` to `to`.
	     *
	     * @param {Number} from      Insert the text as this index, can also be a range Array tuple, default 0
	     * @param {Number} to        Will delete the text between `from` and `to`
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.deleteText = function (from, to, source, selection) {
	        var _a;
	        _a = this._normalizeRange(from, to, source, selection), from = _a[0], to = _a[1], source = _a[2], selection = _a[3];
	        if (from === to)
	            return null;
	        if (selection == null && this.selection !== null)
	            selection = from;
	        var change = this.delta().retain(from)["delete"](to - from);
	        change = cleanDelete$2(this, from, to, change);
	        // Keep the active format of the text to the right of the cursor when deleting
	        var activeFormats;
	        if (selection === from)
	            activeFormats = this.getTextFormat(from, from + 1);
	        var result = this.updateContents(change, source, selection);
	        if (result && activeFormats)
	            this.activeFormats = activeFormats;
	        return result;
	    };
	    /**
	     * Get the line formats for the line that `from` is in to the line that `to` is in. Returns only the common formats
	     * between all the lines. If `from` equals `to` (or `to` is not provided) the formats will be all of those for the
	     * line `from` is on. If two lines are touched and they have different formats, an empty object will be returned.
	     *
	     * @param {Number} from Getting line formats starting at `from`
	     * @param {Number} to   Getting line formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the lines which intersect from and to
	     */
	    Editor.prototype.getLineFormat = function (from, to) {
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        var formats;
	        this.contents.getLines(from, to).forEach(function (line) {
	            if (!line.attributes)
	                formats = {};
	            else if (!formats)
	                formats = __assign$2({}, line.attributes);
	            else
	                formats = combineFormats$2(formats, line.attributes);
	        });
	        return formats;
	    };
	    /**
	     * Get the text formats for all the text from `from` to `to`. Returns only the common formats between the two indexes.
	     * Will also return the `activeFormats`. Active formats are those which are toggled on when the selection is collapsed
	     * (from and to are equal) indicating inserted text should use (or not use) those formats.
	     *
	     * @param {Number} from Getting text formats starting at `from`
	     * @param {Number} to   Getting text formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the text
	     */
	    Editor.prototype.getTextFormat = function (from, to) {
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        var formats;
	        // optimize for current selection
	        var seleciton = this.selection;
	        if (from === to && shallowEqual$2(this.selection, [from, to])) {
	            return this.activeFormats;
	        }
	        this.contents.getOps(from, to).forEach(function (_a) {
	            var op = _a.op;
	            if (/^\n+$/.test(op.insert))
	                return;
	            if (!op.attributes)
	                formats = {};
	            else if (!formats)
	                formats = __assign$2({}, op.attributes);
	            else
	                formats = combineFormats$2(formats, op.attributes);
	        });
	        if (!formats)
	            formats = {};
	        return formats;
	    };
	    /**
	     * Get the text and line formats for all the lines and text from `from` to `to`.
	     *
	     * @param {Number} from Getting line and text formats starting at `from`
	     * @param {Number} to   Getting line and text formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the lines and text which intersect from and to
	     */
	    Editor.prototype.getFormat = function (from, to) {
	        return __assign$2({}, this.getTextFormat(from, to), this.getLineFormat(from, to));
	    };
	    /**
	     * Formats the lines intersected by `from` and `to` with the given line formats. To remove an existing format pass in
	     * `null` or `false` to turn it off (e.g. `{ blockquote: false }`).
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the line
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.formatLine = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var change = this.delta();
	        this.contents.getLines(from, to).forEach(function (line) {
	            if (!change.ops.length)
	                change.retain(line.end - 1);
	            else
	                change.retain(line.end - line.start - 1);
	            // Clear out old formats on the line
	            Object.keys(line.attributes).forEach(function (name) { return !formats[name] && (formats[name] = null); });
	            change.retain(1, formats);
	        });
	        change.chop();
	        return change.ops.length ? this.updateContents(change, source) : null;
	    };
	    /**
	     * Formats the text from `from` to `to` with the given text formats. To remove an existing format pass in `null` or
	     * `false` to turn it off (e.g. `{ bold: false }`).
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the text
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.formatText = function (from, to, formats, source) {
	        var _this = this;
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        if (from === to) {
	            if (this.activeFormats === empty$2)
	                this.activeFormats = {};
	            Object.keys(formats).forEach(function (key) {
	                var value = formats[key];
	                if (value == null || value === false)
	                    delete _this.activeFormats[key];
	                else
	                    _this.activeFormats[key] = value;
	            });
	            return;
	        }
	        Object.keys(formats).forEach(function (name) { return formats[name] === false && (formats[name] = null); });
	        var change = this.delta().retain(from);
	        this.getText(from, to).split('\n').forEach(function (line) {
	            line.length && change.retain(line.length, formats);
	            change.retain(1);
	        });
	        change.chop();
	        return this.updateContents(change, source);
	    };
	    /**
	     * Toggles the line formats from `from` to `to` with the given line formats. If the line has the exact formats already
	     * they will be removed, otherwise they will be added.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the line
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.toggleLineFormat = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var existing = this.getLineFormat(from, to);
	        if (deepEqual$2(existing, formats)) {
	            Object.keys(formats).forEach(function (key) { return formats[key] = null; });
	        }
	        return this.formatLine(from, to, formats, source);
	    };
	    /**
	     * Toggles the text formats from `from` to `to` with the given text formats. If the text has the exact formats already
	     * they will be removed, otherwise they will be added.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the text
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.toggleTextFormat = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var existing = this.getTextFormat(from, to);
	        var isSame = Object.keys(formats).every(function (key) { return formats[key] === existing[key]; });
	        if (isSame) {
	            Object.keys(formats).forEach(function (key) { return formats[key] = null; });
	        }
	        return this.formatText(from, to, formats, source);
	    };
	    /**
	     * Removes all formatting, text and line formats, for the text and lines from `from` to `to`.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.removeFormats = function (from, to, source) {
	        var _this = this;
	        var _a;
	        _a = this._normalizeRange(from, to, source), from = _a[0], to = _a[1], source = _a[2];
	        var formats = {};
	        this.contents.getOps(from, to).forEach(function (_a) {
	            var op = _a.op;
	            op.attributes && Object.keys(op.attributes).forEach(function (key) { return formats[key] = null; });
	        });
	        var change = this.delta().retain(from).retain(to - from, formats);
	        // If the last block was not captured be sure to clear that too
	        this.contents.getLines(from, to).forEach(function (line) {
	            var formats = {};
	            Object.keys(line.attributes).forEach(function (key) { return formats[key] = null; });
	            change = change.compose(_this.delta().retain(line.end - 1).retain(1, formats));
	        });
	        return this.updateContents(change, source);
	    };
	    /**
	     * Create a change delta calling one or more methods on the editor. The changes will not be applied as normal but will
	     * be collated into a single change delta and returned from this methnod. Example:
	     * ```js
	     * var change = editor.getChange(function() {
	     *   editor.deleteText(0, 5);
	     *   editor.insertText('\n', { blockquote: true });
	     *   editor.formatText(10, 20, { bold: true });
	     * });
	     *
	     * editor.updateContents(change, 'user');
	     * ```
	     *
	     * @param {Function} producer A function in which to call methods on the editor to produce a change
	     * @returns {Delta}           The sum of all the changes made within the producer
	     */
	    Editor.prototype.getChange = function (producer) {
	        var change = this.delta();
	        this.updateContents = function (singleChange) {
	            if (singleChange.ops.length) {
	                change = change.compose(singleChange);
	                return singleChange;
	            }
	            else {
	                return null;
	            }
	        };
	        producer(this);
	        delete this.updateContents;
	        return change;
	    };
	    /**
	     * Make several changes to the editor apply all at one in one commit. Changes made with the transaction will be
	     * applied all together and the "text-changing", "text-change", and "selection-change" events will be dispatched only
	     * once. Use this to combine multiple changes into one.
	     *
	     * @param {Function} producer A function which should make changes with the editor
	     * @param {String} source     The source of the change, user, api, or silent
	     * @param {Array} selection   Optional selection after the change has been applied
	     * @returns {Delta}           Returns the change when successful, or null if not
	     */
	    Editor.prototype.transaction = function (producer, source, selection) {
	        var change = this.getChange(producer);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Returns the selected range (or the provided range) in index order (lowest number first) and within the bounds of
	     * the content, between 0 and content.length() - 1 (the selection cannot be past the trailing newline).
	     *
	     * @param {Array} range Optional range, defaults to current selection
	     * @param {Number} max  The maxium number the range can be
	     */
	    Editor.prototype.getSelectedRange = function (range, max) {
	        if (range === void 0) { range = this.selection; }
	        if (max === void 0) { max = this.length - 1; }
	        var _a;
	        if (range == null)
	            return range;
	        if (typeof range === 'number')
	            range = [range, range];
	        if (range[0] > range[1])
	            _a = [range[1], range[0]], range[0] = _a[0], range[1] = _a[1];
	        return range.map(function (index) { return Math.max(0, Math.min(max, index)); });
	    };
	    Editor.prototype._queueEvents = function (events) {
	        var _a;
	        var alreadyRunning = this._queuedEvents.length;
	        (_a = this._queuedEvents).push.apply(_a, events);
	        if (alreadyRunning)
	            return;
	        while (this._queuedEvents.length) {
	            var event = this._queuedEvents.shift();
	            this.fire.apply(this, event);
	        }
	    };
	    /**
	     * Normalizes range values to a proper range if it is not already. A range is a `from` and a `to` index, e.g. 0, 4.
	     * This will ensure the lower index is first. Example usage:
	     * editor._normalizeRange(5); // [5, 5]
	     * editor._normalizeRange(-4, 100); // for a doc with length 10, [0, 10]
	     * editor._normalizeRange(25, 18); // [18, 25]
	     * editor._normalizeRange([12, 13]); // [12, 13]
	     * editor._normalizeRange(5, { bold: true }); // [5, 5, { bold: true }]
	     */
	    Editor.prototype._normalizeRange = function (from, to) {
	        var rest = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            rest[_i - 2] = arguments[_i];
	        }
	        var _a;
	        _a = this._normalizeSelection.apply(this, [from, to].concat(rest)), from = _a[0], to = _a[1], rest = _a.slice(2);
	        if (from > to) {
	            var toValue = from;
	            from = to;
	            to = toValue;
	        }
	        return [from, to].concat(rest);
	    };
	    Editor.prototype._normalizeSelection = function (from, to) {
	        var rest = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            rest[_i - 2] = arguments[_i];
	        }
	        var _a;
	        if (Array.isArray(from)) {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            _a = from, from = _a[0], to = _a[1];
	            if (to === undefined)
	                to = from;
	        }
	        else if (typeof from !== 'number') {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            if (from !== undefined || rest.length)
	                rest.unshift(from);
	            from = to = 0;
	        }
	        else if (typeof to !== 'number') {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            to = from;
	        }
	        from = Math.max(0, Math.min(this.length, Math.floor(from)));
	        to = Math.max(0, Math.min(this.length, Math.floor(to)));
	        return [from, to].concat(rest);
	    };
	    return Editor;
	}(EventDispatcher$2));
	// Ensures the format for the current line in a delete remains the same when multiple lines are deleted. This is needed
	// because the last line holds the formatting after a delete, but the first line is expected to be the retained format
	function cleanDelete$2(editor, from, to, change) {
	    if (from !== to) {
	        var line = editor.contents.getLine(from);
	        if (!line.ops.length() && to === from + 1)
	            return change;
	        var lineFormat_2 = editor.getLineFormat(from);
	        if (!deepEqual$2(lineFormat_2, editor.getLineFormat(to))) {
	            var lineChange = editor.getChange(function () { return editor.formatLine(to, lineFormat_2); });
	            change = change.compose(change.transform(lineChange));
	        }
	    }
	    return change;
	}
	// Ensures contents end with a newline
	function normalizeContents$2(contents) {
	    // Contents only have inserts. Deletes and retains belong to changes only.
	    contents.ops = contents.ops.filter(function (op) { return op.insert; });
	    var lastOp = contents.ops[contents.ops.length - 1];
	    if (!lastOp || typeof lastOp.insert !== 'string' || lastOp.insert.slice(-1) !== '\n')
	        contents.insert('\n');
	    return contents;
	}
	// Sets the contents onto the editor after ensuring they end in a newline, freezes the contents from change, and
	// updates the length and text of the editor to the latest
	function setContents$2(editor, contents) {
	    contents = normalizeContents$2(contents);
	    contents.freeze();
	    editor.contents = contents;
	    editor.length = contents.length();
	}
	// Combine formats removing ones that don't exist in both and creating an array for those with multiple values
	function combineFormats$2(formats, combined) {
	    return Object.keys(combined).reduce(function (merged, name) {
	        if (formats[name] == null)
	            return merged;
	        if (combined[name] === formats[name]) {
	            merged[name] = combined[name];
	        }
	        else if (Array.isArray(combined[name])) {
	            if (combined[name].indexOf(formats[name]) < 0) {
	                merged[name] = combined[name].concat([formats[name]]);
	            }
	        }
	        else {
	            merged[name] = [combined[name], formats[name]];
	        }
	        return merged;
	    }, {});
	}

	var SKIP_ELEMENTS = { STYLE: true, SCRIPT: true, LINK: true, META: true, TITLE: true };
	var BLOCK_ELEMENTS = 'address, article, aside, blockquote, canvas, dd, div, dl, dt, fieldset, figcaption, figure, footer, form, header, hr, li, main, nav, noscript, ol, output, p, pre, section, table, tfoot, ul, video';
	var defaultOptions = { notInDom: false };
	function deltaFromDom(root, paper, options) {
	    if (options === void 0) { options = {}; }
	    var _a, _b;
	    var inDom = root.ownerDocument.contains(root);
	    var blocks = paper.blocks, marks = paper.marks, embeds = paper.embeds;
	    if (!options)
	        options = defaultOptions;
	    var walker = root.ownerDocument.createTreeWalker(root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, {
	        acceptNode: function (node) {
	            if (SKIP_ELEMENTS[node.nodeName]) {
	                return NodeFilter.FILTER_REJECT;
	            }
	            else if (node.nodeType === Node.TEXT_NODE && node.nodeValue === '') {
	                node.nodeType === Node.TEXT_NODE;
	            }
	            else if (node.nodeType === Node.TEXT_NODE || options.notInDom || inDom) {
	                return NodeFilter.FILTER_ACCEPT;
	            }
	            else {
	                return NodeFilter.FILTER_REJECT;
	            }
	        }
	    });
	    var delta = new Delta$2();
	    var currentBlock, firstBlockSeen = false, unknownBlock = false, empty = true, node;
	    var lastNode = false;
	    if (options.startNode) {
	        walker.currentNode = options.startNode;
	        walker.previousNode();
	        if (options.offset)
	            delta.retain(options.offset, undefined);
	    }
	    else {
	        walker.currentNode = root;
	    }
	    while ((node = walker.nextNode())) {
	        if (node === options.endNode)
	            lastNode = true;
	        else if (lastNode)
	            break;
	        if (isBRPlaceholder(paper, node)) {
	            empty = false;
	        }
	        else if (node.nodeType === Node.TEXT_NODE) {
	            var parent = node.parentNode;
	            // If all newlines, we can ignore
	            if (node.nodeValue.replace(/\n+/g, '') === '')
	                continue;
	            // non-breaking spaces (&nbsp;) are spaces in a delta
	            var text = node.nodeValue.replace(/\xA0/g, ' ').replace(/\n+/g, ' ');
	            // Word gives us end-of-paragraph nodes with a single space. Ignore them.
	            if (!text || (text === ' ' && parent.classList.contains('EOP')))
	                continue;
	            // Gather up all the marks for this text node, walking up to the block level
	            var attributes = gatherMarks(parent, root, paper);
	            empty = false;
	            delta.insert(text, attributes);
	        }
	        else if (node.className.indexOf('decorator') !== -1) {
	            continue;
	        }
	        else if (embeds.matches(node)) {
	            var embed = embeds.findByNode(node);
	            if (embed) {
	                var attributes = gatherMarks(node.parentNode, root, paper);
	                delta.insert((_a = {}, _a[embed.name] = embed.fromDom ? embed.fromDom(node, paper) : true, _a), attributes);
	            }
	        }
	        else if (blocks.matches(node) || (node.nodeType === Node.ELEMENT_NODE && node.matches(BLOCK_ELEMENTS))) {
	            unknownBlock = !blocks.matches(node);
	            if (unknownBlock) {
	                var parent = node.parentNode;
	                while (parent && !blocks.matches(parent) && parent !== root) {
	                    parent = parent.parentNode;
	                }
	                // If this block element is inside a recognized block, ignore it
	                if (parent && parent !== root) {
	                    continue;
	                }
	            }
	            var block = blocks.findByNode(node, true);
	            // Skip paragraphs/divs inside blockquotes and list items etc.
	            if (block === blocks.getDefault() && blocks.matches(node.parentNode)) {
	                continue;
	            }
	            if (firstBlockSeen) {
	                if (!currentBlock.unknownBlock || !empty) {
	                    delta.insert('\n', currentBlock.unknownBlock ? {} : currentBlock);
	                    empty = true;
	                }
	            }
	            else {
	                firstBlockSeen = true;
	            }
	            if (unknownBlock) {
	                currentBlock = { unknownBlock: unknownBlock };
	            }
	            else if (block !== blocks.getDefault()) {
	                currentBlock = block.fromDom ? block.fromDom(node, paper) : (_b = {}, _b[block.name] = true, _b);
	            }
	            else {
	                currentBlock = {};
	            }
	        }
	    }
	    // Delta documents should always end with a newline, unless they are partial documents
	    if (!unknownBlock || !empty) {
	        delta.insert('\n', currentBlock);
	    }
	    return delta;
	}
	// Walk up the DOM to the closest parent, finding marks
	function gatherMarks(parent, root, paper) {
	    var blocks = paper.blocks, marks = paper.marks;
	    var attributes = {};
	    while (parent && !blocks.matches(parent) && parent !== root) {
	        if (marks.matches(parent)) {
	            var mark = marks.findByNode(parent);
	            if (mark.name !== 'decorator') {
	                attributes[mark.name] = mark.fromDom ? mark.fromDom(parent, paper) : true;
	            }
	        }
	        else if (parent.hasAttribute('style')) {
	            marks.list.forEach(function (mark) {
	                if (mark.styleSelector && parent.matches(mark.styleSelector)) {
	                    attributes[mark.name] = mark.fromDom ? mark.fromDom(parent, paper) : true;
	                }
	            });
	        }
	        parent = parent.parentNode;
	    }
	    return attributes;
	}

	var modifierKeys = {
	    Control: true,
	    Meta: true,
	    Shift: true,
	    Alt: true
	};
	var isMac$1 = navigator.userAgent.indexOf('Macintosh') !== -1;
	/**
	 * Returns the textual representation of a shortcut given a keyboard event. Examples of shortcuts:
	 * Cmd+L
	 * Cmd+Shift+M
	 * Ctrl+O
	 * Backspace
	 * T
	 * Right
	 * Shift+Down
	 * Shift+F1
	 * Space
	 */
	function shortcutFromEvent(event) {
	    var shortcutArray = [];
	    var key = event.key;
	    if (!key)
	        return '';
	    if (key === ' ')
	        key = 'Space';
	    if (event.metaKey)
	        shortcutArray.push('Cmd');
	    if (event.ctrlKey)
	        shortcutArray.push('Ctrl');
	    if (event.altKey)
	        shortcutArray.push('Alt');
	    if (event.shiftKey)
	        shortcutArray.push('Shift');
	    if (!modifierKeys[key]) {
	        if (isMac$1 && event.altKey && event.code && event.code.startsWith('Key')) {
	            // The altKey on mac can change the key value (e.g. Cmd+Alt+R will show up as Cmd+Alt+® if we don't do this)
	            key = event.code.replace('Key', '');
	        }
	        // a and A, b and B, should be the same shortcut
	        if (key.length === 1)
	            key = key.toUpperCase();
	        shortcutArray.push(key);
	    }
	    return shortcutArray.join('+');
	}
	// Get the range (a tuple of indexes) for this view from the browser selection
	function getSelection(root, paper, range) {
	    var selection = !range ? root.ownerDocument.getSelection() : {
	        anchorNode: range.startContainer, anchorOffset: range.startOffset,
	        focusNode: range.endContainer, focusOffset: range.endOffset,
	        isCollapsed: range.collapsed
	    };
	    if (!root.contains(selection.anchorNode)) {
	        return null;
	    }
	    else {
	        var anchorIndex = getNodeAndOffsetIndex(root, paper, selection.anchorNode, selection.anchorOffset);
	        var isCollapsed = selection.anchorNode === selection.focusNode && selection.anchorOffset === selection.focusOffset;
	        // selection.isCollapsed causes a layout on Chrome. ?? Manual detection does not.
	        var focusIndex = isCollapsed ?
	            anchorIndex :
	            getNodeAndOffsetIndex(root, paper, selection.focusNode, selection.focusOffset);
	        return [anchorIndex, focusIndex];
	    }
	}
	function getNodeAndOffsetIndex(root, paper, node, offset) {
	    if (node.nodeType === Node.ELEMENT_NODE && offset > 0) {
	        node = node.childNodes[offset - 1];
	        offset = node.nodeType === Node.ELEMENT_NODE ? 0 : node.nodeValue.length;
	    }
	    return getNodeIndex(root, paper, node) + offset;
	}
	// Get the index the node starts at in the content
	function getNodeIndex(root, paper, node) {
	    var inDom = root.ownerDocument.contains(root);
	    var blocks = paper.blocks, embeds = paper.embeds;
	    var walker = root.ownerDocument.createTreeWalker(root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, {
	        acceptNode: inDom ? acceptNodeInDom : acceptNode
	    });
	    walker.currentNode = node;
	    var index = node.nodeType === Node.ELEMENT_NODE ? 0 : -1;
	    while ((node = walker.previousNode())) {
	        if (node === root)
	            continue;
	        else if (node.nodeType === Node.TEXT_NODE)
	            index += node.nodeValue.length;
	        else if (node.className.indexOf('decorator') !== -1)
	            ;
	        else if (embeds.matches(node) && !isBRPlaceholder(paper, node))
	            index++;
	        else if (blocks.matches(node))
	            index++;
	    }
	    return index;
	}
	function acceptNode(node) {
	    if (node.nodeType === Node.TEXT_NODE) {
	        return node.nodeValue.length ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
	    }
	    return NodeFilter.FILTER_REJECT;
	}
	function acceptNodeInDom(node) {
	    if (node.nodeType === Node.TEXT_NODE) {
	        return node.nodeValue.length ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
	    }
	    return NodeFilter.FILTER_ACCEPT;
	}

	var isMac$1$1 = navigator.userAgent.indexOf('Macintosh') !== -1;
	var modExpr = isMac$1$1 ? /Cmd/ : /Ctrl/;
	function shortcuts(options) {
	    if (!options) {
	        options = {
	            bubbles: false
	        };
	    }
	    return function (editor, root) {
	        function onKeyDown(event) {
	            var shortcut = shortcutFromEvent(event);
	            // Don't dispatch events for every character typed
	            if (shortcut.length <= 1)
	                return;
	            var canceled = false;
	            var init = {
	                detail: shortcut,
	                cancelable: true,
	                bubbles: options.bubbles
	            };
	            var os = isMac$1$1 ? 'mac' : 'win';
	            var osSpecificEvent = new CustomEvent('shortcut:' + os + ':' + shortcut, init);
	            var specificEvent = new CustomEvent('shortcut:' + shortcut, init);
	            var generalEvent = new CustomEvent('shortcut', init);
	            root.dispatchEvent(osSpecificEvent);
	            root.dispatchEvent(specificEvent);
	            root.dispatchEvent(generalEvent);
	            canceled = osSpecificEvent.defaultPrevented || specificEvent.defaultPrevented || generalEvent.defaultPrevented;
	            if (modExpr.test(shortcut)) {
	                init.detail = shortcut.replace(modExpr, 'Mod');
	                specificEvent = new CustomEvent('shortcut:' + init.detail, init);
	                generalEvent = new CustomEvent('shortcut', init);
	                root.dispatchEvent(specificEvent);
	                root.dispatchEvent(generalEvent);
	                canceled = canceled || specificEvent.defaultPrevented || generalEvent.defaultPrevented;
	            }
	            if (canceled) {
	                // Prevent the original keydown if the shortcut event called preventDefault
	                event.preventDefault();
	            }
	        }
	        root.addEventListener('keydown', onKeyDown);
	        return {
	            options: options,
	            onDestroy: function () {
	                root.removeEventListener('keydown', onKeyDown);
	            }
	        };
	    };
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */

	var __assign$1$1 = function() {
	    __assign$1$1 = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1$1.apply(this, arguments);
	};

	var dispatcherEvents$1$1 = new WeakMap();
	var EventDispatcher$1$1 = /** @class */ (function () {
	    function EventDispatcher() {
	    }
	    EventDispatcher.prototype.on = function (type, listener) {
	        getEventListeners$1$1(this, type, true).add(listener);
	    };
	    EventDispatcher.prototype.off = function (type, listener) {
	        var events = getEventListeners$1$1(this, type);
	        events && events["delete"](listener);
	    };
	    EventDispatcher.prototype.once = function (type, listener) {
	        function once() {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            this.off(type, once);
	            listener.apply(this, args);
	        }
	        this.on(type, once);
	    };
	    EventDispatcher.prototype.fire = function (type) {
	        var _this = this;
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        var uncanceled = true;
	        var events = getEventListeners$1$1(this, type);
	        if (events)
	            events.forEach(function (listener) {
	                uncanceled && listener.apply(_this, args) !== false || (uncanceled = false);
	            });
	        return uncanceled;
	    };
	    return EventDispatcher;
	}());
	function getEventListeners$1$1(obj, type, autocreate) {
	    if (autocreate === void 0) { autocreate = false; }
	    var events = dispatcherEvents$1$1.get(obj);
	    if (!events && autocreate)
	        dispatcherEvents$1$1.set(obj, events = Object.create(null));
	    return events && events[type] || autocreate && (events[type] = new Set());
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics$1$1 = function(d, b) {
	    extendStatics$1$1 = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return extendStatics$1$1(d, b);
	};

	function __extends$1$1(d, b) {
	    extendStatics$1$1(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign$2$1 = function() {
	    __assign$2$1 = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2$1.apply(this, arguments);
	};

	/**
	 * This library modifies the diff-patch-match library by Neil Fraser
	 * by removing the patch and match functionality and certain advanced
	 * options in the diff function. The original license is as follows:
	 *
	 * ===
	 *
	 * Diff Match and Patch
	 *
	 * Copyright 2006 Google Inc.
	 * http://code.google.com/p/google-diff-match-patch/
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * The data structure representing a diff is an array of tuples:
	 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
	 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
	 */
	var DIFF_DELETE$1$1 = -1;
	var DIFF_INSERT$1$1 = 1;
	var DIFF_EQUAL$1$1 = 0;
	/**
	 * Find the differences between two texts.  Simplifies the problem by stripping
	 * any common prefix or suffix off the texts before diffing.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {Int} cursor_pos Expected edit position in text1 (optional)
	 * @return {Array} Array of diff tuples.
	 */
	function diff$1$1(text1, text2, cursor_pos) {
	    // Check for equality (speedup).
	    if (text1 == text2) {
	        if (text1) {
	            return [[DIFF_EQUAL$1$1, text1]];
	        }
	        return [];
	    }
	    // Check cursor_pos within bounds
	    if (cursor_pos < 0 || text1.length < cursor_pos) {
	        cursor_pos = null;
	    }
	    // Trim off common prefix (speedup).
	    var commonlength = diff_commonPrefix$1$1(text1, text2);
	    var commonprefix = text1.substring(0, commonlength);
	    text1 = text1.substring(commonlength);
	    text2 = text2.substring(commonlength);
	    // Trim off common suffix (speedup).
	    commonlength = diff_commonSuffix$1$1(text1, text2);
	    var commonsuffix = text1.substring(text1.length - commonlength);
	    text1 = text1.substring(0, text1.length - commonlength);
	    text2 = text2.substring(0, text2.length - commonlength);
	    // Compute the diff on the middle block.
	    var diffs = diff_compute_$1$1(text1, text2);
	    // Restore the prefix and suffix.
	    if (commonprefix) {
	        diffs.unshift([DIFF_EQUAL$1$1, commonprefix]);
	    }
	    if (commonsuffix) {
	        diffs.push([DIFF_EQUAL$1$1, commonsuffix]);
	    }
	    diff_cleanupMerge$1$1(diffs);
	    if (cursor_pos != null) {
	        diffs = fix_cursor$1$1(diffs, cursor_pos);
	    }
	    diffs = fix_emoji$1$1(diffs);
	    return diffs;
	}
	/**
	 * Find the differences between two texts.  Assumes that the texts do not
	 * have any common prefix or suffix.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @return {Array} Array of diff tuples.
	 */
	function diff_compute_$1$1(text1, text2) {
	    var diffs;
	    if (!text1) {
	        // Just add some text (speedup).
	        return [[DIFF_INSERT$1$1, text2]];
	    }
	    if (!text2) {
	        // Just delete some text (speedup).
	        return [[DIFF_DELETE$1$1, text1]];
	    }
	    var longtext = text1.length > text2.length ? text1 : text2;
	    var shorttext = text1.length > text2.length ? text2 : text1;
	    var i = longtext.indexOf(shorttext);
	    if (i != -1) {
	        // Shorter text is inside the longer text (speedup).
	        diffs = [[DIFF_INSERT$1$1, longtext.substring(0, i)],
	            [DIFF_EQUAL$1$1, shorttext],
	            [DIFF_INSERT$1$1, longtext.substring(i + shorttext.length)]];
	        // Swap insertions for deletions if diff is reversed.
	        if (text1.length > text2.length) {
	            diffs[0][0] = diffs[2][0] = DIFF_DELETE$1$1;
	        }
	        return diffs;
	    }
	    if (shorttext.length == 1) {
	        // Single character string.
	        // After the previous speedup, the character can't be an equality.
	        return [[DIFF_DELETE$1$1, text1], [DIFF_INSERT$1$1, text2]];
	    }
	    // Check to see if the problem can be split in two.
	    var hm = diff_halfMatch_$1$1(text1, text2);
	    if (hm) {
	        // A half-match was found, sort out the return data.
	        var text1_a = hm[0];
	        var text1_b = hm[1];
	        var text2_a = hm[2];
	        var text2_b = hm[3];
	        var mid_common = hm[4];
	        // Send both pairs off for separate processing.
	        var diffs_a = diff$1$1(text1_a, text2_a);
	        var diffs_b = diff$1$1(text1_b, text2_b);
	        // Merge the results.
	        return diffs_a.concat([[DIFF_EQUAL$1$1, mid_common]], diffs_b);
	    }
	    return diff_bisect_$1$1(text1, text2);
	}
	/**
	 * Find the 'middle snake' of a diff, split the problem in two
	 * and return the recursively constructed diff.
	 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @return {Array} Array of diff tuples.
	 * @private
	 */
	function diff_bisect_$1$1(text1, text2) {
	    // Cache the text lengths to prevent multiple calls.
	    var text1_length = text1.length;
	    var text2_length = text2.length;
	    var max_d = Math.ceil((text1_length + text2_length) / 2);
	    var v_offset = max_d;
	    var v_length = 2 * max_d;
	    var v1 = new Array(v_length);
	    var v2 = new Array(v_length);
	    // Setting all elements to -1 is faster in Chrome & Firefox than mixing
	    // integers and undefined.
	    for (var x = 0; x < v_length; x++) {
	        v1[x] = -1;
	        v2[x] = -1;
	    }
	    v1[v_offset + 1] = 0;
	    v2[v_offset + 1] = 0;
	    var delta = text1_length - text2_length;
	    // If the total number of characters is odd, then the front path will collide
	    // with the reverse path.
	    var front = (delta % 2 != 0);
	    // Offsets for start and end of k loop.
	    // Prevents mapping of space beyond the grid.
	    var k1start = 0;
	    var k1end = 0;
	    var k2start = 0;
	    var k2end = 0;
	    for (var d = 0; d < max_d; d++) {
	        // Walk the front path one step.
	        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
	            var k1_offset = v_offset + k1;
	            var x1;
	            if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
	                x1 = v1[k1_offset + 1];
	            }
	            else {
	                x1 = v1[k1_offset - 1] + 1;
	            }
	            var y1 = x1 - k1;
	            while (x1 < text1_length && y1 < text2_length &&
	                text1.charAt(x1) == text2.charAt(y1)) {
	                x1++;
	                y1++;
	            }
	            v1[k1_offset] = x1;
	            if (x1 > text1_length) {
	                // Ran off the right of the graph.
	                k1end += 2;
	            }
	            else if (y1 > text2_length) {
	                // Ran off the bottom of the graph.
	                k1start += 2;
	            }
	            else if (front) {
	                var k2_offset = v_offset + delta - k1;
	                if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
	                    // Mirror x2 onto top-left coordinate system.
	                    var x2 = text1_length - v2[k2_offset];
	                    if (x1 >= x2) {
	                        // Overlap detected.
	                        return diff_bisectSplit_$1$1(text1, text2, x1, y1);
	                    }
	                }
	            }
	        }
	        // Walk the reverse path one step.
	        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
	            var k2_offset = v_offset + k2;
	            var x2;
	            if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
	                x2 = v2[k2_offset + 1];
	            }
	            else {
	                x2 = v2[k2_offset - 1] + 1;
	            }
	            var y2 = x2 - k2;
	            while (x2 < text1_length && y2 < text2_length &&
	                text1.charAt(text1_length - x2 - 1) ==
	                    text2.charAt(text2_length - y2 - 1)) {
	                x2++;
	                y2++;
	            }
	            v2[k2_offset] = x2;
	            if (x2 > text1_length) {
	                // Ran off the left of the graph.
	                k2end += 2;
	            }
	            else if (y2 > text2_length) {
	                // Ran off the top of the graph.
	                k2start += 2;
	            }
	            else if (!front) {
	                var k1_offset = v_offset + delta - k2;
	                if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
	                    var x1 = v1[k1_offset];
	                    var y1 = v_offset + x1 - k1_offset;
	                    // Mirror x2 onto top-left coordinate system.
	                    x2 = text1_length - x2;
	                    if (x1 >= x2) {
	                        // Overlap detected.
	                        return diff_bisectSplit_$1$1(text1, text2, x1, y1);
	                    }
	                }
	            }
	        }
	    }
	    // Diff took too long and hit the deadline or
	    // number of diffs equals number of characters, no commonality at all.
	    return [[DIFF_DELETE$1$1, text1], [DIFF_INSERT$1$1, text2]];
	}
	/**
	 * Given the location of the 'middle snake', split the diff in two parts
	 * and recurse.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} x Index of split point in text1.
	 * @param {number} y Index of split point in text2.
	 * @return {Array} Array of diff tuples.
	 */
	function diff_bisectSplit_$1$1(text1, text2, x, y) {
	    var text1a = text1.substring(0, x);
	    var text2a = text2.substring(0, y);
	    var text1b = text1.substring(x);
	    var text2b = text2.substring(y);
	    // Compute both diffs serially.
	    var diffs = diff$1$1(text1a, text2a);
	    var diffsb = diff$1$1(text1b, text2b);
	    return diffs.concat(diffsb);
	}
	/**
	 * Determine the common prefix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the start of each
	 *     string.
	 */
	function diff_commonPrefix$1$1(text1, text2) {
	    // Quick check for common null cases.
	    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
	        return 0;
	    }
	    // Binary search.
	    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	    var pointermin = 0;
	    var pointermax = Math.min(text1.length, text2.length);
	    var pointermid = pointermax;
	    var pointerstart = 0;
	    while (pointermin < pointermid) {
	        if (text1.substring(pointerstart, pointermid) ==
	            text2.substring(pointerstart, pointermid)) {
	            pointermin = pointermid;
	            pointerstart = pointermin;
	        }
	        else {
	            pointermax = pointermid;
	        }
	        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }
	    return pointermid;
	}
	/**
	 * Determine the common suffix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the end of each string.
	 */
	function diff_commonSuffix$1$1(text1, text2) {
	    // Quick check for common null cases.
	    if (!text1 || !text2 ||
	        text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
	        return 0;
	    }
	    // Binary search.
	    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	    var pointermin = 0;
	    var pointermax = Math.min(text1.length, text2.length);
	    var pointermid = pointermax;
	    var pointerend = 0;
	    while (pointermin < pointermid) {
	        if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
	            text2.substring(text2.length - pointermid, text2.length - pointerend)) {
	            pointermin = pointermid;
	            pointerend = pointermin;
	        }
	        else {
	            pointermax = pointermid;
	        }
	        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }
	    return pointermid;
	}
	/**
	 * Do the two texts share a substring which is at least half the length of the
	 * longer text?
	 * This speedup can produce non-minimal diffs.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {Array.<string>} Five element Array, containing the prefix of
	 *     text1, the suffix of text1, the prefix of text2, the suffix of
	 *     text2 and the common middle.  Or null if there was no match.
	 */
	function diff_halfMatch_$1$1(text1, text2) {
	    var longtext = text1.length > text2.length ? text1 : text2;
	    var shorttext = text1.length > text2.length ? text2 : text1;
	    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
	        return null; // Pointless.
	    }
	    /**
	     * Does a substring of shorttext exist within longtext such that the substring
	     * is at least half the length of longtext?
	     * Closure, but does not reference any external variables.
	     * @param {string} longtext Longer string.
	     * @param {string} shorttext Shorter string.
	     * @param {number} i Start index of quarter length substring within longtext.
	     * @return {Array.<string>} Five element Array, containing the prefix of
	     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
	     *     of shorttext and the common middle.  Or null if there was no match.
	     * @private
	     */
	    function diff_halfMatchI_(longtext, shorttext, i) {
	        // Start with a 1/4 length substring at position i as a seed.
	        var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
	        var j = -1;
	        var best_common = '';
	        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
	        while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
	            var prefixLength = diff_commonPrefix$1$1(longtext.substring(i), shorttext.substring(j));
	            var suffixLength = diff_commonSuffix$1$1(longtext.substring(0, i), shorttext.substring(0, j));
	            if (best_common.length < suffixLength + prefixLength) {
	                best_common = shorttext.substring(j - suffixLength, j) +
	                    shorttext.substring(j, j + prefixLength);
	                best_longtext_a = longtext.substring(0, i - suffixLength);
	                best_longtext_b = longtext.substring(i + prefixLength);
	                best_shorttext_a = shorttext.substring(0, j - suffixLength);
	                best_shorttext_b = shorttext.substring(j + prefixLength);
	            }
	        }
	        if (best_common.length * 2 >= longtext.length) {
	            return [best_longtext_a, best_longtext_b,
	                best_shorttext_a, best_shorttext_b, best_common];
	        }
	        else {
	            return null;
	        }
	    }
	    // First check if the second quarter is the seed for a half-match.
	    var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
	    // Check again based on the third quarter.
	    var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
	    var hm;
	    if (!hm1 && !hm2) {
	        return null;
	    }
	    else if (!hm2) {
	        hm = hm1;
	    }
	    else if (!hm1) {
	        hm = hm2;
	    }
	    else {
	        // Both matched.  Select the longest.
	        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
	    }
	    // A half-match was found, sort out the return data.
	    var text1_a, text1_b, text2_a, text2_b;
	    if (text1.length > text2.length) {
	        text1_a = hm[0];
	        text1_b = hm[1];
	        text2_a = hm[2];
	        text2_b = hm[3];
	    }
	    else {
	        text2_a = hm[0];
	        text2_b = hm[1];
	        text1_a = hm[2];
	        text1_b = hm[3];
	    }
	    var mid_common = hm[4];
	    return [text1_a, text1_b, text2_a, text2_b, mid_common];
	}
	/**
	 * Reorder and merge like edit sections.  Merge equalities.
	 * Any edit section can move as long as it doesn't cross an equality.
	 * @param {Array} diffs Array of diff tuples.
	 */
	function diff_cleanupMerge$1$1(diffs) {
	    diffs.push([DIFF_EQUAL$1$1, '']); // Add a dummy entry at the end.
	    var pointer = 0;
	    var count_delete = 0;
	    var count_insert = 0;
	    var text_delete = '';
	    var text_insert = '';
	    var commonlength;
	    while (pointer < diffs.length) {
	        switch (diffs[pointer][0]) {
	            case DIFF_INSERT$1$1:
	                count_insert++;
	                text_insert += diffs[pointer][1];
	                pointer++;
	                break;
	            case DIFF_DELETE$1$1:
	                count_delete++;
	                text_delete += diffs[pointer][1];
	                pointer++;
	                break;
	            case DIFF_EQUAL$1$1:
	                // Upon reaching an equality, check for prior redundancies.
	                if (count_delete + count_insert > 1) {
	                    if (count_delete !== 0 && count_insert !== 0) {
	                        // Factor out any common prefixies.
	                        commonlength = diff_commonPrefix$1$1(text_insert, text_delete);
	                        if (commonlength !== 0) {
	                            if ((pointer - count_delete - count_insert) > 0 &&
	                                diffs[pointer - count_delete - count_insert - 1][0] ==
	                                    DIFF_EQUAL$1$1) {
	                                diffs[pointer - count_delete - count_insert - 1][1] +=
	                                    text_insert.substring(0, commonlength);
	                            }
	                            else {
	                                diffs.splice(0, 0, [DIFF_EQUAL$1$1,
	                                    text_insert.substring(0, commonlength)]);
	                                pointer++;
	                            }
	                            text_insert = text_insert.substring(commonlength);
	                            text_delete = text_delete.substring(commonlength);
	                        }
	                        // Factor out any common suffixies.
	                        commonlength = diff_commonSuffix$1$1(text_insert, text_delete);
	                        if (commonlength !== 0) {
	                            diffs[pointer][1] = text_insert.substring(text_insert.length -
	                                commonlength) + diffs[pointer][1];
	                            text_insert = text_insert.substring(0, text_insert.length -
	                                commonlength);
	                            text_delete = text_delete.substring(0, text_delete.length -
	                                commonlength);
	                        }
	                    }
	                    // Delete the offending records and add the merged ones.
	                    if (count_delete === 0) {
	                        diffs.splice(pointer - count_insert, count_delete + count_insert, [DIFF_INSERT$1$1, text_insert]);
	                    }
	                    else if (count_insert === 0) {
	                        diffs.splice(pointer - count_delete, count_delete + count_insert, [DIFF_DELETE$1$1, text_delete]);
	                    }
	                    else {
	                        diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [DIFF_DELETE$1$1, text_delete], [DIFF_INSERT$1$1, text_insert]);
	                    }
	                    pointer = pointer - count_delete - count_insert +
	                        (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
	                }
	                else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL$1$1) {
	                    // Merge this equality with the previous one.
	                    diffs[pointer - 1][1] += diffs[pointer][1];
	                    diffs.splice(pointer, 1);
	                }
	                else {
	                    pointer++;
	                }
	                count_insert = 0;
	                count_delete = 0;
	                text_delete = '';
	                text_insert = '';
	                break;
	        }
	    }
	    if (diffs[diffs.length - 1][1] === '') {
	        diffs.pop(); // Remove the dummy entry at the end.
	    }
	    // Second pass: look for single edits surrounded on both sides by equalities
	    // which can be shifted sideways to eliminate an equality.
	    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
	    var changes = false;
	    pointer = 1;
	    // Intentionally ignore the first and last element (don't need checking).
	    while (pointer < diffs.length - 1) {
	        if (diffs[pointer - 1][0] == DIFF_EQUAL$1$1 &&
	            diffs[pointer + 1][0] == DIFF_EQUAL$1$1) {
	            // This is a single edit surrounded by equalities.
	            if (diffs[pointer][1].substring(diffs[pointer][1].length -
	                diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
	                // Shift the edit over the previous equality.
	                diffs[pointer][1] = diffs[pointer - 1][1] +
	                    diffs[pointer][1].substring(0, diffs[pointer][1].length -
	                        diffs[pointer - 1][1].length);
	                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
	                diffs.splice(pointer - 1, 1);
	                changes = true;
	            }
	            else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
	                diffs[pointer + 1][1]) {
	                // Shift the edit over the next equality.
	                diffs[pointer - 1][1] += diffs[pointer + 1][1];
	                diffs[pointer][1] =
	                    diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
	                        diffs[pointer + 1][1];
	                diffs.splice(pointer + 1, 1);
	                changes = true;
	            }
	        }
	        pointer++;
	    }
	    // If shifts were made, the diff needs reordering and another shift sweep.
	    if (changes) {
	        diff_cleanupMerge$1$1(diffs);
	    }
	}
	diff$1$1.INSERT = DIFF_INSERT$1$1;
	diff$1$1.DELETE = DIFF_DELETE$1$1;
	diff$1$1.EQUAL = DIFF_EQUAL$1$1;
	/*
	 * Modify a diff such that the cursor position points to the start of a change:
	 * E.g.
	 *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)
	 *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]
	 *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)
	 *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
	 * @return {Array} A tuple [cursor location in the modified diff, modified diff]
	 */
	function cursor_normalize_diff$1$1(diffs, cursor_pos) {
	    if (cursor_pos === 0) {
	        return [DIFF_EQUAL$1$1, diffs];
	    }
	    for (var current_pos = 0, i = 0; i < diffs.length; i++) {
	        var d = diffs[i];
	        if (d[0] === DIFF_DELETE$1$1 || d[0] === DIFF_EQUAL$1$1) {
	            var next_pos = current_pos + d[1].length;
	            if (cursor_pos === next_pos) {
	                return [i + 1, diffs];
	            }
	            else if (cursor_pos < next_pos) {
	                // copy to prevent side effects
	                diffs = diffs.slice();
	                // split d into two diff changes
	                var split_pos = cursor_pos - current_pos;
	                var d_left = [d[0], d[1].slice(0, split_pos)];
	                var d_right = [d[0], d[1].slice(split_pos)];
	                diffs.splice(i, 1, d_left, d_right);
	                return [i + 1, diffs];
	            }
	            else {
	                current_pos = next_pos;
	            }
	        }
	    }
	    throw new Error('cursor_pos is out of bounds!');
	}
	/*
	 * Modify a diff such that the edit position is "shifted" to the proposed edit location (cursor_position).
	 *
	 * Case 1)
	 *   Check if a naive shift is possible:
	 *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)
	 *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result
	 * Case 2)
	 *   Check if the following shifts are possible:
	 *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']
	 *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']
	 *         ^            ^
	 *         d          d_next
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
	 * @return {Array} Array of diff tuples
	 */
	function fix_cursor$1$1(diffs, cursor_pos) {
	    var norm = cursor_normalize_diff$1$1(diffs, cursor_pos);
	    var ndiffs = norm[1];
	    var cursor_pointer = norm[0];
	    var d = ndiffs[cursor_pointer];
	    var d_next = ndiffs[cursor_pointer + 1];
	    if (d == null) {
	        // Text was deleted from end of original string,
	        // cursor is now out of bounds in new string
	        return diffs;
	    }
	    else if (d[0] !== DIFF_EQUAL$1$1) {
	        // A modification happened at the cursor location.
	        // This is the expected outcome, so we can return the original diff.
	        return diffs;
	    }
	    else {
	        if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
	            // Case 1)
	            // It is possible to perform a naive shift
	            ndiffs.splice(cursor_pointer, 2, d_next, d);
	            return merge_tuples$1$1(ndiffs, cursor_pointer, 2);
	        }
	        else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
	            // Case 2)
	            // d[1] is a prefix of d_next[1]
	            // We can assume that d_next[0] !== 0, since d[0] === 0
	            // Shift edit locations..
	            ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
	            var suffix = d_next[1].slice(d[1].length);
	            if (suffix.length > 0) {
	                ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
	            }
	            return merge_tuples$1$1(ndiffs, cursor_pointer, 3);
	        }
	        else {
	            // Not possible to perform any modification
	            return diffs;
	        }
	    }
	}
	/*
	 * Check diff did not split surrogate pairs.
	 * Ex. [0, '\uD83D'], [-1, '\uDC36'], [1, '\uDC2F'] -> [-1, '\uD83D\uDC36'], [1, '\uD83D\uDC2F']
	 *     '\uD83D\uDC36' === '🐶', '\uD83D\uDC2F' === '🐯'
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @return {Array} Array of diff tuples
	 */
	function fix_emoji$1$1(diffs) {
	    var compact = false;
	    var starts_with_pair_end = function (str) {
	        return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;
	    };
	    var ends_with_pair_start = function (str) {
	        return str.charCodeAt(str.length - 1) >= 0xD800 && str.charCodeAt(str.length - 1) <= 0xDBFF;
	    };
	    for (var i = 2; i < diffs.length; i += 1) {
	        if (diffs[i - 2][0] === DIFF_EQUAL$1$1 && ends_with_pair_start(diffs[i - 2][1]) &&
	            diffs[i - 1][0] === DIFF_DELETE$1$1 && starts_with_pair_end(diffs[i - 1][1]) &&
	            diffs[i][0] === DIFF_INSERT$1$1 && starts_with_pair_end(diffs[i][1])) {
	            compact = true;
	            diffs[i - 1][1] = diffs[i - 2][1].slice(-1) + diffs[i - 1][1];
	            diffs[i][1] = diffs[i - 2][1].slice(-1) + diffs[i][1];
	            diffs[i - 2][1] = diffs[i - 2][1].slice(0, -1);
	        }
	    }
	    if (!compact) {
	        return diffs;
	    }
	    var fixed_diffs = [];
	    for (var i = 0; i < diffs.length; i += 1) {
	        if (diffs[i][1].length > 0) {
	            fixed_diffs.push(diffs[i]);
	        }
	    }
	    return fixed_diffs;
	}
	/*
	 * Try to merge tuples with their neigbors in a given range.
	 * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']
	 *
	 * @param {Array} diffs Array of diff tuples.
	 * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).
	 * @param {Int} length Number of consecutive elements to check.
	 * @return {Array} Array of merged diff tuples.
	 */
	function merge_tuples$1$1(diffs, start, length) {
	    // Check from (start-1) to (start+length).
	    for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {
	        if (i + 1 < diffs.length) {
	            var left_d = diffs[i];
	            var right_d = diffs[i + 1];
	            if (left_d[0] === right_d[1]) {
	                diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
	            }
	        }
	    }
	    return diffs;
	}

	function shallowEqual$1$1(valueA, valueB) {
	    return valueEqual$1$1(valueA, valueB, strictEqual$1$1);
	}
	function deepEqual$1$1(valueA, valueB) {
	    return valueEqual$1$1(valueA, valueB, valueEqual$1$1);
	}
	function strictEqual$1$1(valueA, valueB) {
	    return valueA === valueB;
	}
	function valueEqual$1$1(valueA, valueB, propEqual) {
	    if (valueA === valueB)
	        return true;
	    if (valueA instanceof Date && valueB instanceof Date)
	        return valueA.getTime() === valueB.getTime();
	    if (!valueA || !valueB || typeof valueA !== 'object' && typeof valueB !== 'object')
	        return valueA === valueB;
	    return objectEqual$1$1(valueA, valueB, propEqual);
	}
	function objectEqual$1$1(objA, objB, propEqual) {
	    if (objA.prototype !== objB.prototype)
	        return false;
	    var keysA = Object.keys(objA);
	    var keysB = Object.keys(objB);
	    if (keysA.length !== keysB.length)
	        return false;
	    return keysA.every(function (key, i) { return key === keysB[i] && propEqual(objA[key], objB[key], propEqual); });
	}

	var NULL_CHARACTER$1$1 = String.fromCharCode(0); // Placeholder char for embed in diff()
	var Delta$1$1 = /** @class */ (function () {
	    function Delta(ops) {
	        if (ops === void 0) { ops = []; }
	        this.ops = ops;
	    }
	    /**
	     * Appends an insert operation. Returns this for chainability.
	     *
	     * @param {String|Object} text Represents text or embed to insert
	     * @param {Object} attributes Optional attributes to apply
	     */
	    Delta.prototype.insert = function (text, attributes) {
	        var newOp = {};
	        if (text.length === 0)
	            return this;
	        newOp.insert = text;
	        if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
	            newOp.attributes = attributes;
	        }
	        return this._push(newOp);
	    };
	    /**
	     * Appends a delete operation. Returns this for chainability.
	     *
	     * @param {Number} length Number of characters to delete
	     */
	    Delta.prototype["delete"] = function (length) {
	        if (length <= 0)
	            return this;
	        return this._push({ "delete": length });
	    };
	    /**
	     * Appends a retain operation. Returns this for chainability.
	     *
	     * @param {Number} length Number of characters to retain
	     * @param {Object} attributes Optional attributes to apply
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.retain = function (length, attributes) {
	        if (length <= 0)
	            return this;
	        var newOp = { retain: length };
	        if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
	            newOp.attributes = attributes;
	        }
	        return this._push(newOp);
	    };
	    /**
	     * Freezes delta from future modifications. Returns this for chainability.
	     *
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.freeze = function () {
	        var _this = this;
	        this._push = function () { return _this; };
	        return this;
	    };
	    /**
	     * Adds a new operation. Returns this for chainability.
	     *
	     * @param {Object} newOp A new operation
	     * @returns {Delta} This delta
	     */
	    Delta.prototype._push = function (newOp) {
	        var index = this.ops.length;
	        var lastOp = this.ops[index - 1];
	        if (typeof lastOp === 'object') {
	            if (typeof newOp["delete"] === 'number' && typeof lastOp["delete"] === 'number') {
	                this.ops[index - 1] = { "delete": lastOp["delete"] + newOp["delete"] };
	                return this;
	            }
	            // Since it does not matter if we insert before or after deleting at the same index,
	            // always prefer to insert first
	            if (typeof lastOp["delete"] === 'number' && newOp.insert != null) {
	                index -= 1;
	                lastOp = this.ops[index - 1];
	                if (typeof lastOp !== 'object') {
	                    this.ops.unshift(newOp);
	                    return this;
	                }
	            }
	            if (deepEqual$1$1(newOp.attributes, lastOp.attributes)) {
	                if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {
	                    this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };
	                    if (typeof newOp.attributes === 'object')
	                        this.ops[index - 1].attributes = newOp.attributes;
	                    return this;
	                }
	                else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {
	                    this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };
	                    if (typeof newOp.attributes === 'object')
	                        this.ops[index - 1].attributes = newOp.attributes;
	                    return this;
	                }
	            }
	        }
	        if (index === this.ops.length) {
	            this.ops.push(newOp);
	        }
	        else {
	            this.ops.splice(index, 0, newOp);
	        }
	        return this;
	    };
	    /**
	     * Chops off trailing retain instructions to make the delta concise.
	     *
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.chop = function () {
	        var lastOp = this.ops[this.ops.length - 1];
	        if (lastOp && lastOp.retain && !lastOp.attributes) {
	            this.ops.pop();
	        }
	        return this;
	    };
	    /**
	     * Returns an iterator to iterate over the operations of this delta.
	     *
	     * @returns {Iterator} An operation iterator with methods hasNext, next, peek, peekLength, & peekType
	     */
	    Delta.prototype.iterator = function () {
	        return new Iterator$1$1(this.ops);
	    };
	    /**
	     * Returns an array of operations that passes a given function.
	     *
	     * @param {Function} predicate Function to test each operation against. Return true to keep the operation, false
	     *                             otherwise
	     * @returns {Array} Filtered resulting array
	     */
	    Delta.prototype.filter = function (predicate) {
	        return this.ops.filter(predicate);
	    };
	    /**
	     * Iterates through operations, calling the provided function for each operation.
	     *
	     * @param {Function} predicate Function to call during iteration, passing in the current operation
	     */
	    Delta.prototype.forEach = function (predicate) {
	        this.ops.forEach(predicate);
	    };
	    /**
	     * Returns a new array with the results of calling provided function on each operation.
	     *
	     * @param {Function} predicate Function to call, passing in the current operation, returning an element of the new
	     *                             array to be returned
	     * @returns {Array} A new array with each element being the result of the given function
	     */
	    Delta.prototype.map = function (predicate) {
	        return this.ops.map(predicate);
	    };
	    /**
	     * Create an array of two arrays, the first with operations that pass the given function, the other that failed.
	     *
	     * @param {Function} predicate Function to call, passing in the current operation, returning whether that operation
	     *                             passed
	     * @returns {Array} A new array of two Arrays, the first with passed operations, the other with failed operations
	     */
	    Delta.prototype.partition = function (predicate) {
	        var passed = [], failed = [];
	        this.forEach(function (op) {
	            var target = predicate(op) ? passed : failed;
	            target.push(op);
	        });
	        return [passed, failed];
	    };
	    /**
	     * Applies given function against an accumulator and each operation to reduce to a single value.
	     *
	     * @param {Function} predicate Function to call per iteration, returning an accumulated value
	     * @param {*} initial Initial value to pass to first call to predicate
	     * @returns {*} The accumulated value
	     */
	    Delta.prototype.reduce = function (predicate, initial) {
	        return this.ops.reduce(predicate, initial);
	    };
	    Delta.prototype.changeLength = function () {
	        return this.reduce(function (length, entry) {
	            if (entry.insert) {
	                return length + getOpLength$1$1(entry);
	            }
	            else if (entry["delete"]) {
	                return length - entry["delete"];
	            }
	            return length;
	        }, 0);
	    };
	    /**
	     * Returns length of a Delta, which is the sum of the lengths of its operations.
	     *
	     * @returns {Number} The length of this delta
	     */
	    Delta.prototype.length = function () {
	        return this.reduce(function (length, entry) {
	            return length + getOpLength$1$1(entry);
	        }, 0);
	    };
	    /**
	     * Returns copy of delta with subset of operations.
	     *
	     * @param {Number} start Start index of subset, defaults to 0
	     * @param {Number} end End index of subset, defaults to rest of operations
	     * @returns {Array} An array slice of the operations
	     */
	    Delta.prototype.slice = function (start, end) {
	        if (start === void 0) { start = 0; }
	        if (typeof end !== 'number')
	            end = Infinity;
	        var ops = [];
	        var iter = this.iterator();
	        var index = 0;
	        while (index < end && iter.hasNext()) {
	            var nextOp;
	            if (index < start) {
	                nextOp = iter.next(start - index);
	            }
	            else {
	                nextOp = iter.next(end - index);
	                ops.push(nextOp);
	            }
	            index += getOpLength$1$1(nextOp);
	        }
	        return new Delta(ops);
	    };
	    /**
	     * Returns a Delta that is equivalent to applying the operations of own Delta, followed by another Delta.
	     *
	     * @param {Delta} other Delta to compose
	     */
	    Delta.prototype.compose = function (other) {
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        var delta = new Delta();
	        while (thisIter.hasNext() || otherIter.hasNext()) {
	            if (otherIter.peekType() === 'insert') {
	                delta._push(otherIter.next());
	            }
	            else if (thisIter.peekType() === 'delete') {
	                delta._push(thisIter.next());
	            }
	            else {
	                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
	                var thisOp = thisIter.next(length);
	                var otherOp = otherIter.next(length);
	                if (typeof otherOp.retain === 'number') {
	                    var newOp = {};
	                    if (typeof thisOp.retain === 'number') {
	                        newOp.retain = length;
	                    }
	                    else {
	                        newOp.insert = thisOp.insert;
	                    }
	                    // Preserve null when composing with a retain, otherwise remove it for inserts
	                    var attributes = composeAttributes$1$1(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');
	                    if (attributes)
	                        newOp.attributes = attributes;
	                    delta._push(newOp);
	                    // Optimization if rest of other is just retain
	                    if (!otherIter.hasNext() && deepEqual$1$1(delta.ops[delta.ops.length - 1], newOp)) {
	                        var rest = new Delta(thisIter.rest());
	                        return delta.concat(rest).chop();
	                    }
	                    // Other op should be delete, we could be an insert or retain
	                    // Insert + delete cancels out
	                }
	                else if (typeof otherOp["delete"] === 'number' && typeof thisOp.retain === 'number') {
	                    delta._push(otherOp);
	                }
	            }
	        }
	        return delta.chop();
	    };
	    /**
	     * Returns a new Delta representing the concatenation of this and another document Delta's operations.
	     *
	     * @param {Delta} other Document Delta to concatenate
	     * @returns {Delta} Concatenated document Delta
	     */
	    Delta.prototype.concat = function (other) {
	        var delta = new Delta(this.ops.slice());
	        if (other.ops.length > 0) {
	            delta._push(other.ops[0]);
	            delta.ops = delta.ops.concat(other.ops.slice(1));
	        }
	        return delta;
	    };
	    /**
	     * Returns a Delta representing the difference between two documents. Optionally, accepts a suggested index where
	     * change took place, often representing a cursor position before change.
	     *
	     * @param {Delta} other Document Delta to diff against
	     * @param {Number} index Suggested index where change took place
	     * @returns {Delta} Difference between the two documents
	     */
	    Delta.prototype.diff = function (other, index) {
	        if (this.ops === other.ops) {
	            return new Delta();
	        }
	        var strings = [this, other].map(function (delta) {
	            return delta.map(function (op) {
	                if (op.insert != null) {
	                    return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER$1$1;
	                }
	                var prep = (delta === other) ? 'on' : 'with';
	                throw new Error('diff() called ' + prep + ' non-document');
	            }).join('');
	        });
	        var delta = new Delta();
	        var diffResult = diff$1$1(strings[0], strings[1], index);
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        diffResult.forEach(function (component) {
	            var length = component[1].length;
	            while (length > 0) {
	                var opLength = 0;
	                switch (component[0]) {
	                    case diff$1$1.INSERT:
	                        opLength = Math.min(otherIter.peekLength(), length);
	                        delta._push(otherIter.next(opLength));
	                        break;
	                    case diff$1$1.DELETE:
	                        opLength = Math.min(length, thisIter.peekLength());
	                        thisIter.next(opLength);
	                        delta["delete"](opLength);
	                        break;
	                    case diff$1$1.EQUAL:
	                        opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
	                        var thisOp = thisIter.next(opLength);
	                        var otherOp = otherIter.next(opLength);
	                        if (deepEqual$1$1(thisOp.insert, otherOp.insert)) {
	                            delta.retain(opLength, diffAttributes$1$1(thisOp.attributes, otherOp.attributes));
	                        }
	                        else {
	                            delta._push(otherOp)["delete"](opLength);
	                        }
	                        break;
	                }
	                length -= opLength;
	            }
	        });
	        return delta.chop();
	    };
	    /**
	     * Iterates through document Delta, calling a given function with a Delta and attributes object, representing the line
	     * segment.
	     *
	     * @param {Function} predicate Function to call on each line group
	     * @param {String} newline Newline character, defaults to \n
	     */
	    Delta.prototype.eachLine = function (predicate, newline) {
	        if (newline === void 0) { newline = '\n'; }
	        var iter = this.iterator();
	        var ops = new Delta();
	        var index = 0;
	        var lineStart = 0;
	        var currentIndex = 0;
	        while (iter.hasNext()) {
	            if (iter.peekType() !== 'insert')
	                return;
	            var op = iter.peek();
	            var nextLength = iter.peekLength();
	            var start = getOpLength$1$1(op) - nextLength;
	            var newlineIndex = typeof op.insert === 'string' ? op.insert.indexOf(newline, start) - start : -1;
	            if (newlineIndex < 0) {
	                currentIndex += nextLength;
	                ops._push(iter.next());
	            }
	            else if (newlineIndex > 0) {
	                currentIndex += newlineIndex;
	                ops._push(iter.next(newlineIndex));
	            }
	            else {
	                currentIndex += 1;
	                var attributes = iter.next(1).attributes || {};
	                var line = { ops: ops, attributes: attributes, start: lineStart, end: currentIndex, index: index };
	                if (predicate(line, index) === false) {
	                    return;
	                }
	                index += 1;
	                lineStart = currentIndex;
	                ops = new Delta();
	            }
	        }
	        if (ops.length() > 0) {
	            var line_1 = { ops: ops, attributes: {}, start: lineStart, end: currentIndex, index: index };
	            predicate(line_1, index);
	        }
	    };
	    // Extends Delta, get the lines from `from` to `to`.
	    Delta.prototype.getLines = function (from, to, newline) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = Infinity; }
	        var lines = [];
	        this.eachLine(function (line) {
	            if (line.start > to || (line.start === to && from !== to))
	                return false;
	            if (line.end > from) {
	                lines.push(line);
	            }
	        }, newline);
	        return lines;
	    };
	    // Extends Delta, get the line at `at`.
	    Delta.prototype.getLine = function (at, newline) {
	        return this.getLines(at, at, newline)[0];
	    };
	    // Extends Delta, get the ops from `from` to `to`.
	    Delta.prototype.getOps = function (from, to) {
	        var start = 0;
	        var ops = [];
	        this.ops.some(function (op) {
	            if (start >= to)
	                return true;
	            var end = start + getOpLength$1$1(op);
	            if (end > from || (from === to && end === to)) {
	                ops.push({ op: op, start: start, end: end });
	            }
	            start = end;
	        });
	        return ops;
	    };
	    // Extends Delta, get the op at `at`.
	    Delta.prototype.getOp = function (at) {
	        return this.getOps(at, at)[0];
	    };
	    /**
	     * Transform given Delta against own operations. Used as an alias for transformPosition when called with a number.
	     *
	     * @param {Delta} other Delta to transform
	     * @param {Boolean} priority Boolean used to break ties. If true, then this takes priority over other, that is, its
	     *                           actions are considered to happen "first."
	     * @returns {Delta} Transformed Delta
	     */
	    Delta.prototype.transform = function (other, priority) {
	        if (priority === void 0) { priority = false; }
	        if (typeof other === 'number') {
	            return this.transformPosition(other, priority);
	        }
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        var delta = new Delta();
	        while (thisIter.hasNext() || otherIter.hasNext()) {
	            if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {
	                delta.retain(getOpLength$1$1(thisIter.next()));
	            }
	            else if (otherIter.peekType() === 'insert') {
	                delta._push(otherIter.next());
	            }
	            else {
	                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
	                var thisOp = thisIter.next(length);
	                var otherOp = otherIter.next(length);
	                if (thisOp["delete"]) {
	                    // Our delete either makes their delete redundant or removes their retain
	                    continue;
	                }
	                else if (otherOp["delete"]) {
	                    delta._push(otherOp);
	                }
	                else {
	                    // We retain either their retain or insert
	                    delta.retain(length, transformAttributes$1$1(thisOp.attributes, otherOp.attributes, priority));
	                }
	            }
	        }
	        return delta.chop();
	    };
	    /**
	     * Transform an index against the delta. Useful for representing cursor/selection positions.
	     *
	     * @param {Number} index Index to transform
	     * @param {Boolean} priority Boolean used to break ties. If true, then this takes priority over other, that is, its
	     *                           actions are considered to happen "first."
	     * @returns {Number} Transformed index
	     */
	    Delta.prototype.transformPosition = function (index, priority) {
	        if (priority === void 0) { priority = false; }
	        var thisIter = this.iterator();
	        var offset = 0;
	        while (thisIter.hasNext() && offset <= index) {
	            var length = thisIter.peekLength();
	            var nextType = thisIter.peekType();
	            thisIter.next();
	            if (nextType === 'delete') {
	                index -= Math.min(length, index - offset);
	                continue;
	            }
	            else if (nextType === 'insert' && (offset < index || !priority)) {
	                index += length;
	            }
	            offset += length;
	        }
	        return index;
	    };
	    return Delta;
	}());
	/**
	 * Create an attributes object that is equivalent to applying the attributes of the target followed by the source.
	 *
	 * @param {Object} target Target attributes object which will have the source applied to
	 * @param {Object} source Source attributes object being applied to the target
	 * @param {Boolean} keepNull Whether to keep null values from source
	 * @returns {Object} A new attributes object (or undefined if empty) with both
	 */
	function composeAttributes$1$1(target, source, keepNull) {
	    if (target === void 0) { target = {}; }
	    if (source === void 0) { source = {}; }
	    var attributes = __assign$2$1({}, target, source);
	    if (!keepNull)
	        Object.keys(attributes).forEach(function (key) {
	            if (attributes[key] == null)
	                delete attributes[key];
	        });
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Finds the difference between two attributes objects. Returns the source attributes that are different from the
	 * target attributes.
	 *
	 * @param {Object} target An attributes object
	 * @param {Object} source An attributes object
	 * @returns {Object} The difference between the two attribute objects or undefined if there is none
	 */
	function diffAttributes$1$1(target, source) {
	    if (target === void 0) { target = {}; }
	    if (source === void 0) { source = {}; }
	    var attributes = Object.keys(target).concat(Object.keys(source)).reduce(function (attributes, key) {
	        if (!deepEqual$1$1(target[key], source[key])) {
	            attributes[key] = source[key] === undefined ? null : source[key];
	        }
	        return attributes;
	    }, {});
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Transforms the attributes of source over target (or the other way around if priority is set). Will return an
	 * attributes object which has all the values from source if priority if false or will have the values from source that
	 * are set on target.
	 *
	 * @param {Object} target An attributes object
	 * @param {Object} source An attributes object
	 * @param {Boolean} priority If target has priority over source
	 */
	function transformAttributes$1$1(target, source, priority) {
	    if (typeof target !== 'object')
	        return source;
	    if (typeof source !== 'object')
	        return undefined;
	    if (!priority)
	        return source; // b simply overwrites us without priority
	    var attributes = Object.keys(source).reduce(function (attributes, key) {
	        if (target[key] === undefined)
	            attributes[key] = source[key]; // null is a valid value
	        return attributes;
	    }, {});
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Determines the length of a Delta operation.
	 *
	 * @param {Object} op An operation entry from a Delta object
	 * @returns {Number} The length of the op
	 */
	function getOpLength$1$1(op) {
	    if (typeof op["delete"] === 'number') {
	        return op["delete"];
	    }
	    else if (typeof op.retain === 'number') {
	        return op.retain;
	    }
	    else {
	        return typeof op.insert === 'string' ? op.insert.length : 1;
	    }
	}
	/**
	 * An iterator to handle iterating over a list of Delta operations efficiently.
	 */
	var Iterator$1$1 = /** @class */ (function () {
	    function Iterator(ops) {
	        this.ops = ops;
	        this.index = 0;
	        this.offset = 0;
	    }
	    /**
	     * Determine if there will be another operation returned by `next`.
	     *
	     * @returns {Boolean} Whether there are more operations to iterate over
	     */
	    Iterator.prototype.hasNext = function () {
	        return this.peekLength() < Infinity;
	    };
	    /**
	     * Get the next operation, optionally limited/sliced by length. If an operation is sliced by length, the next call to
	     * `next` will return more of that operation until it is returned in full.
	     *
	     * @param {Number} length Optionally limit the returned operation by length, slicing it down as needed
	     */
	    Iterator.prototype.next = function (length) {
	        if (length === void 0) { length = Infinity; }
	        var nextOp = this.ops[this.index];
	        if (!nextOp)
	            return { retain: Infinity };
	        var offset = this.offset;
	        var opLength = getOpLength$1$1(nextOp);
	        // Update index and offset
	        if (length >= opLength - offset) {
	            length = opLength - offset;
	            this.index += 1;
	            this.offset = 0;
	        }
	        else {
	            this.offset += length;
	        }
	        if (typeof nextOp["delete"] === 'number') {
	            return { "delete": length };
	        }
	        else {
	            var retOp = {};
	            if (nextOp.attributes) {
	                retOp.attributes = nextOp.attributes;
	            }
	            if (typeof nextOp.retain === 'number') {
	                retOp.retain = length;
	            }
	            else if (typeof nextOp.insert === 'string') {
	                retOp.insert = nextOp.insert.substr(offset, length);
	            }
	            else {
	                // offset should === 0, length should === 1
	                retOp.insert = nextOp.insert;
	            }
	            return retOp;
	        }
	    };
	    /**
	     * Return the next entry.
	     *
	     * @returns {Object} The next entry in the ops array.
	     */
	    Iterator.prototype.peek = function () {
	        return this.ops[this.index];
	    };
	    /**
	     * Check the length of the next entry.
	     *
	     * @returns {Number} The length of the next entry or Infinity if there is no next entry
	     */
	    Iterator.prototype.peekLength = function () {
	        if (this.ops[this.index]) {
	            // Should never return 0 if our index is being managed correctly
	            return getOpLength$1$1(this.ops[this.index]) - this.offset;
	        }
	        else {
	            return Infinity;
	        }
	    };
	    /**
	     * Check the type of the next entry, delete, retain, or insert.
	     *
	     * @returns {String} The type of the next entry
	     */
	    Iterator.prototype.peekType = function () {
	        if (this.ops[this.index]) {
	            if (typeof this.ops[this.index]["delete"] === 'number') {
	                return 'delete';
	            }
	            else if (typeof this.ops[this.index].retain === 'number') {
	                return 'retain';
	            }
	            else {
	                return 'insert';
	            }
	        }
	        return 'retain';
	    };
	    Iterator.prototype.rest = function () {
	        if (!this.hasNext()) {
	            return [];
	        }
	        else if (this.offset === 0) {
	            return this.ops.slice(this.index);
	        }
	        else {
	            var offset = this.offset;
	            var index = this.index;
	            var next = this.next();
	            var rest = this.ops.slice(this.index);
	            this.offset = offset;
	            this.index = index;
	            return [next].concat(rest);
	        }
	    };
	    return Iterator;
	}());

	var SOURCE_API$1$1 = 'api';
	var SOURCE_USER$1$1 = 'user';
	var SOURCE_SILENT$1$1 = 'silent';
	var empty$1$1 = {};
	/**
	 * Event for text changes, called before the change has occurred. If a listener returns false the change will be
	 * canceled and not committed.
	 *
	 * @event Editor#text-changing
	 * @type  {Object}
	 * @property {Delta} change       The change which is being applied to the content
	 * @property {Delta} content      The new content after the change
	 * @property {Delta} oldContent   The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * Event for text changes, called after the change has occurred.
	 *
	 * @event Editor#text-change
	 * @type  {Object}
	 * @property {Delta} change       The change which is being applied to the content
	 * @property {Delta} content      The new content after the change
	 * @property {Delta} oldContent   The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * Event for selection changes. If part of a text change the `change`, `content`, and `oldContent` properties will be
	 * set. Otherwise they will not be set.
	 *
	 * @event Editor#selection-change
	 * @type  {Object}
	 * @property {Delta} change       [ Optional ] The change which is being applied to the content
	 * @property {Delta} content      [ Optional ] The new content after the change
	 * @property {Delta} oldContent   [ Optional ] The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * A Typewriter Editor handles the logic for selection and editing of contents. It has no dependency on browser APIs
	 * and can be used in Node.js as easily as the browser. It has no logic to limit formatting (i.e. it does not disallow
	 * using bold, headers, links, or FOOBAR), that will need to be limited outside of the editor itself.
	 *
	 * @fires Editor#text-changing
	 * @fires Editor#text-change
	 * @fires Editor#selection-change
	 *
	 * @readonly @property {Delta}  contents      The data model for the text editor
	 * @readonly @property {Number} length        The length of the contents
	 * @readonly @property {String} text          The text of the contents
	 * @readonly @property {Array}  selection     The current editor selection, a tuple of `[ from, to ]` or `null`
	 * @readonly @property {Object} activeFormats The currently active formats (formats that will apply on the next insert)
	 */
	var Editor$1$1 = /** @class */ (function (_super) {
	    __extends$1$1(Editor, _super);
	    /**
	     * Create a new Typewriter editor.
	     *
	     * @param {Object} options Options for this editor include initial `contents` and `modules`:
	     * @param {Delta}  options.contents The initial contents of this editor
	     */
	    function Editor(options) {
	        if (options === void 0) { options = {}; }
	        var _this = _super.call(this) || this;
	        _this.contents = null;
	        _this.length = 0;
	        _this.selection = null;
	        _this.activeFormats = empty$1$1;
	        setContents$1$1(_this, options.contents || _this.delta().insert('\n'));
	        _this._queuedEvents = []; // Event queuing ensure they are fired in order
	        return _this;
	    }
	    /**
	     * Convenience method for creating a new delta.
	     *
	     * @param {Array} ops [Optional] The initial ops for the delta
	     * @returns {Delta}   A new Delta object
	     */
	    Editor.prototype.delta = function (ops) {
	        return new Delta$1$1(ops);
	    };
	    /**
	     * Returns the contents or a slice of them.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {Delta}     The contents of this editor
	     */
	    Editor.prototype.getContents = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.contents.slice(from, to);
	    };
	    /**
	     * Returns the text for the editor or a slice of it.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {String}    The text in the editor
	     */
	    Editor.prototype.getText = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length - 1; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.getContents(from, to)
	            .filter(function (op) { return typeof op.insert === 'string'; })
	            .map(function (op) { return op.insert; })
	            .join('');
	    };
	    /**
	     * Returns the text for the editor with null characters in place of embeds. This can be used to determine the index of
	     * given words or lines of text within the contents.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {String}    The text in the editor with embed spaces
	     */
	    Editor.prototype.getExactText = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length - 1; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.getContents(from, to)
	            .map(function (op) { return typeof op.insert === 'string' ? op.insert : '\0'; })
	            .join('');
	    };
	    /**
	     * Set the selection to a new location (or null for no selection). Will return false if the new selection is the same
	     * as the old selection. Dispatches "selection-change" once the selection is changed. This "selection-change" event
	     * won't have { contents, oldContnts, change } in it since the selection is changing without any content updates.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Boolean}        Whether the selection changed or not
	     */
	    Editor.prototype.setSelection = function (from, to, source) {
	        var _this = this;
	        if (source === void 0) { source = SOURCE_USER$1$1; }
	        var _a;
	        var oldSelection = this.selection;
	        var selection;
	        if (from === null) {
	            selection = null;
	            if (typeof to === 'string')
	                source = to;
	        }
	        else {
	            _a = this._normalizeSelection(from, to, source), from = _a[0], to = _a[1], source = _a[2];
	            selection = [from, to].map(function (i) { return Math.min(i, _this.length - 1); });
	        }
	        if (shallowEqual$1$1(oldSelection, selection))
	            return false;
	        // Reset the active formats when selection changes (do this before setting selection)
	        this.activeFormats = selection ? this.getTextFormat(Math.min(selection[0], selection[1])) : empty$1$1;
	        this.selection = selection;
	        var event = { selection: selection, oldSelection: oldSelection, source: source };
	        if (source !== SOURCE_SILENT$1$1)
	            this.fire('selection-change', event);
	        this.fire('editor-change', event);
	        return true;
	    };
	    /**
	     * The method that all other methods use to update the contents (even setContents & setText). This method will
	     * dispatch the event "text-changing". If a listener returns `false` then the change will be canceled and null will
	     * be returned. Otherwise, the change will be successful and if the `source` is not "silent" a "text-change" event
	     * will be fired with an event object containing `{ contents, oldContents, selection, oldSelection, source }`. If the
	     * selection has changed as part of this update a "selection-change" event will also be fired with the same event
	     * object.
	     *
	     * @param {Delta} change    A delta change to the document
	     * @param {String} source   The source of the change, user, api, or silent
	     * @param {Array} selection Optional selection after the change has been applied
	     * @returns {Delta}         Returns the change when successful, or null if not
	     */
	    Editor.prototype.updateContents = function (change, source, selection) {
	        if (source === void 0) { source = SOURCE_API$1$1; }
	        if (!change.chop().ops.length)
	            return null;
	        if (typeof selection === 'number')
	            selection = [selection, selection];
	        var oldContents = this.contents;
	        var contents = normalizeContents$1$1(oldContents.compose(change));
	        var length = contents.length();
	        var oldSelection = this.selection;
	        if (!selection)
	            selection = oldSelection ? oldSelection.map(function (i) { return change.transform(i); }) : oldSelection;
	        selection = selection && this.getSelectedRange(selection, length - 1);
	        var changeEvent = { contents: contents, oldContents: oldContents, change: change, selection: selection, oldSelection: oldSelection, source: source };
	        var selectionChanged = !shallowEqual$1$1(oldSelection, selection);
	        if (!this.fire('text-changing', changeEvent))
	            return null;
	        setContents$1$1(this, contents);
	        if (selection) {
	            // Reset the active formats when selection changes (do this before setting selection)
	            this.activeFormats = selection ? this.getTextFormat(Math.min(selection[0], selection[1])) : empty$1$1;
	            this.selection = selection;
	        }
	        var events = [];
	        if (source !== SOURCE_SILENT$1$1) {
	            events.push(['text-change', changeEvent]);
	            if (selectionChanged)
	                events.push(['selection-change', changeEvent]);
	        }
	        events.push(['editor-change', changeEvent]);
	        this._queueEvents(events);
	        return change;
	    };
	    /**
	     * Sets the entire contents of the editor. This will calculate the difference between the old content and the new and
	     * only apply the difference, if any.
	     *
	     * @param {Delta} newContents The contents of the editor, as a delta object
	     * @param {String} source     The source of the change, user, api, or silent
	     * @param {Array} selection   Optional selection after the change has been applied
	     * @returns {Delta}           Returns the change when successful, or null if not
	     */
	    Editor.prototype.setContents = function (newContents, source, selection) {
	        var change = this.contents.diff(normalizeContents$1$1(newContents));
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Sets the text content of the editor, removing existing contents and formatting.
	     *
	     * @param {String} text     Set the contents of this editor as text
	     * @param {String} source   The source of the change, user, api, or silent
	     * @param {Array} selection Optional selection after the change has been applied
	     * @returns {Delta}         Returns the change when successful, or null if not
	     */
	    Editor.prototype.setText = function (text, source, selection) {
	        return this.setContents(this.delta().insert(text + '\n'), source, selection);
	    };
	    /**
	     * Inserts text into the content of the editor, removing text between from and to if provided. If `text` is a newline
	     * ("\n") then the formats will apply to the line, otherwise they will apply to the text only (even if there are
	     * newlines in the text).
	     *
	     * @param {Number} from      Insert the text at this index, can also be a range Array tuple, default 0
	     * @param {Number} to        If provided and not equal to `from` will delete the text between `from` and `to`
	     * @param {String} text      The text to insert into the editor's contents
	     * @param {Object} formats   The formats of the inserted text. If null the formats at `from` will be used.
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.insertText = function (from, to, text, formats, source, selection) {
	        var _a, _b, _c;
	        _a = this._normalizeRange(from, to, text, formats, source, selection), from = _a[0], to = _a[1], text = _a[2], formats = _a[3], source = _a[4], selection = _a[5];
	        // If we are not inserting a newline, make sure from and to are within the selectable range
	        if (text !== '\n')
	            _b = this.getSelectedRange([from, to]), from = _b[0], to = _b[1];
	        if (typeof formats === 'string')
	            _c = [null, formats, source], formats = _c[0], source = _c[1], selection = _c[2];
	        if (selection == null && this.selection !== null)
	            selection = from + text.length;
	        var change = this.delta().retain(from)["delete"](to - from);
	        if (text === '\n') {
	            change.insert('\n', formats || this.getLineFormat(from));
	        }
	        else {
	            var lineFormat_1 = text.indexOf('\n') === -1 ? null : this.getLineFormat(from);
	            var textFormat_1 = formats || this.getTextFormat(from);
	            text.split('\n').forEach(function (line, i) {
	                if (i)
	                    change.insert('\n', lineFormat_1);
	                line.length && change.insert(line, textFormat_1);
	            });
	        }
	        change = cleanDelete$1$1(this, from, to, change);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Inserts an embed into the content of the editor, removing text between from and to if provided.
	     *
	     * @param {Number} from      Insert the embed at this index, can also be a range Array tuple, default 0
	     * @param {Number} to        If provided and not equal to `from` will delete the text between `from` and `to`
	     * @param {String} embed     Insert the text into the editor's contents
	     * @param {mixed}  value     Insert the text into the editor's contents
	     * @param {String} formats   The formats of the inserted text. If null the formats at `from` will be used.
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.insertEmbed = function (from, to, embed, value, formats, source, selection) {
	        var _a, _b, _c;
	        _a = this._normalizeRange(from, to, embed, value, source, selection), from = _a[0], to = _a[1], embed = _a[2], value = _a[3], source = _a[4], selection = _a[5];
	        if (typeof formats === 'string')
	            _b = [null, formats, source], formats = _b[0], source = _b[1], selection = _b[2];
	        if (from >= this.length)
	            from = this.length - 1;
	        if (to >= this.length)
	            to = this.length - 1;
	        if (selection == null && this.selection !== null)
	            selection = from + 1;
	        var textFormat = formats || this.getTextFormat(from);
	        var change = this.delta().retain(from)["delete"](to - from).insert((_c = {}, _c[embed] = value, _c), textFormat);
	        change = cleanDelete$1$1(this, from, to, change);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Deletes text from `from` to `to`.
	     *
	     * @param {Number} from      Insert the text as this index, can also be a range Array tuple, default 0
	     * @param {Number} to        Will delete the text between `from` and `to`
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.deleteText = function (from, to, source, selection) {
	        var _a;
	        _a = this._normalizeRange(from, to, source, selection), from = _a[0], to = _a[1], source = _a[2], selection = _a[3];
	        if (from === to)
	            return null;
	        if (selection == null && this.selection !== null)
	            selection = from;
	        var change = this.delta().retain(from)["delete"](to - from);
	        change = cleanDelete$1$1(this, from, to, change);
	        // Keep the active format of the text to the right of the cursor when deleting
	        var activeFormats;
	        if (selection === from)
	            activeFormats = this.getTextFormat(from, from + 1);
	        var result = this.updateContents(change, source, selection);
	        if (result && activeFormats)
	            this.activeFormats = activeFormats;
	        return result;
	    };
	    /**
	     * Get the line formats for the line that `from` is in to the line that `to` is in. Returns only the common formats
	     * between all the lines. If `from` equals `to` (or `to` is not provided) the formats will be all of those for the
	     * line `from` is on. If two lines are touched and they have different formats, an empty object will be returned.
	     *
	     * @param {Number} from Getting line formats starting at `from`
	     * @param {Number} to   Getting line formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the lines which intersect from and to
	     */
	    Editor.prototype.getLineFormat = function (from, to) {
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        var formats;
	        this.contents.getLines(from, to).forEach(function (line) {
	            if (!line.attributes)
	                formats = {};
	            else if (!formats)
	                formats = __assign$2$1({}, line.attributes);
	            else
	                formats = combineFormats$1$1(formats, line.attributes);
	        });
	        return formats;
	    };
	    /**
	     * Get the text formats for all the text from `from` to `to`. Returns only the common formats between the two indexes.
	     * Will also return the `activeFormats`. Active formats are those which are toggled on when the selection is collapsed
	     * (from and to are equal) indicating inserted text should use (or not use) those formats.
	     *
	     * @param {Number} from Getting text formats starting at `from`
	     * @param {Number} to   Getting text formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the text
	     */
	    Editor.prototype.getTextFormat = function (from, to) {
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        var formats;
	        // optimize for current selection
	        var seleciton = this.selection;
	        if (from === to && shallowEqual$1$1(this.selection, [from, to])) {
	            return this.activeFormats;
	        }
	        this.contents.getOps(from, to).forEach(function (_a) {
	            var op = _a.op;
	            if (/^\n+$/.test(op.insert))
	                return;
	            if (!op.attributes)
	                formats = {};
	            else if (!formats)
	                formats = __assign$2$1({}, op.attributes);
	            else
	                formats = combineFormats$1$1(formats, op.attributes);
	        });
	        if (!formats)
	            formats = {};
	        return formats;
	    };
	    /**
	     * Get the text and line formats for all the lines and text from `from` to `to`.
	     *
	     * @param {Number} from Getting line and text formats starting at `from`
	     * @param {Number} to   Getting line and text formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the lines and text which intersect from and to
	     */
	    Editor.prototype.getFormat = function (from, to) {
	        return __assign$2$1({}, this.getTextFormat(from, to), this.getLineFormat(from, to));
	    };
	    /**
	     * Formats the lines intersected by `from` and `to` with the given line formats. To remove an existing format pass in
	     * `null` or `false` to turn it off (e.g. `{ blockquote: false }`).
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the line
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.formatLine = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var change = this.delta();
	        this.contents.getLines(from, to).forEach(function (line) {
	            if (!change.ops.length)
	                change.retain(line.end - 1);
	            else
	                change.retain(line.end - line.start - 1);
	            // Clear out old formats on the line
	            Object.keys(line.attributes).forEach(function (name) { return !formats[name] && (formats[name] = null); });
	            change.retain(1, formats);
	        });
	        change.chop();
	        return change.ops.length ? this.updateContents(change, source) : null;
	    };
	    /**
	     * Formats the text from `from` to `to` with the given text formats. To remove an existing format pass in `null` or
	     * `false` to turn it off (e.g. `{ bold: false }`).
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the text
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.formatText = function (from, to, formats, source) {
	        var _this = this;
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        if (from === to) {
	            if (this.activeFormats === empty$1$1)
	                this.activeFormats = {};
	            Object.keys(formats).forEach(function (key) {
	                var value = formats[key];
	                if (value == null || value === false)
	                    delete _this.activeFormats[key];
	                else
	                    _this.activeFormats[key] = value;
	            });
	            return;
	        }
	        Object.keys(formats).forEach(function (name) { return formats[name] === false && (formats[name] = null); });
	        var change = this.delta().retain(from);
	        this.getText(from, to).split('\n').forEach(function (line) {
	            line.length && change.retain(line.length, formats);
	            change.retain(1);
	        });
	        change.chop();
	        return this.updateContents(change, source);
	    };
	    /**
	     * Toggles the line formats from `from` to `to` with the given line formats. If the line has the exact formats already
	     * they will be removed, otherwise they will be added.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the line
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.toggleLineFormat = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var existing = this.getLineFormat(from, to);
	        if (deepEqual$1$1(existing, formats)) {
	            Object.keys(formats).forEach(function (key) { return formats[key] = null; });
	        }
	        return this.formatLine(from, to, formats, source);
	    };
	    /**
	     * Toggles the text formats from `from` to `to` with the given text formats. If the text has the exact formats already
	     * they will be removed, otherwise they will be added.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the text
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.toggleTextFormat = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var existing = this.getTextFormat(from, to);
	        var isSame = Object.keys(formats).every(function (key) { return formats[key] === existing[key]; });
	        if (isSame) {
	            Object.keys(formats).forEach(function (key) { return formats[key] = null; });
	        }
	        return this.formatText(from, to, formats, source);
	    };
	    /**
	     * Removes all formatting, text and line formats, for the text and lines from `from` to `to`.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.removeFormats = function (from, to, source) {
	        var _this = this;
	        var _a;
	        _a = this._normalizeRange(from, to, source), from = _a[0], to = _a[1], source = _a[2];
	        var formats = {};
	        this.contents.getOps(from, to).forEach(function (_a) {
	            var op = _a.op;
	            op.attributes && Object.keys(op.attributes).forEach(function (key) { return formats[key] = null; });
	        });
	        var change = this.delta().retain(from).retain(to - from, formats);
	        // If the last block was not captured be sure to clear that too
	        this.contents.getLines(from, to).forEach(function (line) {
	            var formats = {};
	            Object.keys(line.attributes).forEach(function (key) { return formats[key] = null; });
	            change = change.compose(_this.delta().retain(line.end - 1).retain(1, formats));
	        });
	        return this.updateContents(change, source);
	    };
	    /**
	     * Create a change delta calling one or more methods on the editor. The changes will not be applied as normal but will
	     * be collated into a single change delta and returned from this methnod. Example:
	     * ```js
	     * var change = editor.getChange(function() {
	     *   editor.deleteText(0, 5);
	     *   editor.insertText('\n', { blockquote: true });
	     *   editor.formatText(10, 20, { bold: true });
	     * });
	     *
	     * editor.updateContents(change, 'user');
	     * ```
	     *
	     * @param {Function} producer A function in which to call methods on the editor to produce a change
	     * @returns {Delta}           The sum of all the changes made within the producer
	     */
	    Editor.prototype.getChange = function (producer) {
	        var change = this.delta();
	        this.updateContents = function (singleChange) {
	            if (singleChange.ops.length) {
	                change = change.compose(singleChange);
	                return singleChange;
	            }
	            else {
	                return null;
	            }
	        };
	        producer(this);
	        delete this.updateContents;
	        return change;
	    };
	    /**
	     * Make several changes to the editor apply all at one in one commit. Changes made with the transaction will be
	     * applied all together and the "text-changing", "text-change", and "selection-change" events will be dispatched only
	     * once. Use this to combine multiple changes into one.
	     *
	     * @param {Function} producer A function which should make changes with the editor
	     * @param {String} source     The source of the change, user, api, or silent
	     * @param {Array} selection   Optional selection after the change has been applied
	     * @returns {Delta}           Returns the change when successful, or null if not
	     */
	    Editor.prototype.transaction = function (producer, source, selection) {
	        var change = this.getChange(producer);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Returns the selected range (or the provided range) in index order (lowest number first) and within the bounds of
	     * the content, between 0 and content.length() - 1 (the selection cannot be past the trailing newline).
	     *
	     * @param {Array} range Optional range, defaults to current selection
	     * @param {Number} max  The maxium number the range can be
	     */
	    Editor.prototype.getSelectedRange = function (range, max) {
	        if (range === void 0) { range = this.selection; }
	        if (max === void 0) { max = this.length - 1; }
	        var _a;
	        if (range == null)
	            return range;
	        if (typeof range === 'number')
	            range = [range, range];
	        if (range[0] > range[1])
	            _a = [range[1], range[0]], range[0] = _a[0], range[1] = _a[1];
	        return range.map(function (index) { return Math.max(0, Math.min(max, index)); });
	    };
	    Editor.prototype._queueEvents = function (events) {
	        var _a;
	        var alreadyRunning = this._queuedEvents.length;
	        (_a = this._queuedEvents).push.apply(_a, events);
	        if (alreadyRunning)
	            return;
	        while (this._queuedEvents.length) {
	            var event = this._queuedEvents.shift();
	            this.fire.apply(this, event);
	        }
	    };
	    /**
	     * Normalizes range values to a proper range if it is not already. A range is a `from` and a `to` index, e.g. 0, 4.
	     * This will ensure the lower index is first. Example usage:
	     * editor._normalizeRange(5); // [5, 5]
	     * editor._normalizeRange(-4, 100); // for a doc with length 10, [0, 10]
	     * editor._normalizeRange(25, 18); // [18, 25]
	     * editor._normalizeRange([12, 13]); // [12, 13]
	     * editor._normalizeRange(5, { bold: true }); // [5, 5, { bold: true }]
	     */
	    Editor.prototype._normalizeRange = function (from, to) {
	        var rest = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            rest[_i - 2] = arguments[_i];
	        }
	        var _a;
	        _a = this._normalizeSelection.apply(this, [from, to].concat(rest)), from = _a[0], to = _a[1], rest = _a.slice(2);
	        if (from > to) {
	            var toValue = from;
	            from = to;
	            to = toValue;
	        }
	        return [from, to].concat(rest);
	    };
	    Editor.prototype._normalizeSelection = function (from, to) {
	        var rest = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            rest[_i - 2] = arguments[_i];
	        }
	        var _a;
	        if (Array.isArray(from)) {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            _a = from, from = _a[0], to = _a[1];
	            if (to === undefined)
	                to = from;
	        }
	        else if (typeof from !== 'number') {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            if (from !== undefined || rest.length)
	                rest.unshift(from);
	            from = to = 0;
	        }
	        else if (typeof to !== 'number') {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            to = from;
	        }
	        from = Math.max(0, Math.min(this.length, Math.floor(from)));
	        to = Math.max(0, Math.min(this.length, Math.floor(to)));
	        return [from, to].concat(rest);
	    };
	    return Editor;
	}(EventDispatcher$1$1));
	// Ensures the format for the current line in a delete remains the same when multiple lines are deleted. This is needed
	// because the last line holds the formatting after a delete, but the first line is expected to be the retained format
	function cleanDelete$1$1(editor, from, to, change) {
	    if (from !== to) {
	        var line = editor.contents.getLine(from);
	        if (!line.ops.length() && to === from + 1)
	            return change;
	        var lineFormat_2 = editor.getLineFormat(from);
	        if (!deepEqual$1$1(lineFormat_2, editor.getLineFormat(to))) {
	            var lineChange = editor.getChange(function () { return editor.formatLine(to, lineFormat_2); });
	            change = change.compose(change.transform(lineChange));
	        }
	    }
	    return change;
	}
	// Ensures contents end with a newline
	function normalizeContents$1$1(contents) {
	    // Contents only have inserts. Deletes and retains belong to changes only.
	    contents.ops = contents.ops.filter(function (op) { return op.insert; });
	    var lastOp = contents.ops[contents.ops.length - 1];
	    if (!lastOp || typeof lastOp.insert !== 'string' || lastOp.insert.slice(-1) !== '\n')
	        contents.insert('\n');
	    return contents;
	}
	// Sets the contents onto the editor after ensuring they end in a newline, freezes the contents from change, and
	// updates the length and text of the editor to the latest
	function setContents$1$1(editor, contents) {
	    contents = normalizeContents$1$1(contents);
	    contents.freeze();
	    editor.contents = contents;
	    editor.length = contents.length();
	}
	// Combine formats removing ones that don't exist in both and creating an array for those with multiple values
	function combineFormats$1$1(formats, combined) {
	    return Object.keys(combined).reduce(function (merged, name) {
	        if (formats[name] == null)
	            return merged;
	        if (combined[name] === formats[name]) {
	            merged[name] = combined[name];
	        }
	        else if (Array.isArray(combined[name])) {
	            if (combined[name].indexOf(formats[name]) < 0) {
	                merged[name] = combined[name].concat([formats[name]]);
	            }
	        }
	        else {
	            merged[name] = [combined[name], formats[name]];
	        }
	        return merged;
	    }, {});
	}

	var SOURCE_USER$2$1 = 'user';
	var mutationOptions = {
	    characterData: true,
	    characterDataOldValue: true,
	    subtree: true,
	    childList: true
	};
	// Basic text input module. Prevent any actions other than typing characters and handle with the API.
	function input(options) {
	    if (options === void 0) { options = {}; }
	    return function (editor, root, paper) {
	        // Final fallback. Handles composition text etc. Detects text changes from e.g. spell-check or Opt+E to produce ´
	        function onMutate(list) {
	            // Optimize for text changes (typing text)
	            var textChange = getTextChange(list);
	            var selection = getSelection(root, paper);
	            if (textChange) {
	                undoMutation(list, !options.forceTextUpdates);
	                editor.updateContents(textChange, SOURCE_USER$2$1, selection);
	            }
	            else {
	                // Handle everything else, pasted content, cut, spellcheck replacements
	                var delta = deltaFromDom(root, paper);
	                var change = editor.contents.diff(delta);
	                undoMutation(list);
	                editor.updateContents(change, SOURCE_USER$2$1, selection);
	            }
	        }
	        // Undo a DOM mutation so that the view can update it correctly if needed
	        function getTextChange(list) {
	            var mutation = getTextChangeMutation(list);
	            if (!mutation)
	                return;
	            var change = editor.delta();
	            var index = getNodeIndex(root, paper, mutation.target);
	            change.retain(index);
	            var diffs = diff$1$1(mutation.oldValue.replace(/\xA0/g, ' '), mutation.target.nodeValue.replace(/\xA0/g, ' '));
	            diffs.forEach(function (_a) {
	                var action = _a[0], string = _a[1];
	                if (action === diff$1$1.EQUAL)
	                    change.retain(string.length);
	                else if (action === diff$1$1.DELETE)
	                    change["delete"](string.length);
	                else if (action === diff$1$1.INSERT) {
	                    change.insert(string, editor.activeFormats);
	                }
	            });
	            change.chop();
	            return change;
	        }
	        // Undo a DOM mutation so that the view can update it correctly if needed
	        function undoMutation(list, exceptText) {
	            if (exceptText === void 0) { exceptText = false; }
	            observer.disconnect();
	            list.reverse().forEach(function (mutation) {
	                mutation.addedNodes.forEach(function (node) { return node.remove(); });
	                mutation.removedNodes.forEach(function (node) { return mutation.target.insertBefore(node, mutation.nextSibling); });
	                if (!exceptText && mutation.type === 'characterData')
	                    mutation.target.data = mutation.oldValue;
	            });
	            observer.observe(root, mutationOptions);
	        }
	        function onEnter(event) {
	            if (event.defaultPrevented)
	                return;
	            event.preventDefault();
	            var _a = editor.getSelectedRange(), from = _a[0], to = _a[1];
	            var line = editor.contents.getLine(from);
	            var attributes = line.attributes;
	            var block = paper.blocks.findByAttributes(attributes, true);
	            var isDefault = block === paper.blocks.getDefault();
	            var length = line.end - line.start - 1;
	            var atEnd = to === line.end - 1;
	            if (atEnd && !isDefault && block.defaultFollows) {
	                attributes = {};
	            }
	            else if (typeof block.getNextLineAttributes === 'function') {
	                attributes = block.getNextLineAttributes(attributes);
	            }
	            var activeFormats = editor.activeFormats;
	            if (!length && !isDefault && !block.defaultFollows && from === to) {
	                editor.formatLine(from, to, {}, SOURCE_USER$2$1);
	            }
	            else {
	                var selection = from + 1;
	                if (from === to)
	                    from = to = from + 1;
	                editor.insertText(from, to, '\n', attributes, SOURCE_USER$2$1, selection);
	            }
	            editor.activeFormats = activeFormats;
	        }
	        function onShiftEnter(event) {
	            if (event.defaultPrevented)
	                return;
	            event.preventDefault();
	            if (!paper.embeds.get('br'))
	                return;
	            var _a = editor.getSelectedRange(), from = _a[0], to = _a[1];
	            editor.insertEmbed(from, to, 'br', true, null, SOURCE_USER$2$1);
	        }
	        function onBackspace(event) {
	            if (event.defaultPrevented)
	                return;
	            event.preventDefault();
	            function flattenBlock(line, force) {
	                var block = paper.blocks.findByAttributes(line.attributes, true);
	                if (block.indentable && line.attributes.indent) {
	                    onTab(new CustomEvent('shortcut', { detail: 'Shift+Tab' }));
	                    return true;
	                }
	                if (block && (force || block !== paper.blocks.getDefault() && !block.defaultFollows)) {
	                    editor.formatLine(from, {}, SOURCE_USER$2$1);
	                    return true;
	                }
	            }
	            var _a = editor.getSelectedRange(), from = _a[0], to = _a[1];
	            if (from + to === 0) {
	                var line = editor.contents.getLine(from);
	                if (flattenBlock(line, true))
	                    return true;
	            }
	            else {
	                // The "from" block needs to stay the same. The "to" block gets merged into it
	                if (from === to) {
	                    var line = editor.contents.getLine(from);
	                    if (from === line.start && flattenBlock(line)) {
	                        return;
	                    }
	                    from--;
	                }
	                editor.deleteText(from, to, SOURCE_USER$2$1);
	            }
	        }
	        function onDelete(event) {
	            if (event.defaultPrevented)
	                return;
	            event.preventDefault();
	            var _a = editor.getSelectedRange(), from = _a[0], to = _a[1];
	            if (from === to && from === editor.length)
	                return;
	            if (from === to) {
	                to++;
	            }
	            editor.deleteText(from, to, SOURCE_USER$2$1);
	        }
	        function onTab(event) {
	            if (event.defaultPrevented)
	                return;
	            event.preventDefault();
	            var shortcut = event.detail;
	            var direction = shortcut === 'Tab' || shortcut === 'Mod+]' ? 1 : -1;
	            var _a = editor.getSelectedRange(), from = _a[0], to = _a[1];
	            var lines = editor.contents.getLines(from, to);
	            editor.transaction(function () {
	                lines.forEach(function (line) {
	                    var block = paper.blocks.findByAttributes(line.attributes, true);
	                    if (block.indentable) {
	                        var indent = (line.attributes.indent || 0) + direction;
	                        if (indent < 0) {
	                            editor.formatLine(line.start, {});
	                        }
	                        else {
	                            var attributes = __assign$1$1({}, line.attributes, { indent: indent });
	                            editor.formatLine(line.start, attributes);
	                        }
	                    }
	                });
	            }, SOURCE_USER$2$1);
	        }
	        var observer = new MutationObserver(onMutate);
	        observer.observe(root, mutationOptions);
	        // Don't observe the changes that occur when the view updates, we only want to respond to changes that happen
	        // outside of our API to read them back in
	        function onRendering() {
	            observer.disconnect();
	        }
	        // Once the view update is complete, continue observing for changes
	        function onRender() {
	            observer.observe(root, mutationOptions);
	        }
	        root.addEventListener('rendering', onRendering);
	        root.addEventListener('render', onRender);
	        root.addEventListener('shortcut:Enter', onEnter);
	        root.addEventListener('shortcut:Shift+Enter', onShiftEnter);
	        root.addEventListener('shortcut:Backspace', onBackspace);
	        root.addEventListener('shortcut:Delete', onDelete);
	        root.addEventListener('shortcut:Tab', onTab);
	        root.addEventListener('shortcut:Shift+Tab', onTab);
	        root.addEventListener('shortcut:Mod+]', onTab);
	        root.addEventListener('shortcut:Mod+[', onTab);
	        return {
	            onDestroy: function () {
	                observer.disconnect();
	                root.removeEventListener('rendering', onRendering);
	                root.removeEventListener('render', onRender);
	                root.removeEventListener('shortcut:Enter', onEnter);
	                root.removeEventListener('shortcut:Shift+Enter', onShiftEnter);
	                root.removeEventListener('shortcut:Backspace', onBackspace);
	                root.removeEventListener('shortcut:Delete', onDelete);
	                root.removeEventListener('shortcut:Tab', onTab);
	                root.removeEventListener('shortcut:Shift+Tab', onTab);
	                root.removeEventListener('shortcut:Mod+]', onTab);
	                root.removeEventListener('shortcut:Mod+[', onTab);
	            }
	        };
	    };
	}
	function getTextChangeMutation(list) {
	    if (list.length > 3)
	        return null;
	    var last = list[list.length - 1];
	    if (last.type !== 'characterData')
	        return null;
	    if (list.length < 3)
	        return list[0].type === 'characterData' ? list[0] : last;
	    var textAdd = list[0], brRemove = list[1];
	    if (textAdd.addedNodes[0] !== last.target)
	        return null;
	    if (!brRemove.removedNodes.length || brRemove.removedNodes[0].nodeName !== 'BR')
	        return null;
	    return last;
	}

	var SOURCE_USER$3 = 'user';
	var keymap = {
	    'Mod+B': function (editor) { return editor.toggleTextFormat(editor.selection, { bold: true }, SOURCE_USER$3); },
	    'Mod+I': function (editor) { return editor.toggleTextFormat(editor.selection, { italic: true }, SOURCE_USER$3); },
	    'Mod+1': function (editor) { return editor.toggleLineFormat(editor.selection, { header: 1 }, SOURCE_USER$3); },
	    'Mod+2': function (editor) { return editor.toggleLineFormat(editor.selection, { header: 2 }, SOURCE_USER$3); },
	    'Mod+3': function (editor) { return editor.toggleLineFormat(editor.selection, { header: 3 }, SOURCE_USER$3); },
	    'Mod+4': function (editor) { return editor.toggleLineFormat(editor.selection, { header: 4 }, SOURCE_USER$3); },
	    'Mod+5': function (editor) { return editor.toggleLineFormat(editor.selection, { header: 5 }, SOURCE_USER$3); },
	    'Mod+6': function (editor) { return editor.toggleLineFormat(editor.selection, { header: 6 }, SOURCE_USER$3); },
	    'Mod+0': function (editor) { return editor.formatLine(editor.selection, {}, SOURCE_USER$3); }
	};
	// Basic text input module. Prevent any actions other than typing characters and handle with the API.
	function keyShortcuts(customShortcuts) {
	    if (customShortcuts === void 0) { customShortcuts = {}; }
	    return function (editor, root) {
	        var shortcuts = __assign$1$1({}, keymap, customShortcuts);
	        function onShortcut(event) {
	            if (event.defaultPrevented)
	                return;
	            var shortcut = event.detail;
	            if (shortcut in shortcuts) {
	                event.preventDefault();
	                shortcuts[shortcut](editor);
	            }
	        }
	        root.addEventListener('shortcut', onShortcut);
	        return {
	            onDestroy: function () {
	                root.addEventListener('shortcut', onShortcut);
	            }
	        };
	    };
	}

	var SOURCE_USER$4 = 'user';
	var defaultOptions$1 = {
	    delay: 0,
	    maxStack: 500
	};
	/**
	 * History is a view module for storing user changes and undoing/redoing those changes.
	 *
	 * Stores history for all user-generated changes. Like-changes will be combined until a selection or a delay timeout
	 * cuts off the combining. E.g. if a user types "Hello" the 5 changes will be combined into one history entry. If
	 * the user moves the cursor somewhere and then back to the end and types " World" the next 6 changes are combined
	 * separately from the first 5 because selection changes add a cutoff history entries.
	 *
	 * The default options can be overridden by passing alternatives to history. To add a timeout to force a cutoff after
	 * so many milliseconds set a delay like this:
	 * ```js
	 * const modules = {
	 *   history: history({ delay: 4000 })
	 * };
	 * ```
	 */
	function history(options) {
	    if (options === void 0) { options = {}; }
	    return function (editor, root) {
	        options = __assign$1$1({}, defaultOptions$1, options);
	        var stack = options.stack || {
	            undo: [],
	            redo: []
	        };
	        var lastRecorded = 0;
	        var lastAction = '';
	        var ignoreChange = false;
	        function undo(event) {
	            action(event, 'undo', 'redo');
	        }
	        function redo(event) {
	            action(event, 'redo', 'undo');
	        }
	        function cutoff() {
	            lastRecorded = 0;
	        }
	        function clear() {
	            stack.undo.length = 0;
	            stack.redo.length = 0;
	        }
	        function action(event, source, dest) {
	            if (event.defaultPrevented)
	                return;
	            event.preventDefault();
	            if (stack[source].length === 0)
	                return;
	            var entry = stack[source].pop();
	            stack[dest].push(entry);
	            cutoff();
	            ignoreChange = true;
	            if (typeof entry[source] === 'function') {
	                entry[source]();
	            }
	            else {
	                editor.updateContents(entry[source], SOURCE_USER$4, entry[source + 'Selection']);
	            }
	            ignoreChange = false;
	        }
	        function record(change, contents, oldContents, selection, oldSelection) {
	            var timestamp = Date.now();
	            var action = getAction(change);
	            stack.redo.length = 0;
	            var undoChange = contents.diff(oldContents);
	            // Break combining if actions are different (e.g. a delete then an insert should break it)
	            if (!action || lastAction !== action)
	                cutoff();
	            lastAction = action;
	            if (lastRecorded && (!options.delay || lastRecorded + options.delay > timestamp) && stack.undo.length > 0) {
	                // Combine with the last change
	                var entry = stack.undo.pop();
	                oldSelection = entry.undoSelection;
	                undoChange = undoChange.compose(entry.undo);
	                change = entry.redo.compose(change);
	            }
	            else {
	                lastRecorded = timestamp;
	            }
	            stack.undo.push({
	                redo: change,
	                undo: undoChange,
	                redoSelection: selection,
	                undoSelection: oldSelection
	            });
	            if (stack.undo.length > options.maxStack) {
	                stack.undo.shift();
	            }
	        }
	        function transform(change) {
	            stack.undo.forEach(function (entry) {
	                entry.undo = change.transform(entry.undo, true);
	                entry.redo = change.transform(entry.redo, true);
	            });
	            stack.redo.forEach(function (entry) {
	                entry.undo = change.transform(entry.undo, true);
	                entry.redo = change.transform(entry.redo, true);
	            });
	        }
	        function onTextChange(_a) {
	            var change = _a.change, contents = _a.contents, oldContents = _a.oldContents, selection = _a.selection, oldSelection = _a.oldSelection, source = _a.source;
	            if (ignoreChange)
	                return;
	            if (source === SOURCE_USER$4) {
	                record(change, contents, oldContents, selection, oldSelection);
	            }
	            else {
	                transform(change);
	            }
	        }
	        function onSelectionChange(_a) {
	            var change = _a.change;
	            if (change)
	                return;
	            // Break the history merging when selection changes without a text change
	            cutoff();
	        }
	        editor.on('text-change', onTextChange);
	        editor.on('selection-change', onSelectionChange);
	        root.addEventListener('shortcut:Mod+Z', undo);
	        root.addEventListener('shortcut:win:Ctrl+Y', redo);
	        root.addEventListener('shortcut:mac:Cmd+Shift+Z', redo);
	        return {
	            undo: undo,
	            redo: redo,
	            cutoff: cutoff,
	            options: options,
	            clear: clear,
	            onDestroy: function () {
	                editor.off('text-change', onTextChange);
	                editor.off('selection-change', onSelectionChange);
	                root.removeEventListener('shortcut:Mod+Z', undo);
	                root.removeEventListener('shortcut:win:Ctrl+Y', redo);
	                root.removeEventListener('shortcut:mac:Cmd+Shift+Z', redo);
	            }
	        };
	    };
	}
	function getAction(change) {
	    if (change.ops.length === 1 || change.ops.length === 2 && change.ops[0].retain && !change.ops[0].attributes) {
	        var changeOp = change.ops[change.ops.length - 1];
	        if (changeOp["delete"])
	            return 'delete';
	        if (changeOp.insert === '\n')
	            return 'newline';
	        if (changeOp.insert)
	            return 'insert';
	    }
	    return '';
	}

	/**
	 * Set placeholder text in the editable area when there is no content. Add css:
	 *
	 * ```css
	 * .placeholder::before {
	 *   content: attr(data-placeholder);
	 *   opacity: 0.5;
	 * }
	 * ```
	 */
	function placeholder(placeholder) {
	    return function (editor, root) {
	        function onDecorate(event) {
	            var decorators = event.detail;
	            if (editor.length === 1) {
	                var text = (typeof placeholder === 'function' ? placeholder() : placeholder) || '';
	                decorators.embed(0, { "class": 'placeholder', 'data-placeholder': text });
	            }
	        }
	        root.addEventListener('decorate', onDecorate);
	        return {
	            onDestroy: function () {
	                root.removeEventListener('decorate', onDecorate);
	            }
	        };
	    };
	}

	var SOURCE_USER$5 = 'user';
	/**
	 * A list of [ RegExp, Function ] tuples to convert text into a formatted block with the attributes returned by the
	 * function. The function's argument will be the captured text from the regular expression.
	 */
	var blockReplacements = [
	    [/^(#{1,6}) $/, function (capture) { return ({ header: capture.length }); }],
	    [/^[-*] $/, function () { return ({ list: 'bullet' }); }],
	    [/^1\. $/, function () { return ({ list: 'ordered' }); }],
	    [/^([AaIi])\. $/, function (type) { return ({ list: 'ordered', type: type }); }],
	    [/^(-?\d+)\. $/, function (start) { return ({ list: 'ordered', start: start }); }],
	    [/^([A-Z])\. $/, function (char) { return ({ list: 'ordered', type: 'A', start: char.charCodeAt(0) - 'A'.charCodeAt(0) + 1 }); }],
	    [/^([a-z])\. $/, function (char) { return ({ list: 'ordered', type: 'a', start: char.charCodeAt(0) - 'a'.charCodeAt(0) + 1 }); }],
	    [/^([IVXLCDM]+)\. $/i, function (chars) { return ({ list: 'ordered', type: chars[0].toUpperCase() === chars[0] ? 'I' : 'i', start: fromRomanNumeral(chars) }); }],
	    [/^> $/, function () { return ({ blockquote: true }); }],
	];
	/**
	 * A list of [ RegExp, Function ] tuples to convert text into another string of text which is returned by the function.
	 * The function's argument will be the captured text from the regular expression.
	 */
	var textReplacements = [
	    [/--$/, function () { return '—'; }],
	    [/\.\.\.$/, function () { return '…'; }],
	];
	/**
	 * Allow text representations to format a block
	 */
	function blockReplace(editor, index, prefix) {
	    return blockReplacements.some(function (_a) {
	        var regexp = _a[0], getAttributes = _a[1];
	        var match = prefix.match(regexp);
	        if (match) {
	            var attributes_1 = getAttributes(match[1]);
	            var change = editor.getChange(function () {
	                editor.formatLine(index, attributes_1);
	                editor.deleteText(index - prefix.length, index);
	            });
	            editor.updateContents(change, SOURCE_USER$5, index - prefix.length);
	            return true;
	        }
	    });
	}
	function textReplace(editor, index, prefix) {
	    return textReplacements.some(function (_a) {
	        var regexp = _a[0], replaceWith = _a[1];
	        var match = prefix.match(regexp);
	        if (match) {
	            editor.insertText(index - match[0].length, index, replaceWith(match[1]), null, SOURCE_USER$5);
	            return true;
	        }
	    });
	}
	var defaultHandlers = [blockReplace, textReplace];
	function smartEntry (handlers) {
	    if (handlers === void 0) { handlers = defaultHandlers; }
	    return function (editor) {
	        var ignore = false;
	        function onTextChange(_a) {
	            var change = _a.change, source = _a.source;
	            if (ignore || source !== 'user' || !editor.selection || !isTextEntry(change))
	                return;
	            var index = editor.selection[1];
	            var text = editor.getExactText();
	            var lineStart = text.lastIndexOf('\n', index - 1) + 1;
	            var prefix = text.slice(lineStart, index);
	            ignore = true;
	            handlers.some(function (handler) { return handler(editor, index, prefix); });
	            ignore = false;
	        }
	        editor.on('text-change', onTextChange);
	        return {
	            onDestroy: function () {
	                editor.off('text-change', onTextChange);
	            }
	        };
	    };
	}
	function isTextEntry(change) {
	    return (change.ops.length === 1 ||
	        (change.ops.length === 2 && change.ops[0].retain && !change.ops[0].attributes)) &&
	        change.ops[change.ops.length - 1].insert &&
	        change.ops[change.ops.length - 1].insert !== '\n';
	}
	var DIGIT_VALUES = {
	    I: 1,
	    V: 5,
	    X: 10,
	    L: 50,
	    C: 100,
	    D: 500,
	    M: 1000
	};
	function fromRomanNumeral(romanNumeral) {
	    romanNumeral = romanNumeral.toUpperCase();
	    var result = 0;
	    for (var i = 0; i < romanNumeral.length; i++) {
	        var currentLetter = DIGIT_VALUES[romanNumeral[i]];
	        var nextLetter = DIGIT_VALUES[romanNumeral[i + 1]];
	        if (currentLetter === undefined)
	            return undefined;
	        if (currentLetter < nextLetter) {
	            result += nextLetter - currentLetter;
	            i++;
	        }
	        else {
	            result += currentLetter;
	        }
	    }
	    return result;
	}

	/**
	 * Replaces regular quotes with smart quotes as they are typed. Does not affect pasted content.
	 * Uses the text-changing event to prevent the original change and replace it with the new one. This makes the smart-
	 * quotes act more seemlessly and includes them as part of regular text undo/redo instead of breaking it like the smart-
	 * entry conversions do.
	 */
	function smartQuotes() {
	    return function (editor) {
	        function onTextChange(_a) {
	            var change = _a.change, source = _a.source, selection = _a.selection;
	            if (source !== 'user' || !editor.selection || !isTextEntry$1(change))
	                return;
	            var index = editor.selection[1];
	            var lastOp = change.ops[change.ops.length - 1];
	            var lastChars = editor.getText(index - 1, index) + lastOp.insert.slice(-1);
	            var replaced = lastChars.replace(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, '“')
	                .replace(/"$/, '”')
	                .replace(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, '‘')
	                .replace(/'$/, '’');
	            if (replaced !== lastChars) {
	                var quote = replaced.slice(-1);
	                lastOp.insert = lastOp.insert.slice(0, -1) + quote;
	                editor.updateContents(change, source, selection);
	                return false;
	            }
	        }
	        editor.on('text-changing', onTextChange);
	        return {
	            onDestroy: function () {
	                editor.off('text-changing', onTextChange);
	            }
	        };
	    };
	}
	function isTextEntry$1(change) {
	    return (change.ops.length === 1 ||
	        (change.ops.length === 2 && change.ops[0].retain && !change.ops[0].attributes)) &&
	        typeof change.ops[change.ops.length - 1].insert === 'string' &&
	        change.ops[change.ops.length - 1].insert !== '\n';
	}

	function unwrapExports$1 (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
	}

	function createCommonjsModule$1(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var internal$1 = createCommonjsModule$1(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });

	function noop() {}

	const identity = x => x;

	function assign(tar, src) {
		for (const k in src) tar[k] = src[k];
		return tar;
	}

	function is_promise(value) {
		return value && typeof value.then === 'function';
	}

	function add_location(element, file, line, column, char) {
		element.__svelte_meta = {
			loc: { file, line, column, char }
		};
	}

	function run(fn) {
		return fn();
	}

	function blank_object() {
		return Object.create(null);
	}

	function run_all(fns) {
		fns.forEach(run);
	}

	function is_function(thing) {
		return typeof thing === 'function';
	}

	function safe_not_equal(a, b) {
		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function not_equal(a, b) {
		return a != a ? b == b : a !== b;
	}

	function validate_store(store, name) {
		if (!store || typeof store.subscribe !== 'function') {
			throw new Error(`'${name}' is not a store with a 'subscribe' method`);
		}
	}

	function subscribe(component, store, callback) {
		component.$$.on_destroy.push(store.subscribe(callback));
	}

	function create_slot(definition, ctx, fn) {
		if (definition) {
			const slot_ctx = get_slot_context(definition, ctx, fn);
			return definition[0](slot_ctx);
		}
	}

	function get_slot_context(definition, ctx, fn) {
		return definition[1]
			? assign({}, assign(ctx.$$scope.ctx, definition[1](fn ? fn(ctx) : {})))
			: ctx.$$scope.ctx;
	}

	function get_slot_changes(definition, ctx, changed, fn) {
		return definition[1]
			? assign({}, assign(ctx.$$scope.changed || {}, definition[1](fn ? fn(changed) : {})))
			: ctx.$$scope.changed || {};
	}

	function exclude_internal_props(props) {
		const result = {};
		for (const k in props) if (k[0] !== '$') result[k] = props[k];
		return result;
	}

	const tasks = new Set();
	let running = false;

	function run_tasks() {
		tasks.forEach(task => {
			if (!task[0](window.performance.now())) {
				tasks.delete(task);
				task[1]();
			}
		});

		running = tasks.size > 0;
		if (running) requestAnimationFrame(run_tasks);
	}

	function clear_loops() {
		// for testing...
		tasks.forEach(task => tasks.delete(task));
		running = false;
	}

	function loop(fn) {
		let task;

		if (!running) {
			running = true;
			requestAnimationFrame(run_tasks);
		}

		return {
			promise: new Promise(fulfil => {
				tasks.add(task = [fn, fulfil]);
			}),
			abort() {
				tasks.delete(task);
			}
		};
	}

	function append(target, node) {
		target.appendChild(node);
	}

	function insert(target, node, anchor) {
		target.insertBefore(node, anchor);
	}

	function detach(node) {
		node.parentNode.removeChild(node);
	}

	function detach_between(before, after) {
		while (before.nextSibling && before.nextSibling !== after) {
			before.parentNode.removeChild(before.nextSibling);
		}
	}

	function detach_before(after) {
		while (after.previousSibling) {
			after.parentNode.removeChild(after.previousSibling);
		}
	}

	function detach_after(before) {
		while (before.nextSibling) {
			before.parentNode.removeChild(before.nextSibling);
		}
	}

	function destroy_each(iterations, detaching) {
		for (let i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d(detaching);
		}
	}

	function element(name) {
		return document.createElement(name);
	}

	function svg_element(name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	}

	function text(data) {
		return document.createTextNode(data);
	}

	function space() {
		return text(' ');
	}

	function empty() {
		return text('');
	}

	function listen(node, event, handler, options) {
		node.addEventListener(event, handler, options);
		return () => node.removeEventListener(event, handler, options);
	}

	function prevent_default(fn) {
		return function(event) {
			event.preventDefault();
			return fn.call(this, event);
		};
	}

	function stop_propagation(fn) {
		return function(event) {
			event.stopPropagation();
			return fn.call(this, event);
		};
	}

	function attr(node, attribute, value) {
		if (value == null) node.removeAttribute(attribute);
		else node.setAttribute(attribute, value);
	}

	function set_attributes(node, attributes) {
		for (const key in attributes) {
			if (key === 'style') {
				node.style.cssText = attributes[key];
			} else if (key in node) {
				node[key] = attributes[key];
			} else {
				attr(node, key, attributes[key]);
			}
		}
	}

	function set_custom_element_data(node, prop, value) {
		if (prop in node) {
			node[prop] = value;
		} else {
			attr(node, prop, value);
		}
	}

	function xlink_attr(node, attribute, value) {
		node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
	}

	function get_binding_group_value(group) {
		const value = [];
		for (let i = 0; i < group.length; i += 1) {
			if (group[i].checked) value.push(group[i].__value);
		}
		return value;
	}

	function to_number(value) {
		return value === '' ? undefined : +value;
	}

	function time_ranges_to_array(ranges) {
		const array = [];
		for (let i = 0; i < ranges.length; i += 1) {
			array.push({ start: ranges.start(i), end: ranges.end(i) });
		}
		return array;
	}

	function children(element) {
		return Array.from(element.childNodes);
	}

	function claim_element(nodes, name, attributes, svg) {
		for (let i = 0; i < nodes.length; i += 1) {
			const node = nodes[i];
			if (node.nodeName === name) {
				for (let j = 0; j < node.attributes.length; j += 1) {
					const attribute = node.attributes[j];
					if (!attributes[attribute.name]) node.removeAttribute(attribute.name);
				}
				return nodes.splice(i, 1)[0]; // TODO strip unwanted attributes
			}
		}

		return svg ? svg_element(name) : element(name);
	}

	function claim_text(nodes, data) {
		for (let i = 0; i < nodes.length; i += 1) {
			const node = nodes[i];
			if (node.nodeType === 3) {
				node.data = data;
				return nodes.splice(i, 1)[0];
			}
		}

		return text(data);
	}

	function set_data(text, data) {
		text.data = '' + data;
	}

	function set_input_type(input, type) {
		try {
			input.type = type;
		} catch (e) {
			// do nothing
		}
	}

	function set_style(node, key, value) {
		node.style.setProperty(key, value);
	}

	function select_option(select, value) {
		for (let i = 0; i < select.options.length; i += 1) {
			const option = select.options[i];

			if (option.__value === value) {
				option.selected = true;
				return;
			}
		}
	}

	function select_options(select, value) {
		for (let i = 0; i < select.options.length; i += 1) {
			const option = select.options[i];
			option.selected = ~value.indexOf(option.__value);
		}
	}

	function select_value(select) {
		const selected_option = select.querySelector(':checked') || select.options[0];
		return selected_option && selected_option.__value;
	}

	function select_multiple_value(select) {
		return [].map.call(select.querySelectorAll(':checked'), option => option.__value);
	}

	function add_resize_listener(element, fn) {
		if (getComputedStyle(element).position === 'static') {
			element.style.position = 'relative';
		}

		const object = document.createElement('object');
		object.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;');
		object.type = 'text/html';

		let win;

		object.onload = () => {
			win = object.contentDocument.defaultView;
			win.addEventListener('resize', fn);
		};

		if (/Trident/.test(navigator.userAgent)) {
			element.appendChild(object);
			object.data = 'about:blank';
		} else {
			object.data = 'about:blank';
			element.appendChild(object);
		}

		return {
			cancel: () => {
				win && win.removeEventListener && win.removeEventListener('resize', fn);
				element.removeChild(object);
			}
		};
	}

	function toggle_class(element, name, toggle) {
		element.classList[toggle ? 'add' : 'remove'](name);
	}

	function custom_event(type, detail) {
		const e = document.createEvent('CustomEvent');
		e.initCustomEvent(type, false, false, detail);
		return e;
	}

	let stylesheet;
	let active = 0;
	let current_rules = {};

	// https://github.com/darkskyapp/string-hash/blob/master/index.js
	function hash(str) {
		let hash = 5381;
		let i = str.length;

		while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
		return hash >>> 0;
	}

	function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
		const step = 16.666 / duration;
		let keyframes = '{\n';

		for (let p = 0; p <= 1; p += step) {
			const t = a + (b - a) * ease(p);
			keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
		}

		const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
		const name = `__svelte_${hash(rule)}_${uid}`;

		if (!current_rules[name]) {
			if (!stylesheet) {
				const style = element('style');
				document.head.appendChild(style);
				stylesheet = style.sheet;
			}

			current_rules[name] = true;
			stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
		}

		const animation = node.style.animation || '';
		node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;

		active += 1;
		return name;
	}

	function delete_rule(node, name) {
		node.style.animation = (node.style.animation || '')
			.split(', ')
			.filter(name
				? anim => anim.indexOf(name) < 0 // remove specific animation
				: anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
			)
			.join(', ');

		if (name && !--active) clear_rules();
	}

	function clear_rules() {
		requestAnimationFrame(() => {
			if (active) return;
			let i = stylesheet.cssRules.length;
			while (i--) stylesheet.deleteRule(i);
			current_rules = {};
		});
	}

	function create_animation(node, from, fn, params) {
		if (!from) return noop;

		const to = node.getBoundingClientRect();
		if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom) return noop;

		const {
			delay = 0,
			duration = 300,
			easing = identity,
			start: start_time = window.performance.now() + delay,
			end = start_time + duration,
			tick = noop,
			css
		} = fn(node, { from, to }, params);

		let running = true;
		let started = false;
		let name;

		const css_text = node.style.cssText;

		function start() {
			if (css) {
				if (delay) node.style.cssText = css_text; // TODO create delayed animation instead?
				name = create_rule(node, 0, 1, duration, 0, easing, css);
			}

			started = true;
		}

		function stop() {
			if (css) delete_rule(node, name);
			running = false;
		}

		loop(now => {
			if (!started && now >= start_time) {
				start();
			}

			if (started && now >= end) {
				tick(1, 0);
				stop();
			}

			if (!running) {
				return false;
			}

			if (started) {
				const p = now - start_time;
				const t = 0 + 1 * easing(p / duration);
				tick(t, 1 - t);
			}

			return true;
		});

		if (delay) {
			if (css) node.style.cssText += css(0, 1);
		} else {
			start();
		}

		tick(0, 1);

		return stop;
	}

	function fix_position(node) {
		const style = getComputedStyle(node);

		if (style.position !== 'absolute' && style.position !== 'fixed') {
			const { width, height } = style;
			const a = node.getBoundingClientRect();
			node.style.position = 'absolute';
			node.style.width = width;
			node.style.height = height;
			const b = node.getBoundingClientRect();

			if (a.left !== b.left || a.top !== b.top) {
				const style = getComputedStyle(node);
				const transform = style.transform === 'none' ? '' : style.transform;

				node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
			}
		}
	}

	function set_current_component(component) {
		exports.current_component = component;
	}

	function get_current_component() {
		if (!exports.current_component) throw new Error(`Function called outside component initialization`);
		return exports.current_component;
	}

	function beforeUpdate(fn) {
		get_current_component().$$.before_render.push(fn);
	}

	function onMount(fn) {
		get_current_component().$$.on_mount.push(fn);
	}

	function afterUpdate(fn) {
		get_current_component().$$.after_render.push(fn);
	}

	function onDestroy(fn) {
		get_current_component().$$.on_destroy.push(fn);
	}

	function createEventDispatcher() {
		const component = exports.current_component;

		return (type, detail) => {
			const callbacks = component.$$.callbacks[type];

			if (callbacks) {
				// TODO are there situations where events could be dispatched
				// in a server (non-DOM) environment?
				const event = custom_event(type, detail);
				callbacks.slice().forEach(fn => {
					fn.call(component, event);
				});
			}
		};
	}

	function setContext(key, context) {
		get_current_component().$$.context.set(key, context);
	}

	function getContext(key) {
		return get_current_component().$$.context.get(key);
	}

	// TODO figure out if we still want to support
	// shorthand events, or if we want to implement
	// a real bubbling mechanism
	function bubble(component, event) {
		const callbacks = component.$$.callbacks[event.type];

		if (callbacks) {
			callbacks.slice().forEach(fn => fn(event));
		}
	}

	const dirty_components = [];
	const intros = { enabled: false };

	let update_promise;
	const binding_callbacks = [];
	const render_callbacks = [];

	function schedule_update() {
		if (!update_promise) {
			update_promise = Promise.resolve();
			update_promise.then(flush);
		}
	}

	function add_render_callback(fn) {
		render_callbacks.push(fn);
	}

	function tick() {
		schedule_update();
		return update_promise;
	}

	function add_binding_callback(fn) {
		binding_callbacks.push(fn);
	}

	function flush() {
		const seen_callbacks = new Set();

		do {
			// first, call beforeUpdate functions
			// and update components
			while (dirty_components.length) {
				const component = dirty_components.shift();
				set_current_component(component);
				update(component.$$);
			}

			while (binding_callbacks.length) binding_callbacks.shift()();

			// then, once components are updated, call
			// afterUpdate functions. This may cause
			// subsequent updates...
			while (render_callbacks.length) {
				const callback = render_callbacks.pop();
				if (!seen_callbacks.has(callback)) {
					callback();

					// ...so guard against infinite loops
					seen_callbacks.add(callback);
				}
			}
		} while (dirty_components.length);

		update_promise = null;
	}

	function update($$) {
		if ($$.fragment) {
			$$.update($$.dirty);
			run_all($$.before_render);
			$$.fragment.p($$.dirty, $$.ctx);
			$$.dirty = null;

			$$.after_render.forEach(add_render_callback);
		}
	}

	let promise;

	function wait() {
		if (!promise) {
			promise = Promise.resolve();
			promise.then(() => {
				promise = null;
			});
		}

		return promise;
	}

	function dispatch(node, direction, kind) {
		node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
	}

	let outros;

	function group_outros() {
		outros = {
			remaining: 0,
			callbacks: []
		};
	}

	function check_outros() {
		if (!outros.remaining) {
			run_all(outros.callbacks);
		}
	}

	function on_outro(callback) {
		outros.callbacks.push(callback);
	}

	function create_in_transition(node, fn, params) {
		let config = fn(node, params);
		let running = false;
		let animation_name;
		let task;
		let uid = 0;

		function cleanup() {
			if (animation_name) delete_rule(node, animation_name);
		}

		function go() {
			const {
				delay = 0,
				duration = 300,
				easing = identity,
				tick: tick$$1 = noop,
				css
			} = config;

			if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
			tick$$1(0, 1);

			const start_time = window.performance.now() + delay;
			const end_time = start_time + duration;

			if (task) task.abort();
			running = true;

			task = loop(now => {
				if (running) {
					if (now >= end_time) {
						tick$$1(1, 0);
						cleanup();
						return running = false;
					}

					if (now >= start_time) {
						const t = easing((now - start_time) / duration);
						tick$$1(t, 1 - t);
					}
				}

				return running;
			});
		}

		let started = false;

		return {
			start() {
				if (started) return;

				delete_rule(node);

				if (typeof config === 'function') {
					config = config();
					wait().then(go);
				} else {
					go();
				}
			},

			invalidate() {
				started = false;
			},

			end() {
				if (running) {
					cleanup();
					running = false;
				}
			}
		};
	}

	function create_out_transition(node, fn, params) {
		let config = fn(node, params);
		let running = true;
		let animation_name;

		const group = outros;

		group.remaining += 1;

		function go() {
			const {
				delay = 0,
				duration = 300,
				easing = identity,
				tick: tick$$1 = noop,
				css
			} = config;

			if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);

			const start_time = window.performance.now() + delay;
			const end_time = start_time + duration;

			loop(now => {
				if (running) {
					if (now >= end_time) {
						tick$$1(0, 1);

						if (!--group.remaining) {
							// this will result in `end()` being called,
							// so we don't need to clean up here
							run_all(group.callbacks);
						}

						return false;
					}

					if (now >= start_time) {
						const t = easing((now - start_time) / duration);
						tick$$1(1 - t, t);
					}
				}

				return running;
			});
		}

		if (typeof config === 'function') {
			wait().then(() => {
				config = config();
				go();
			});
		} else {
			go();
		}

		return {
			end(reset) {
				if (reset && config.tick) {
					config.tick(1, 0);
				}

				if (running) {
					if (animation_name) delete_rule(node, animation_name);
					running = false;
				}
			}
		};
	}

	function create_bidirectional_transition(node, fn, params, intro) {
		let config = fn(node, params);

		let t = intro ? 0 : 1;

		let running_program = null;
		let pending_program = null;
		let animation_name = null;

		function clear_animation() {
			if (animation_name) delete_rule(node, animation_name);
		}

		function init(program, duration) {
			const d = program.b - t;
			duration *= Math.abs(d);

			return {
				a: t,
				b: program.b,
				d,
				duration,
				start: program.start,
				end: program.start + duration,
				group: program.group
			};
		}

		function go(b) {
			const {
				delay = 0,
				duration = 300,
				easing = identity,
				tick: tick$$1 = noop,
				css
			} = config;

			const program = {
				start: window.performance.now() + delay,
				b
			};

			if (!b) {
				program.group = outros;
				outros.remaining += 1;
			}

			if (running_program) {
				pending_program = program;
			} else {
				// if this is an intro, and there's a delay, we need to do
				// an initial tick and/or apply CSS animation immediately
				if (css) {
					clear_animation();
					animation_name = create_rule(node, t, b, duration, delay, easing, css);
				}

				if (b) tick$$1(0, 1);

				running_program = init(program, duration);
				add_render_callback(() => dispatch(node, b, 'start'));

				loop(now => {
					if (pending_program && now > pending_program.start) {
						running_program = init(pending_program, duration);
						pending_program = null;

						dispatch(node, running_program.b, 'start');

						if (css) {
							clear_animation();
							animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
						}
					}

					if (running_program) {
						if (now >= running_program.end) {
							tick$$1(t = running_program.b, 1 - t);
							dispatch(node, running_program.b, 'end');

							if (!pending_program) {
								// we're done
								if (running_program.b) {
									// intro — we can tidy up immediately
									clear_animation();
								} else {
									// outro — needs to be coordinated
									if (!--running_program.group.remaining) run_all(running_program.group.callbacks);
								}
							}

							running_program = null;
						}

						else if (now >= running_program.start) {
							const p = now - running_program.start;
							t = running_program.a + running_program.d * easing(p / running_program.duration);
							tick$$1(t, 1 - t);
						}
					}

					return !!(running_program || pending_program);
				});
			}
		}

		return {
			run(b) {
				if (typeof config === 'function') {
					wait().then(() => {
						config = config();
						go(b);
					});
				} else {
					go(b);
				}
			},

			end() {
				clear_animation();
				running_program = pending_program = null;
			}
		};
	}

	function handle_promise(promise, info) {
		const token = info.token = {};

		function update(type, index, key, value) {
			if (info.token !== token) return;

			info.resolved = key && { [key]: value };

			const child_ctx = assign(assign({}, info.ctx), info.resolved);
			const block = type && (info.current = type)(child_ctx);

			if (info.block) {
				if (info.blocks) {
					info.blocks.forEach((block, i) => {
						if (i !== index && block) {
							group_outros();
							on_outro(() => {
								block.d(1);
								info.blocks[i] = null;
							});
							block.o(1);
							check_outros();
						}
					});
				} else {
					info.block.d(1);
				}

				block.c();
				if (block.i) block.i(1);
				block.m(info.mount(), info.anchor);

				flush();
			}

			info.block = block;
			if (info.blocks) info.blocks[index] = block;
		}

		if (is_promise(promise)) {
			promise.then(value => {
				update(info.then, 1, info.value, value);
			}, error => {
				update(info.catch, 2, info.error, error);
			});

			// if we previously had a then/catch block, destroy it
			if (info.current !== info.pending) {
				update(info.pending, 0);
				return true;
			}
		} else {
			if (info.current !== info.then) {
				update(info.then, 1, info.value, promise);
				return true;
			}

			info.resolved = { [info.value]: promise };
		}
	}

	function destroy_block(block, lookup) {
		block.d(1);
		lookup[block.key] = null;
	}

	function outro_and_destroy_block(block, lookup) {
		on_outro(() => {
			destroy_block(block, lookup);
		});

		block.o(1);
	}

	function fix_and_outro_and_destroy_block(block, lookup) {
		block.f();
		outro_and_destroy_block(block, lookup);
	}

	function update_keyed_each(old_blocks, changed, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
		let o = old_blocks.length;
		let n = list.length;

		let i = o;
		const old_indexes = {};
		while (i--) old_indexes[old_blocks[i].key] = i;

		const new_blocks = [];
		const new_lookup = {};
		const deltas = {};

		i = n;
		while (i--) {
			const child_ctx = get_context(ctx, list, i);
			const key = get_key(child_ctx);
			let block = lookup[key];

			if (!block) {
				block = create_each_block(key, child_ctx);
				block.c();
			} else if (dynamic) {
				block.p(changed, child_ctx);
			}

			new_blocks[i] = new_lookup[key] = block;

			if (key in old_indexes) deltas[key] = Math.abs(i - old_indexes[key]);
		}

		const will_move = {};
		const did_move = {};

		function insert(block) {
			if (block.i) block.i(1);
			block.m(node, next);
			lookup[block.key] = block;
			next = block.first;
			n--;
		}

		while (o && n) {
			const new_block = new_blocks[n - 1];
			const old_block = old_blocks[o - 1];
			const new_key = new_block.key;
			const old_key = old_block.key;

			if (new_block === old_block) {
				// do nothing
				next = new_block.first;
				o--;
				n--;
			}

			else if (!new_lookup[old_key]) {
				// remove old block
				destroy(old_block, lookup);
				o--;
			}

			else if (!lookup[new_key] || will_move[new_key]) {
				insert(new_block);
			}

			else if (did_move[old_key]) {
				o--;

			} else if (deltas[new_key] > deltas[old_key]) {
				did_move[new_key] = true;
				insert(new_block);

			} else {
				will_move[old_key] = true;
				o--;
			}
		}

		while (o--) {
			const old_block = old_blocks[o];
			if (!new_lookup[old_block.key]) destroy(old_block, lookup);
		}

		while (n) insert(new_blocks[n - 1]);

		return new_blocks;
	}

	function measure(blocks) {
		const rects = {};
		let i = blocks.length;
		while (i--) rects[blocks[i].key] = blocks[i].node.getBoundingClientRect();
		return rects;
	}

	function get_spread_update(levels, updates) {
		const update = {};

		const to_null_out = {};
		const accounted_for = {};

		let i = levels.length;
		while (i--) {
			const o = levels[i];
			const n = updates[i];

			if (n) {
				for (const key in o) {
					if (!(key in n)) to_null_out[key] = 1;
				}

				for (const key in n) {
					if (!accounted_for[key]) {
						update[key] = n[key];
						accounted_for[key] = 1;
					}
				}

				levels[i] = n;
			} else {
				for (const key in o) {
					accounted_for[key] = 1;
				}
			}
		}

		for (const key in to_null_out) {
			if (!(key in update)) update[key] = undefined;
		}

		return update;
	}

	const invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
	// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
	// https://infra.spec.whatwg.org/#noncharacter

	function spread(args) {
		const attributes = Object.assign({}, ...args);
		let str = '';

		Object.keys(attributes).forEach(name => {
			if (invalid_attribute_name_character.test(name)) return;

			const value = attributes[name];
			if (value === undefined) return;
			if (value === true) str += " " + name;

			const escaped = String(value)
				.replace(/"/g, '&#34;')
				.replace(/'/g, '&#39;');

			str += " " + name + "=" + JSON.stringify(escaped);
		});

		return str;
	}

	const escaped = {
		'"': '&quot;',
		"'": '&#39;',
		'&': '&amp;',
		'<': '&lt;',
		'>': '&gt;'
	};

	function escape(html) {
		return String(html).replace(/["'&<>]/g, match => escaped[match]);
	}

	function each(items, fn) {
		let str = '';
		for (let i = 0; i < items.length; i += 1) {
			str += fn(items[i], i);
		}
		return str;
	}

	const missing_component = {
		$$render: () => ''
	};

	function validate_component(component, name) {
		if (!component || !component.$$render) {
			if (name === 'svelte:component') name += ' this={...}';
			throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
		}

		return component;
	}

	function debug(file, line, column, values) {
		console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console
		console.log(values); // eslint-disable-line no-console
		return '';
	}

	let on_destroy;

	function create_ssr_component(fn) {
		function $$render(result, props, bindings, slots) {
			const parent_component = exports.current_component;

			const $$ = {
				on_destroy,
				context: new Map(parent_component ? parent_component.$$.context : []),

				// these will be immediately discarded
				on_mount: [],
				before_render: [],
				after_render: [],
				callbacks: blank_object()
			};

			set_current_component({ $$ });

			const html = fn(result, props, bindings, slots);

			set_current_component(parent_component);
			return html;
		}

		return {
			render: (props = {}, options = {}) => {
				on_destroy = [];

				const result = { head: '', css: new Set() };
				const html = $$render(result, props, {}, options);

				run_all(on_destroy);

				return {
					html,
					css: {
						code: Array.from(result.css).map(css => css.code).join('\n'),
						map: null // TODO
					},
					head: result.head
				};
			},

			$$render
		};
	}

	function get_store_value(store) {
		let value;
		store.subscribe(_ => value = _)();
		return value;
	}

	function bind(component, name, callback) {
		if (component.$$.props.indexOf(name) === -1) return;
		component.$$.bound[name] = callback;
		callback(component.$$.ctx[name]);
	}

	function mount_component(component, target, anchor) {
		const { fragment, on_mount, on_destroy, after_render } = component.$$;

		fragment.m(target, anchor);

		// onMount happens after the initial afterUpdate. Because
		// afterUpdate callbacks happen in reverse order (inner first)
		// we schedule onMount callbacks before afterUpdate callbacks
		add_render_callback(() => {
			const new_on_destroy = on_mount.map(run).filter(is_function);
			if (on_destroy) {
				on_destroy.push(...new_on_destroy);
			} else {
				// Edge case - component was destroyed immediately,
				// most likely as a result of a binding initialising
				run_all(new_on_destroy);
			}
			component.$$.on_mount = [];
		});

		after_render.forEach(add_render_callback);
	}

	function destroy(component, detaching) {
		if (component.$$) {
			run_all(component.$$.on_destroy);
			component.$$.fragment.d(detaching);

			// TODO null out other refs, including component.$$ (but need to
			// preserve final state?)
			component.$$.on_destroy = component.$$.fragment = null;
			component.$$.ctx = {};
		}
	}

	function make_dirty(component, key) {
		if (!component.$$.dirty) {
			dirty_components.push(component);
			schedule_update();
			component.$$.dirty = {};
		}
		component.$$.dirty[key] = true;
	}

	function init(component, options, instance, create_fragment, not_equal$$1, prop_names) {
		const parent_component = exports.current_component;
		set_current_component(component);

		const props = options.props || {};

		const $$ = component.$$ = {
			fragment: null,
			ctx: null,

			// state
			props: prop_names,
			update: noop,
			not_equal: not_equal$$1,
			bound: blank_object(),

			// lifecycle
			on_mount: [],
			on_destroy: [],
			before_render: [],
			after_render: [],
			context: new Map(parent_component ? parent_component.$$.context : []),

			// everything else
			callbacks: blank_object(),
			dirty: null
		};

		let ready = false;

		$$.ctx = instance
			? instance(component, props, (key, value) => {
				if ($$.bound[key]) $$.bound[key](value);

				if ($$.ctx) {
					const changed = not_equal$$1(value, $$.ctx[key]);
					if (ready && changed) {
						make_dirty(component, key);
					}

					$$.ctx[key] = value;
					return changed;
				}
			})
			: props;

		$$.update();
		ready = true;
		run_all($$.before_render);
		$$.fragment = create_fragment($$.ctx);

		if (options.target) {
			if (options.hydrate) {
				$$.fragment.l(children(options.target));
			} else {
				$$.fragment.c();
			}

			if (options.intro && component.$$.fragment.i) component.$$.fragment.i();
			mount_component(component, options.target, options.anchor);
			flush();
		}

		set_current_component(parent_component);
	}
	if (typeof HTMLElement !== 'undefined') {
		exports.SvelteElement = class extends HTMLElement {
			constructor() {
				super();
				this.attachShadow({ mode: 'open' });
			}

			connectedCallback() {
				for (const key in this.$$.slotted) {
					this.appendChild(this.$$.slotted[key]);
				}
			}

			attributeChangedCallback(attr$$1, oldValue, newValue) {
				this[attr$$1] = newValue;
			}

			$destroy() {
				destroy(this, true);
				this.$destroy = noop;
			}

			$on(type, callback) {
				// TODO should this delegate to addEventListener?
				const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
				callbacks.push(callback);

				return () => {
					const index = callbacks.indexOf(callback);
					if (index !== -1) callbacks.splice(index, 1);
				};
			}

			$set() {
				// overridden by instance, if it has props
			}
		};
	}

	class SvelteComponent {
		$destroy() {
			destroy(this, true);
			this.$destroy = noop;
		}

		$on(type, callback) {
			const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
			callbacks.push(callback);

			return () => {
				const index = callbacks.indexOf(callback);
				if (index !== -1) callbacks.splice(index, 1);
			};
		}

		$set() {
			// overridden by instance, if it has props
		}
	}

	class SvelteComponentDev extends SvelteComponent {
		constructor(options) {
			if (!options || (!options.target && !options.$$inline)) {
				throw new Error(`'target' is a required option`);
			}

			super();
		}

		$destroy() {
			super.$destroy();
			this.$destroy = () => {
				console.warn(`Component was already destroyed`); // eslint-disable-line no-console
			};
		}
	}

	exports.create_animation = create_animation;
	exports.fix_position = fix_position;
	exports.handle_promise = handle_promise;
	exports.append = append;
	exports.insert = insert;
	exports.detach = detach;
	exports.detach_between = detach_between;
	exports.detach_before = detach_before;
	exports.detach_after = detach_after;
	exports.destroy_each = destroy_each;
	exports.element = element;
	exports.svg_element = svg_element;
	exports.text = text;
	exports.space = space;
	exports.empty = empty;
	exports.listen = listen;
	exports.prevent_default = prevent_default;
	exports.stop_propagation = stop_propagation;
	exports.attr = attr;
	exports.set_attributes = set_attributes;
	exports.set_custom_element_data = set_custom_element_data;
	exports.xlink_attr = xlink_attr;
	exports.get_binding_group_value = get_binding_group_value;
	exports.to_number = to_number;
	exports.time_ranges_to_array = time_ranges_to_array;
	exports.children = children;
	exports.claim_element = claim_element;
	exports.claim_text = claim_text;
	exports.set_data = set_data;
	exports.set_input_type = set_input_type;
	exports.set_style = set_style;
	exports.select_option = select_option;
	exports.select_options = select_options;
	exports.select_value = select_value;
	exports.select_multiple_value = select_multiple_value;
	exports.add_resize_listener = add_resize_listener;
	exports.toggle_class = toggle_class;
	exports.custom_event = custom_event;
	exports.destroy_block = destroy_block;
	exports.outro_and_destroy_block = outro_and_destroy_block;
	exports.fix_and_outro_and_destroy_block = fix_and_outro_and_destroy_block;
	exports.update_keyed_each = update_keyed_each;
	exports.measure = measure;
	exports.set_current_component = set_current_component;
	exports.beforeUpdate = beforeUpdate;
	exports.onMount = onMount;
	exports.afterUpdate = afterUpdate;
	exports.onDestroy = onDestroy;
	exports.createEventDispatcher = createEventDispatcher;
	exports.setContext = setContext;
	exports.getContext = getContext;
	exports.bubble = bubble;
	exports.clear_loops = clear_loops;
	exports.loop = loop;
	exports.dirty_components = dirty_components;
	exports.intros = intros;
	exports.schedule_update = schedule_update;
	exports.add_render_callback = add_render_callback;
	exports.tick = tick;
	exports.add_binding_callback = add_binding_callback;
	exports.flush = flush;
	exports.get_spread_update = get_spread_update;
	exports.invalid_attribute_name_character = invalid_attribute_name_character;
	exports.spread = spread;
	exports.escaped = escaped;
	exports.escape = escape;
	exports.each = each;
	exports.missing_component = missing_component;
	exports.validate_component = validate_component;
	exports.debug = debug;
	exports.create_ssr_component = create_ssr_component;
	exports.get_store_value = get_store_value;
	exports.group_outros = group_outros;
	exports.check_outros = check_outros;
	exports.on_outro = on_outro;
	exports.create_in_transition = create_in_transition;
	exports.create_out_transition = create_out_transition;
	exports.create_bidirectional_transition = create_bidirectional_transition;
	exports.noop = noop;
	exports.identity = identity;
	exports.assign = assign;
	exports.is_promise = is_promise;
	exports.add_location = add_location;
	exports.run = run;
	exports.blank_object = blank_object;
	exports.run_all = run_all;
	exports.is_function = is_function;
	exports.safe_not_equal = safe_not_equal;
	exports.not_equal = not_equal;
	exports.validate_store = validate_store;
	exports.subscribe = subscribe;
	exports.create_slot = create_slot;
	exports.get_slot_context = get_slot_context;
	exports.get_slot_changes = get_slot_changes;
	exports.exclude_internal_props = exclude_internal_props;
	exports.bind = bind;
	exports.mount_component = mount_component;
	exports.init = init;
	exports.SvelteComponent = SvelteComponent;
	exports.SvelteComponentDev = SvelteComponentDev;
	});

	unwrapExports$1(internal$1);
	var internal_1$1 = internal$1.current_component;
	var internal_2$1 = internal$1.SvelteElement;
	var internal_3$1 = internal$1.create_animation;
	var internal_4$1 = internal$1.fix_position;
	var internal_5$1 = internal$1.handle_promise;
	var internal_6$1 = internal$1.append;
	var internal_7$1 = internal$1.insert;
	var internal_8$1 = internal$1.detach;
	var internal_9$1 = internal$1.detach_between;
	var internal_10$1 = internal$1.detach_before;
	var internal_11$1 = internal$1.detach_after;
	var internal_12$1 = internal$1.destroy_each;
	var internal_13$1 = internal$1.element;
	var internal_14$1 = internal$1.svg_element;
	var internal_15$1 = internal$1.text;
	var internal_16$1 = internal$1.space;
	var internal_17$1 = internal$1.empty;
	var internal_18$1 = internal$1.listen;
	var internal_19$1 = internal$1.prevent_default;
	var internal_20$1 = internal$1.stop_propagation;
	var internal_21$1 = internal$1.attr;
	var internal_22$1 = internal$1.set_attributes;
	var internal_23$1 = internal$1.set_custom_element_data;
	var internal_24$1 = internal$1.xlink_attr;
	var internal_25$1 = internal$1.get_binding_group_value;
	var internal_26$1 = internal$1.to_number;
	var internal_27$1 = internal$1.time_ranges_to_array;
	var internal_28$1 = internal$1.children;
	var internal_29$1 = internal$1.claim_element;
	var internal_30$1 = internal$1.claim_text;
	var internal_31$1 = internal$1.set_data;
	var internal_32$1 = internal$1.set_input_type;
	var internal_33$1 = internal$1.set_style;
	var internal_34$1 = internal$1.select_option;
	var internal_35$1 = internal$1.select_options;
	var internal_36$1 = internal$1.select_value;
	var internal_37$1 = internal$1.select_multiple_value;
	var internal_38$1 = internal$1.add_resize_listener;
	var internal_39$1 = internal$1.toggle_class;
	var internal_40$1 = internal$1.custom_event;
	var internal_41$1 = internal$1.destroy_block;
	var internal_42$1 = internal$1.outro_and_destroy_block;
	var internal_43$1 = internal$1.fix_and_outro_and_destroy_block;
	var internal_44$1 = internal$1.update_keyed_each;
	var internal_45$1 = internal$1.measure;
	var internal_46$1 = internal$1.set_current_component;
	var internal_47$1 = internal$1.beforeUpdate;
	var internal_48$1 = internal$1.onMount;
	var internal_49$1 = internal$1.afterUpdate;
	var internal_50$1 = internal$1.onDestroy;
	var internal_51$1 = internal$1.createEventDispatcher;
	var internal_52$1 = internal$1.setContext;
	var internal_53$1 = internal$1.getContext;
	var internal_54$1 = internal$1.bubble;
	var internal_55$1 = internal$1.clear_loops;
	var internal_56$1 = internal$1.loop;
	var internal_57$1 = internal$1.dirty_components;
	var internal_58$1 = internal$1.intros;
	var internal_59$1 = internal$1.schedule_update;
	var internal_60$1 = internal$1.add_render_callback;
	var internal_61$1 = internal$1.tick;
	var internal_62$1 = internal$1.add_binding_callback;
	var internal_63$1 = internal$1.flush;
	var internal_64$1 = internal$1.get_spread_update;
	var internal_65$1 = internal$1.invalid_attribute_name_character;
	var internal_66$1 = internal$1.spread;
	var internal_67$1 = internal$1.escaped;
	var internal_68$1 = internal$1.escape;
	var internal_69$1 = internal$1.each;
	var internal_70$1 = internal$1.missing_component;
	var internal_71$1 = internal$1.validate_component;
	var internal_72$1 = internal$1.debug;
	var internal_73$1 = internal$1.create_ssr_component;
	var internal_74$1 = internal$1.get_store_value;
	var internal_75$1 = internal$1.group_outros;
	var internal_76$1 = internal$1.check_outros;
	var internal_77$1 = internal$1.on_outro;
	var internal_78$1 = internal$1.create_in_transition;
	var internal_79$1 = internal$1.create_out_transition;
	var internal_80$1 = internal$1.create_bidirectional_transition;
	var internal_81$1 = internal$1.noop;
	var internal_82$1 = internal$1.identity;
	var internal_83$1 = internal$1.assign;
	var internal_84$1 = internal$1.is_promise;
	var internal_85$1 = internal$1.add_location;
	var internal_86$1 = internal$1.run;
	var internal_87$1 = internal$1.blank_object;
	var internal_88$1 = internal$1.run_all;
	var internal_89$1 = internal$1.is_function;
	var internal_90$1 = internal$1.safe_not_equal;
	var internal_91$1 = internal$1.not_equal;
	var internal_92$1 = internal$1.validate_store;
	var internal_93$1 = internal$1.subscribe;
	var internal_94$1 = internal$1.create_slot;
	var internal_95$1 = internal$1.get_slot_context;
	var internal_96$1 = internal$1.get_slot_changes;
	var internal_97$1 = internal$1.exclude_internal_props;
	var internal_98$1 = internal$1.bind;
	var internal_99$1 = internal$1.mount_component;
	var internal_100$1 = internal$1.init;
	var internal_101$1 = internal$1.SvelteComponent;
	var internal_102$1 = internal$1.SvelteComponentDev;

	var svelte = createCommonjsModule$1(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });





	exports.onMount = internal$1.onMount;
	exports.onDestroy = internal$1.onDestroy;
	exports.beforeUpdate = internal$1.beforeUpdate;
	exports.afterUpdate = internal$1.afterUpdate;
	exports.setContext = internal$1.setContext;
	exports.getContext = internal$1.getContext;
	exports.tick = internal$1.tick;
	exports.createEventDispatcher = internal$1.createEventDispatcher;
	});

	unwrapExports$1(svelte);
	var svelte_1 = svelte.onMount;
	var svelte_2 = svelte.onDestroy;
	var svelte_3 = svelte.beforeUpdate;
	var svelte_4 = svelte.afterUpdate;
	var svelte_5 = svelte.setContext;
	var svelte_6 = svelte.getContext;
	var svelte_7 = svelte.tick;
	var svelte_8 = svelte.createEventDispatcher;

	/**
	 * Defines the blocks, marks, and embeds that can be used in a Typewriter document.
	 */

	// Determines if a <br> in the editable area is part of the document or a doorstop at the end of a block.
	function isBRPlaceholder$1(paper, node) {
	    if (node.nodeName !== 'BR')
	        return false;
	    var blocks = paper.blocks;
	    var next = node.nextSibling;
	    while (next && next.nodeValue === '')
	        next = next.nextSibling;
	    if (next) {
	        return next.nodeType === Node.ELEMENT_NODE && blocks.matches(next);
	    }
	    return blocks.matches(node.parentNode);
	}

	var dispatcherEvents$3 = new WeakMap();
	var EventDispatcher$3 = /** @class */ (function () {
	    function EventDispatcher() {
	    }
	    EventDispatcher.prototype.on = function (type, listener) {
	        getEventListeners$3(this, type, true).add(listener);
	    };
	    EventDispatcher.prototype.off = function (type, listener) {
	        var events = getEventListeners$3(this, type);
	        events && events["delete"](listener);
	    };
	    EventDispatcher.prototype.once = function (type, listener) {
	        function once() {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            this.off(type, once);
	            listener.apply(this, args);
	        }
	        this.on(type, once);
	    };
	    EventDispatcher.prototype.fire = function (type) {
	        var _this = this;
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        var uncanceled = true;
	        var events = getEventListeners$3(this, type);
	        if (events)
	            events.forEach(function (listener) {
	                uncanceled && listener.apply(_this, args) !== false || (uncanceled = false);
	            });
	        return uncanceled;
	    };
	    return EventDispatcher;
	}());
	function getEventListeners$3(obj, type, autocreate) {
	    if (autocreate === void 0) { autocreate = false; }
	    var events = dispatcherEvents$3.get(obj);
	    if (!events && autocreate)
	        dispatcherEvents$3.set(obj, events = Object.create(null));
	    return events && events[type] || autocreate && (events[type] = new Set());
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics$3 = function(d, b) {
	    extendStatics$3 = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return extendStatics$3(d, b);
	};

	function __extends$3(d, b) {
	    extendStatics$3(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign$3 = function() {
	    __assign$3 = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$3.apply(this, arguments);
	};

	/**
	 * This library modifies the diff-patch-match library by Neil Fraser
	 * by removing the patch and match functionality and certain advanced
	 * options in the diff function. The original license is as follows:
	 *
	 * ===
	 *
	 * Diff Match and Patch
	 *
	 * Copyright 2006 Google Inc.
	 * http://code.google.com/p/google-diff-match-patch/
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * The data structure representing a diff is an array of tuples:
	 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
	 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
	 */
	var DIFF_DELETE$3 = -1;
	var DIFF_INSERT$3 = 1;
	var DIFF_EQUAL$3 = 0;
	/**
	 * Find the differences between two texts.  Simplifies the problem by stripping
	 * any common prefix or suffix off the texts before diffing.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {Int} cursor_pos Expected edit position in text1 (optional)
	 * @return {Array} Array of diff tuples.
	 */
	function diff$3(text1, text2, cursor_pos) {
	    // Check for equality (speedup).
	    if (text1 == text2) {
	        if (text1) {
	            return [[DIFF_EQUAL$3, text1]];
	        }
	        return [];
	    }
	    // Check cursor_pos within bounds
	    if (cursor_pos < 0 || text1.length < cursor_pos) {
	        cursor_pos = null;
	    }
	    // Trim off common prefix (speedup).
	    var commonlength = diff_commonPrefix$3(text1, text2);
	    var commonprefix = text1.substring(0, commonlength);
	    text1 = text1.substring(commonlength);
	    text2 = text2.substring(commonlength);
	    // Trim off common suffix (speedup).
	    commonlength = diff_commonSuffix$3(text1, text2);
	    var commonsuffix = text1.substring(text1.length - commonlength);
	    text1 = text1.substring(0, text1.length - commonlength);
	    text2 = text2.substring(0, text2.length - commonlength);
	    // Compute the diff on the middle block.
	    var diffs = diff_compute_$3(text1, text2);
	    // Restore the prefix and suffix.
	    if (commonprefix) {
	        diffs.unshift([DIFF_EQUAL$3, commonprefix]);
	    }
	    if (commonsuffix) {
	        diffs.push([DIFF_EQUAL$3, commonsuffix]);
	    }
	    diff_cleanupMerge$3(diffs);
	    if (cursor_pos != null) {
	        diffs = fix_cursor$3(diffs, cursor_pos);
	    }
	    diffs = fix_emoji$3(diffs);
	    return diffs;
	}
	/**
	 * Find the differences between two texts.  Assumes that the texts do not
	 * have any common prefix or suffix.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @return {Array} Array of diff tuples.
	 */
	function diff_compute_$3(text1, text2) {
	    var diffs;
	    if (!text1) {
	        // Just add some text (speedup).
	        return [[DIFF_INSERT$3, text2]];
	    }
	    if (!text2) {
	        // Just delete some text (speedup).
	        return [[DIFF_DELETE$3, text1]];
	    }
	    var longtext = text1.length > text2.length ? text1 : text2;
	    var shorttext = text1.length > text2.length ? text2 : text1;
	    var i = longtext.indexOf(shorttext);
	    if (i != -1) {
	        // Shorter text is inside the longer text (speedup).
	        diffs = [[DIFF_INSERT$3, longtext.substring(0, i)],
	            [DIFF_EQUAL$3, shorttext],
	            [DIFF_INSERT$3, longtext.substring(i + shorttext.length)]];
	        // Swap insertions for deletions if diff is reversed.
	        if (text1.length > text2.length) {
	            diffs[0][0] = diffs[2][0] = DIFF_DELETE$3;
	        }
	        return diffs;
	    }
	    if (shorttext.length == 1) {
	        // Single character string.
	        // After the previous speedup, the character can't be an equality.
	        return [[DIFF_DELETE$3, text1], [DIFF_INSERT$3, text2]];
	    }
	    // Check to see if the problem can be split in two.
	    var hm = diff_halfMatch_$3(text1, text2);
	    if (hm) {
	        // A half-match was found, sort out the return data.
	        var text1_a = hm[0];
	        var text1_b = hm[1];
	        var text2_a = hm[2];
	        var text2_b = hm[3];
	        var mid_common = hm[4];
	        // Send both pairs off for separate processing.
	        var diffs_a = diff$3(text1_a, text2_a);
	        var diffs_b = diff$3(text1_b, text2_b);
	        // Merge the results.
	        return diffs_a.concat([[DIFF_EQUAL$3, mid_common]], diffs_b);
	    }
	    return diff_bisect_$3(text1, text2);
	}
	/**
	 * Find the 'middle snake' of a diff, split the problem in two
	 * and return the recursively constructed diff.
	 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @return {Array} Array of diff tuples.
	 * @private
	 */
	function diff_bisect_$3(text1, text2) {
	    // Cache the text lengths to prevent multiple calls.
	    var text1_length = text1.length;
	    var text2_length = text2.length;
	    var max_d = Math.ceil((text1_length + text2_length) / 2);
	    var v_offset = max_d;
	    var v_length = 2 * max_d;
	    var v1 = new Array(v_length);
	    var v2 = new Array(v_length);
	    // Setting all elements to -1 is faster in Chrome & Firefox than mixing
	    // integers and undefined.
	    for (var x = 0; x < v_length; x++) {
	        v1[x] = -1;
	        v2[x] = -1;
	    }
	    v1[v_offset + 1] = 0;
	    v2[v_offset + 1] = 0;
	    var delta = text1_length - text2_length;
	    // If the total number of characters is odd, then the front path will collide
	    // with the reverse path.
	    var front = (delta % 2 != 0);
	    // Offsets for start and end of k loop.
	    // Prevents mapping of space beyond the grid.
	    var k1start = 0;
	    var k1end = 0;
	    var k2start = 0;
	    var k2end = 0;
	    for (var d = 0; d < max_d; d++) {
	        // Walk the front path one step.
	        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
	            var k1_offset = v_offset + k1;
	            var x1;
	            if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
	                x1 = v1[k1_offset + 1];
	            }
	            else {
	                x1 = v1[k1_offset - 1] + 1;
	            }
	            var y1 = x1 - k1;
	            while (x1 < text1_length && y1 < text2_length &&
	                text1.charAt(x1) == text2.charAt(y1)) {
	                x1++;
	                y1++;
	            }
	            v1[k1_offset] = x1;
	            if (x1 > text1_length) {
	                // Ran off the right of the graph.
	                k1end += 2;
	            }
	            else if (y1 > text2_length) {
	                // Ran off the bottom of the graph.
	                k1start += 2;
	            }
	            else if (front) {
	                var k2_offset = v_offset + delta - k1;
	                if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
	                    // Mirror x2 onto top-left coordinate system.
	                    var x2 = text1_length - v2[k2_offset];
	                    if (x1 >= x2) {
	                        // Overlap detected.
	                        return diff_bisectSplit_$3(text1, text2, x1, y1);
	                    }
	                }
	            }
	        }
	        // Walk the reverse path one step.
	        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
	            var k2_offset = v_offset + k2;
	            var x2;
	            if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
	                x2 = v2[k2_offset + 1];
	            }
	            else {
	                x2 = v2[k2_offset - 1] + 1;
	            }
	            var y2 = x2 - k2;
	            while (x2 < text1_length && y2 < text2_length &&
	                text1.charAt(text1_length - x2 - 1) ==
	                    text2.charAt(text2_length - y2 - 1)) {
	                x2++;
	                y2++;
	            }
	            v2[k2_offset] = x2;
	            if (x2 > text1_length) {
	                // Ran off the left of the graph.
	                k2end += 2;
	            }
	            else if (y2 > text2_length) {
	                // Ran off the top of the graph.
	                k2start += 2;
	            }
	            else if (!front) {
	                var k1_offset = v_offset + delta - k2;
	                if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
	                    var x1 = v1[k1_offset];
	                    var y1 = v_offset + x1 - k1_offset;
	                    // Mirror x2 onto top-left coordinate system.
	                    x2 = text1_length - x2;
	                    if (x1 >= x2) {
	                        // Overlap detected.
	                        return diff_bisectSplit_$3(text1, text2, x1, y1);
	                    }
	                }
	            }
	        }
	    }
	    // Diff took too long and hit the deadline or
	    // number of diffs equals number of characters, no commonality at all.
	    return [[DIFF_DELETE$3, text1], [DIFF_INSERT$3, text2]];
	}
	/**
	 * Given the location of the 'middle snake', split the diff in two parts
	 * and recurse.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} x Index of split point in text1.
	 * @param {number} y Index of split point in text2.
	 * @return {Array} Array of diff tuples.
	 */
	function diff_bisectSplit_$3(text1, text2, x, y) {
	    var text1a = text1.substring(0, x);
	    var text2a = text2.substring(0, y);
	    var text1b = text1.substring(x);
	    var text2b = text2.substring(y);
	    // Compute both diffs serially.
	    var diffs = diff$3(text1a, text2a);
	    var diffsb = diff$3(text1b, text2b);
	    return diffs.concat(diffsb);
	}
	/**
	 * Determine the common prefix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the start of each
	 *     string.
	 */
	function diff_commonPrefix$3(text1, text2) {
	    // Quick check for common null cases.
	    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
	        return 0;
	    }
	    // Binary search.
	    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	    var pointermin = 0;
	    var pointermax = Math.min(text1.length, text2.length);
	    var pointermid = pointermax;
	    var pointerstart = 0;
	    while (pointermin < pointermid) {
	        if (text1.substring(pointerstart, pointermid) ==
	            text2.substring(pointerstart, pointermid)) {
	            pointermin = pointermid;
	            pointerstart = pointermin;
	        }
	        else {
	            pointermax = pointermid;
	        }
	        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }
	    return pointermid;
	}
	/**
	 * Determine the common suffix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the end of each string.
	 */
	function diff_commonSuffix$3(text1, text2) {
	    // Quick check for common null cases.
	    if (!text1 || !text2 ||
	        text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
	        return 0;
	    }
	    // Binary search.
	    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	    var pointermin = 0;
	    var pointermax = Math.min(text1.length, text2.length);
	    var pointermid = pointermax;
	    var pointerend = 0;
	    while (pointermin < pointermid) {
	        if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
	            text2.substring(text2.length - pointermid, text2.length - pointerend)) {
	            pointermin = pointermid;
	            pointerend = pointermin;
	        }
	        else {
	            pointermax = pointermid;
	        }
	        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }
	    return pointermid;
	}
	/**
	 * Do the two texts share a substring which is at least half the length of the
	 * longer text?
	 * This speedup can produce non-minimal diffs.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {Array.<string>} Five element Array, containing the prefix of
	 *     text1, the suffix of text1, the prefix of text2, the suffix of
	 *     text2 and the common middle.  Or null if there was no match.
	 */
	function diff_halfMatch_$3(text1, text2) {
	    var longtext = text1.length > text2.length ? text1 : text2;
	    var shorttext = text1.length > text2.length ? text2 : text1;
	    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
	        return null; // Pointless.
	    }
	    /**
	     * Does a substring of shorttext exist within longtext such that the substring
	     * is at least half the length of longtext?
	     * Closure, but does not reference any external variables.
	     * @param {string} longtext Longer string.
	     * @param {string} shorttext Shorter string.
	     * @param {number} i Start index of quarter length substring within longtext.
	     * @return {Array.<string>} Five element Array, containing the prefix of
	     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
	     *     of shorttext and the common middle.  Or null if there was no match.
	     * @private
	     */
	    function diff_halfMatchI_(longtext, shorttext, i) {
	        // Start with a 1/4 length substring at position i as a seed.
	        var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
	        var j = -1;
	        var best_common = '';
	        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
	        while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
	            var prefixLength = diff_commonPrefix$3(longtext.substring(i), shorttext.substring(j));
	            var suffixLength = diff_commonSuffix$3(longtext.substring(0, i), shorttext.substring(0, j));
	            if (best_common.length < suffixLength + prefixLength) {
	                best_common = shorttext.substring(j - suffixLength, j) +
	                    shorttext.substring(j, j + prefixLength);
	                best_longtext_a = longtext.substring(0, i - suffixLength);
	                best_longtext_b = longtext.substring(i + prefixLength);
	                best_shorttext_a = shorttext.substring(0, j - suffixLength);
	                best_shorttext_b = shorttext.substring(j + prefixLength);
	            }
	        }
	        if (best_common.length * 2 >= longtext.length) {
	            return [best_longtext_a, best_longtext_b,
	                best_shorttext_a, best_shorttext_b, best_common];
	        }
	        else {
	            return null;
	        }
	    }
	    // First check if the second quarter is the seed for a half-match.
	    var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
	    // Check again based on the third quarter.
	    var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
	    var hm;
	    if (!hm1 && !hm2) {
	        return null;
	    }
	    else if (!hm2) {
	        hm = hm1;
	    }
	    else if (!hm1) {
	        hm = hm2;
	    }
	    else {
	        // Both matched.  Select the longest.
	        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
	    }
	    // A half-match was found, sort out the return data.
	    var text1_a, text1_b, text2_a, text2_b;
	    if (text1.length > text2.length) {
	        text1_a = hm[0];
	        text1_b = hm[1];
	        text2_a = hm[2];
	        text2_b = hm[3];
	    }
	    else {
	        text2_a = hm[0];
	        text2_b = hm[1];
	        text1_a = hm[2];
	        text1_b = hm[3];
	    }
	    var mid_common = hm[4];
	    return [text1_a, text1_b, text2_a, text2_b, mid_common];
	}
	/**
	 * Reorder and merge like edit sections.  Merge equalities.
	 * Any edit section can move as long as it doesn't cross an equality.
	 * @param {Array} diffs Array of diff tuples.
	 */
	function diff_cleanupMerge$3(diffs) {
	    diffs.push([DIFF_EQUAL$3, '']); // Add a dummy entry at the end.
	    var pointer = 0;
	    var count_delete = 0;
	    var count_insert = 0;
	    var text_delete = '';
	    var text_insert = '';
	    var commonlength;
	    while (pointer < diffs.length) {
	        switch (diffs[pointer][0]) {
	            case DIFF_INSERT$3:
	                count_insert++;
	                text_insert += diffs[pointer][1];
	                pointer++;
	                break;
	            case DIFF_DELETE$3:
	                count_delete++;
	                text_delete += diffs[pointer][1];
	                pointer++;
	                break;
	            case DIFF_EQUAL$3:
	                // Upon reaching an equality, check for prior redundancies.
	                if (count_delete + count_insert > 1) {
	                    if (count_delete !== 0 && count_insert !== 0) {
	                        // Factor out any common prefixies.
	                        commonlength = diff_commonPrefix$3(text_insert, text_delete);
	                        if (commonlength !== 0) {
	                            if ((pointer - count_delete - count_insert) > 0 &&
	                                diffs[pointer - count_delete - count_insert - 1][0] ==
	                                    DIFF_EQUAL$3) {
	                                diffs[pointer - count_delete - count_insert - 1][1] +=
	                                    text_insert.substring(0, commonlength);
	                            }
	                            else {
	                                diffs.splice(0, 0, [DIFF_EQUAL$3,
	                                    text_insert.substring(0, commonlength)]);
	                                pointer++;
	                            }
	                            text_insert = text_insert.substring(commonlength);
	                            text_delete = text_delete.substring(commonlength);
	                        }
	                        // Factor out any common suffixies.
	                        commonlength = diff_commonSuffix$3(text_insert, text_delete);
	                        if (commonlength !== 0) {
	                            diffs[pointer][1] = text_insert.substring(text_insert.length -
	                                commonlength) + diffs[pointer][1];
	                            text_insert = text_insert.substring(0, text_insert.length -
	                                commonlength);
	                            text_delete = text_delete.substring(0, text_delete.length -
	                                commonlength);
	                        }
	                    }
	                    // Delete the offending records and add the merged ones.
	                    if (count_delete === 0) {
	                        diffs.splice(pointer - count_insert, count_delete + count_insert, [DIFF_INSERT$3, text_insert]);
	                    }
	                    else if (count_insert === 0) {
	                        diffs.splice(pointer - count_delete, count_delete + count_insert, [DIFF_DELETE$3, text_delete]);
	                    }
	                    else {
	                        diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [DIFF_DELETE$3, text_delete], [DIFF_INSERT$3, text_insert]);
	                    }
	                    pointer = pointer - count_delete - count_insert +
	                        (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
	                }
	                else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL$3) {
	                    // Merge this equality with the previous one.
	                    diffs[pointer - 1][1] += diffs[pointer][1];
	                    diffs.splice(pointer, 1);
	                }
	                else {
	                    pointer++;
	                }
	                count_insert = 0;
	                count_delete = 0;
	                text_delete = '';
	                text_insert = '';
	                break;
	        }
	    }
	    if (diffs[diffs.length - 1][1] === '') {
	        diffs.pop(); // Remove the dummy entry at the end.
	    }
	    // Second pass: look for single edits surrounded on both sides by equalities
	    // which can be shifted sideways to eliminate an equality.
	    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
	    var changes = false;
	    pointer = 1;
	    // Intentionally ignore the first and last element (don't need checking).
	    while (pointer < diffs.length - 1) {
	        if (diffs[pointer - 1][0] == DIFF_EQUAL$3 &&
	            diffs[pointer + 1][0] == DIFF_EQUAL$3) {
	            // This is a single edit surrounded by equalities.
	            if (diffs[pointer][1].substring(diffs[pointer][1].length -
	                diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
	                // Shift the edit over the previous equality.
	                diffs[pointer][1] = diffs[pointer - 1][1] +
	                    diffs[pointer][1].substring(0, diffs[pointer][1].length -
	                        diffs[pointer - 1][1].length);
	                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
	                diffs.splice(pointer - 1, 1);
	                changes = true;
	            }
	            else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
	                diffs[pointer + 1][1]) {
	                // Shift the edit over the next equality.
	                diffs[pointer - 1][1] += diffs[pointer + 1][1];
	                diffs[pointer][1] =
	                    diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
	                        diffs[pointer + 1][1];
	                diffs.splice(pointer + 1, 1);
	                changes = true;
	            }
	        }
	        pointer++;
	    }
	    // If shifts were made, the diff needs reordering and another shift sweep.
	    if (changes) {
	        diff_cleanupMerge$3(diffs);
	    }
	}
	diff$3.INSERT = DIFF_INSERT$3;
	diff$3.DELETE = DIFF_DELETE$3;
	diff$3.EQUAL = DIFF_EQUAL$3;
	/*
	 * Modify a diff such that the cursor position points to the start of a change:
	 * E.g.
	 *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)
	 *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]
	 *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)
	 *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
	 * @return {Array} A tuple [cursor location in the modified diff, modified diff]
	 */
	function cursor_normalize_diff$3(diffs, cursor_pos) {
	    if (cursor_pos === 0) {
	        return [DIFF_EQUAL$3, diffs];
	    }
	    for (var current_pos = 0, i = 0; i < diffs.length; i++) {
	        var d = diffs[i];
	        if (d[0] === DIFF_DELETE$3 || d[0] === DIFF_EQUAL$3) {
	            var next_pos = current_pos + d[1].length;
	            if (cursor_pos === next_pos) {
	                return [i + 1, diffs];
	            }
	            else if (cursor_pos < next_pos) {
	                // copy to prevent side effects
	                diffs = diffs.slice();
	                // split d into two diff changes
	                var split_pos = cursor_pos - current_pos;
	                var d_left = [d[0], d[1].slice(0, split_pos)];
	                var d_right = [d[0], d[1].slice(split_pos)];
	                diffs.splice(i, 1, d_left, d_right);
	                return [i + 1, diffs];
	            }
	            else {
	                current_pos = next_pos;
	            }
	        }
	    }
	    throw new Error('cursor_pos is out of bounds!');
	}
	/*
	 * Modify a diff such that the edit position is "shifted" to the proposed edit location (cursor_position).
	 *
	 * Case 1)
	 *   Check if a naive shift is possible:
	 *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)
	 *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result
	 * Case 2)
	 *   Check if the following shifts are possible:
	 *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']
	 *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']
	 *         ^            ^
	 *         d          d_next
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
	 * @return {Array} Array of diff tuples
	 */
	function fix_cursor$3(diffs, cursor_pos) {
	    var norm = cursor_normalize_diff$3(diffs, cursor_pos);
	    var ndiffs = norm[1];
	    var cursor_pointer = norm[0];
	    var d = ndiffs[cursor_pointer];
	    var d_next = ndiffs[cursor_pointer + 1];
	    if (d == null) {
	        // Text was deleted from end of original string,
	        // cursor is now out of bounds in new string
	        return diffs;
	    }
	    else if (d[0] !== DIFF_EQUAL$3) {
	        // A modification happened at the cursor location.
	        // This is the expected outcome, so we can return the original diff.
	        return diffs;
	    }
	    else {
	        if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
	            // Case 1)
	            // It is possible to perform a naive shift
	            ndiffs.splice(cursor_pointer, 2, d_next, d);
	            return merge_tuples$3(ndiffs, cursor_pointer, 2);
	        }
	        else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
	            // Case 2)
	            // d[1] is a prefix of d_next[1]
	            // We can assume that d_next[0] !== 0, since d[0] === 0
	            // Shift edit locations..
	            ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
	            var suffix = d_next[1].slice(d[1].length);
	            if (suffix.length > 0) {
	                ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
	            }
	            return merge_tuples$3(ndiffs, cursor_pointer, 3);
	        }
	        else {
	            // Not possible to perform any modification
	            return diffs;
	        }
	    }
	}
	/*
	 * Check diff did not split surrogate pairs.
	 * Ex. [0, '\uD83D'], [-1, '\uDC36'], [1, '\uDC2F'] -> [-1, '\uD83D\uDC36'], [1, '\uD83D\uDC2F']
	 *     '\uD83D\uDC36' === '🐶', '\uD83D\uDC2F' === '🐯'
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @return {Array} Array of diff tuples
	 */
	function fix_emoji$3(diffs) {
	    var compact = false;
	    var starts_with_pair_end = function (str) {
	        return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;
	    };
	    var ends_with_pair_start = function (str) {
	        return str.charCodeAt(str.length - 1) >= 0xD800 && str.charCodeAt(str.length - 1) <= 0xDBFF;
	    };
	    for (var i = 2; i < diffs.length; i += 1) {
	        if (diffs[i - 2][0] === DIFF_EQUAL$3 && ends_with_pair_start(diffs[i - 2][1]) &&
	            diffs[i - 1][0] === DIFF_DELETE$3 && starts_with_pair_end(diffs[i - 1][1]) &&
	            diffs[i][0] === DIFF_INSERT$3 && starts_with_pair_end(diffs[i][1])) {
	            compact = true;
	            diffs[i - 1][1] = diffs[i - 2][1].slice(-1) + diffs[i - 1][1];
	            diffs[i][1] = diffs[i - 2][1].slice(-1) + diffs[i][1];
	            diffs[i - 2][1] = diffs[i - 2][1].slice(0, -1);
	        }
	    }
	    if (!compact) {
	        return diffs;
	    }
	    var fixed_diffs = [];
	    for (var i = 0; i < diffs.length; i += 1) {
	        if (diffs[i][1].length > 0) {
	            fixed_diffs.push(diffs[i]);
	        }
	    }
	    return fixed_diffs;
	}
	/*
	 * Try to merge tuples with their neigbors in a given range.
	 * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']
	 *
	 * @param {Array} diffs Array of diff tuples.
	 * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).
	 * @param {Int} length Number of consecutive elements to check.
	 * @return {Array} Array of merged diff tuples.
	 */
	function merge_tuples$3(diffs, start, length) {
	    // Check from (start-1) to (start+length).
	    for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {
	        if (i + 1 < diffs.length) {
	            var left_d = diffs[i];
	            var right_d = diffs[i + 1];
	            if (left_d[0] === right_d[1]) {
	                diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
	            }
	        }
	    }
	    return diffs;
	}

	function shallowEqual$3(valueA, valueB) {
	    return valueEqual$3(valueA, valueB, strictEqual$3);
	}
	function deepEqual$3(valueA, valueB) {
	    return valueEqual$3(valueA, valueB, valueEqual$3);
	}
	function strictEqual$3(valueA, valueB) {
	    return valueA === valueB;
	}
	function valueEqual$3(valueA, valueB, propEqual) {
	    if (valueA === valueB)
	        return true;
	    if (valueA instanceof Date && valueB instanceof Date)
	        return valueA.getTime() === valueB.getTime();
	    if (!valueA || !valueB || typeof valueA !== 'object' && typeof valueB !== 'object')
	        return valueA === valueB;
	    return objectEqual$3(valueA, valueB, propEqual);
	}
	function objectEqual$3(objA, objB, propEqual) {
	    if (objA.prototype !== objB.prototype)
	        return false;
	    var keysA = Object.keys(objA);
	    var keysB = Object.keys(objB);
	    if (keysA.length !== keysB.length)
	        return false;
	    return keysA.every(function (key, i) { return key === keysB[i] && propEqual(objA[key], objB[key], propEqual); });
	}

	var NULL_CHARACTER$3 = String.fromCharCode(0); // Placeholder char for embed in diff()
	var Delta$3 = /** @class */ (function () {
	    function Delta(ops) {
	        if (ops === void 0) { ops = []; }
	        this.ops = ops;
	    }
	    /**
	     * Appends an insert operation. Returns this for chainability.
	     *
	     * @param {String|Object} text Represents text or embed to insert
	     * @param {Object} attributes Optional attributes to apply
	     */
	    Delta.prototype.insert = function (text, attributes) {
	        var newOp = {};
	        if (text.length === 0)
	            return this;
	        newOp.insert = text;
	        if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
	            newOp.attributes = attributes;
	        }
	        return this._push(newOp);
	    };
	    /**
	     * Appends a delete operation. Returns this for chainability.
	     *
	     * @param {Number} length Number of characters to delete
	     */
	    Delta.prototype["delete"] = function (length) {
	        if (length <= 0)
	            return this;
	        return this._push({ "delete": length });
	    };
	    /**
	     * Appends a retain operation. Returns this for chainability.
	     *
	     * @param {Number} length Number of characters to retain
	     * @param {Object} attributes Optional attributes to apply
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.retain = function (length, attributes) {
	        if (length <= 0)
	            return this;
	        var newOp = { retain: length };
	        if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
	            newOp.attributes = attributes;
	        }
	        return this._push(newOp);
	    };
	    /**
	     * Freezes delta from future modifications. Returns this for chainability.
	     *
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.freeze = function () {
	        var _this = this;
	        this._push = function () { return _this; };
	        return this;
	    };
	    /**
	     * Adds a new operation. Returns this for chainability.
	     *
	     * @param {Object} newOp A new operation
	     * @returns {Delta} This delta
	     */
	    Delta.prototype._push = function (newOp) {
	        var index = this.ops.length;
	        var lastOp = this.ops[index - 1];
	        if (typeof lastOp === 'object') {
	            if (typeof newOp["delete"] === 'number' && typeof lastOp["delete"] === 'number') {
	                this.ops[index - 1] = { "delete": lastOp["delete"] + newOp["delete"] };
	                return this;
	            }
	            // Since it does not matter if we insert before or after deleting at the same index,
	            // always prefer to insert first
	            if (typeof lastOp["delete"] === 'number' && newOp.insert != null) {
	                index -= 1;
	                lastOp = this.ops[index - 1];
	                if (typeof lastOp !== 'object') {
	                    this.ops.unshift(newOp);
	                    return this;
	                }
	            }
	            if (deepEqual$3(newOp.attributes, lastOp.attributes)) {
	                if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {
	                    this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };
	                    if (typeof newOp.attributes === 'object')
	                        this.ops[index - 1].attributes = newOp.attributes;
	                    return this;
	                }
	                else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {
	                    this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };
	                    if (typeof newOp.attributes === 'object')
	                        this.ops[index - 1].attributes = newOp.attributes;
	                    return this;
	                }
	            }
	        }
	        if (index === this.ops.length) {
	            this.ops.push(newOp);
	        }
	        else {
	            this.ops.splice(index, 0, newOp);
	        }
	        return this;
	    };
	    /**
	     * Chops off trailing retain instructions to make the delta concise.
	     *
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.chop = function () {
	        var lastOp = this.ops[this.ops.length - 1];
	        if (lastOp && lastOp.retain && !lastOp.attributes) {
	            this.ops.pop();
	        }
	        return this;
	    };
	    /**
	     * Returns an iterator to iterate over the operations of this delta.
	     *
	     * @returns {Iterator} An operation iterator with methods hasNext, next, peek, peekLength, & peekType
	     */
	    Delta.prototype.iterator = function () {
	        return new Iterator$3(this.ops);
	    };
	    /**
	     * Returns an array of operations that passes a given function.
	     *
	     * @param {Function} predicate Function to test each operation against. Return true to keep the operation, false
	     *                             otherwise
	     * @returns {Array} Filtered resulting array
	     */
	    Delta.prototype.filter = function (predicate) {
	        return this.ops.filter(predicate);
	    };
	    /**
	     * Iterates through operations, calling the provided function for each operation.
	     *
	     * @param {Function} predicate Function to call during iteration, passing in the current operation
	     */
	    Delta.prototype.forEach = function (predicate) {
	        this.ops.forEach(predicate);
	    };
	    /**
	     * Returns a new array with the results of calling provided function on each operation.
	     *
	     * @param {Function} predicate Function to call, passing in the current operation, returning an element of the new
	     *                             array to be returned
	     * @returns {Array} A new array with each element being the result of the given function
	     */
	    Delta.prototype.map = function (predicate) {
	        return this.ops.map(predicate);
	    };
	    /**
	     * Create an array of two arrays, the first with operations that pass the given function, the other that failed.
	     *
	     * @param {Function} predicate Function to call, passing in the current operation, returning whether that operation
	     *                             passed
	     * @returns {Array} A new array of two Arrays, the first with passed operations, the other with failed operations
	     */
	    Delta.prototype.partition = function (predicate) {
	        var passed = [], failed = [];
	        this.forEach(function (op) {
	            var target = predicate(op) ? passed : failed;
	            target.push(op);
	        });
	        return [passed, failed];
	    };
	    /**
	     * Applies given function against an accumulator and each operation to reduce to a single value.
	     *
	     * @param {Function} predicate Function to call per iteration, returning an accumulated value
	     * @param {*} initial Initial value to pass to first call to predicate
	     * @returns {*} The accumulated value
	     */
	    Delta.prototype.reduce = function (predicate, initial) {
	        return this.ops.reduce(predicate, initial);
	    };
	    Delta.prototype.changeLength = function () {
	        return this.reduce(function (length, entry) {
	            if (entry.insert) {
	                return length + getOpLength$3(entry);
	            }
	            else if (entry["delete"]) {
	                return length - entry["delete"];
	            }
	            return length;
	        }, 0);
	    };
	    /**
	     * Returns length of a Delta, which is the sum of the lengths of its operations.
	     *
	     * @returns {Number} The length of this delta
	     */
	    Delta.prototype.length = function () {
	        return this.reduce(function (length, entry) {
	            return length + getOpLength$3(entry);
	        }, 0);
	    };
	    /**
	     * Returns copy of delta with subset of operations.
	     *
	     * @param {Number} start Start index of subset, defaults to 0
	     * @param {Number} end End index of subset, defaults to rest of operations
	     * @returns {Array} An array slice of the operations
	     */
	    Delta.prototype.slice = function (start, end) {
	        if (start === void 0) { start = 0; }
	        if (typeof end !== 'number')
	            end = Infinity;
	        var ops = [];
	        var iter = this.iterator();
	        var index = 0;
	        while (index < end && iter.hasNext()) {
	            var nextOp;
	            if (index < start) {
	                nextOp = iter.next(start - index);
	            }
	            else {
	                nextOp = iter.next(end - index);
	                ops.push(nextOp);
	            }
	            index += getOpLength$3(nextOp);
	        }
	        return new Delta(ops);
	    };
	    /**
	     * Returns a Delta that is equivalent to applying the operations of own Delta, followed by another Delta.
	     *
	     * @param {Delta} other Delta to compose
	     */
	    Delta.prototype.compose = function (other) {
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        var delta = new Delta();
	        while (thisIter.hasNext() || otherIter.hasNext()) {
	            if (otherIter.peekType() === 'insert') {
	                delta._push(otherIter.next());
	            }
	            else if (thisIter.peekType() === 'delete') {
	                delta._push(thisIter.next());
	            }
	            else {
	                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
	                var thisOp = thisIter.next(length);
	                var otherOp = otherIter.next(length);
	                if (typeof otherOp.retain === 'number') {
	                    var newOp = {};
	                    if (typeof thisOp.retain === 'number') {
	                        newOp.retain = length;
	                    }
	                    else {
	                        newOp.insert = thisOp.insert;
	                    }
	                    // Preserve null when composing with a retain, otherwise remove it for inserts
	                    var attributes = composeAttributes$3(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');
	                    if (attributes)
	                        newOp.attributes = attributes;
	                    delta._push(newOp);
	                    // Optimization if rest of other is just retain
	                    if (!otherIter.hasNext() && deepEqual$3(delta.ops[delta.ops.length - 1], newOp)) {
	                        var rest = new Delta(thisIter.rest());
	                        return delta.concat(rest).chop();
	                    }
	                    // Other op should be delete, we could be an insert or retain
	                    // Insert + delete cancels out
	                }
	                else if (typeof otherOp["delete"] === 'number' && typeof thisOp.retain === 'number') {
	                    delta._push(otherOp);
	                }
	            }
	        }
	        return delta.chop();
	    };
	    /**
	     * Returns a new Delta representing the concatenation of this and another document Delta's operations.
	     *
	     * @param {Delta} other Document Delta to concatenate
	     * @returns {Delta} Concatenated document Delta
	     */
	    Delta.prototype.concat = function (other) {
	        var delta = new Delta(this.ops.slice());
	        if (other.ops.length > 0) {
	            delta._push(other.ops[0]);
	            delta.ops = delta.ops.concat(other.ops.slice(1));
	        }
	        return delta;
	    };
	    /**
	     * Returns a Delta representing the difference between two documents. Optionally, accepts a suggested index where
	     * change took place, often representing a cursor position before change.
	     *
	     * @param {Delta} other Document Delta to diff against
	     * @param {Number} index Suggested index where change took place
	     * @returns {Delta} Difference between the two documents
	     */
	    Delta.prototype.diff = function (other, index) {
	        if (this.ops === other.ops) {
	            return new Delta();
	        }
	        var strings = [this, other].map(function (delta) {
	            return delta.map(function (op) {
	                if (op.insert != null) {
	                    return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER$3;
	                }
	                var prep = (delta === other) ? 'on' : 'with';
	                throw new Error('diff() called ' + prep + ' non-document');
	            }).join('');
	        });
	        var delta = new Delta();
	        var diffResult = diff$3(strings[0], strings[1], index);
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        diffResult.forEach(function (component) {
	            var length = component[1].length;
	            while (length > 0) {
	                var opLength = 0;
	                switch (component[0]) {
	                    case diff$3.INSERT:
	                        opLength = Math.min(otherIter.peekLength(), length);
	                        delta._push(otherIter.next(opLength));
	                        break;
	                    case diff$3.DELETE:
	                        opLength = Math.min(length, thisIter.peekLength());
	                        thisIter.next(opLength);
	                        delta["delete"](opLength);
	                        break;
	                    case diff$3.EQUAL:
	                        opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
	                        var thisOp = thisIter.next(opLength);
	                        var otherOp = otherIter.next(opLength);
	                        if (deepEqual$3(thisOp.insert, otherOp.insert)) {
	                            delta.retain(opLength, diffAttributes$3(thisOp.attributes, otherOp.attributes));
	                        }
	                        else {
	                            delta._push(otherOp)["delete"](opLength);
	                        }
	                        break;
	                }
	                length -= opLength;
	            }
	        });
	        return delta.chop();
	    };
	    /**
	     * Iterates through document Delta, calling a given function with a Delta and attributes object, representing the line
	     * segment.
	     *
	     * @param {Function} predicate Function to call on each line group
	     * @param {String} newline Newline character, defaults to \n
	     */
	    Delta.prototype.eachLine = function (predicate, newline) {
	        if (newline === void 0) { newline = '\n'; }
	        var iter = this.iterator();
	        var ops = new Delta();
	        var index = 0;
	        var lineStart = 0;
	        var currentIndex = 0;
	        while (iter.hasNext()) {
	            if (iter.peekType() !== 'insert')
	                return;
	            var op = iter.peek();
	            var nextLength = iter.peekLength();
	            var start = getOpLength$3(op) - nextLength;
	            var newlineIndex = typeof op.insert === 'string' ? op.insert.indexOf(newline, start) - start : -1;
	            if (newlineIndex < 0) {
	                currentIndex += nextLength;
	                ops._push(iter.next());
	            }
	            else if (newlineIndex > 0) {
	                currentIndex += newlineIndex;
	                ops._push(iter.next(newlineIndex));
	            }
	            else {
	                currentIndex += 1;
	                var attributes = iter.next(1).attributes || {};
	                var line = { ops: ops, attributes: attributes, start: lineStart, end: currentIndex, index: index };
	                if (predicate(line, index) === false) {
	                    return;
	                }
	                index += 1;
	                lineStart = currentIndex;
	                ops = new Delta();
	            }
	        }
	        if (ops.length() > 0) {
	            var line_1 = { ops: ops, attributes: {}, start: lineStart, end: currentIndex, index: index };
	            predicate(line_1, index);
	        }
	    };
	    // Extends Delta, get the lines from `from` to `to`.
	    Delta.prototype.getLines = function (from, to, newline) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = Infinity; }
	        var lines = [];
	        this.eachLine(function (line) {
	            if (line.start > to || (line.start === to && from !== to))
	                return false;
	            if (line.end > from) {
	                lines.push(line);
	            }
	        }, newline);
	        return lines;
	    };
	    // Extends Delta, get the line at `at`.
	    Delta.prototype.getLine = function (at, newline) {
	        return this.getLines(at, at, newline)[0];
	    };
	    // Extends Delta, get the ops from `from` to `to`.
	    Delta.prototype.getOps = function (from, to) {
	        var start = 0;
	        var ops = [];
	        this.ops.some(function (op) {
	            if (start >= to)
	                return true;
	            var end = start + getOpLength$3(op);
	            if (end > from || (from === to && end === to)) {
	                ops.push({ op: op, start: start, end: end });
	            }
	            start = end;
	        });
	        return ops;
	    };
	    // Extends Delta, get the op at `at`.
	    Delta.prototype.getOp = function (at) {
	        return this.getOps(at, at)[0];
	    };
	    /**
	     * Transform given Delta against own operations. Used as an alias for transformPosition when called with a number.
	     *
	     * @param {Delta} other Delta to transform
	     * @param {Boolean} priority Boolean used to break ties. If true, then this takes priority over other, that is, its
	     *                           actions are considered to happen "first."
	     * @returns {Delta} Transformed Delta
	     */
	    Delta.prototype.transform = function (other, priority) {
	        if (priority === void 0) { priority = false; }
	        if (typeof other === 'number') {
	            return this.transformPosition(other, priority);
	        }
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        var delta = new Delta();
	        while (thisIter.hasNext() || otherIter.hasNext()) {
	            if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {
	                delta.retain(getOpLength$3(thisIter.next()));
	            }
	            else if (otherIter.peekType() === 'insert') {
	                delta._push(otherIter.next());
	            }
	            else {
	                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
	                var thisOp = thisIter.next(length);
	                var otherOp = otherIter.next(length);
	                if (thisOp["delete"]) {
	                    // Our delete either makes their delete redundant or removes their retain
	                    continue;
	                }
	                else if (otherOp["delete"]) {
	                    delta._push(otherOp);
	                }
	                else {
	                    // We retain either their retain or insert
	                    delta.retain(length, transformAttributes$3(thisOp.attributes, otherOp.attributes, priority));
	                }
	            }
	        }
	        return delta.chop();
	    };
	    /**
	     * Transform an index against the delta. Useful for representing cursor/selection positions.
	     *
	     * @param {Number} index Index to transform
	     * @param {Boolean} priority Boolean used to break ties. If true, then this takes priority over other, that is, its
	     *                           actions are considered to happen "first."
	     * @returns {Number} Transformed index
	     */
	    Delta.prototype.transformPosition = function (index, priority) {
	        if (priority === void 0) { priority = false; }
	        var thisIter = this.iterator();
	        var offset = 0;
	        while (thisIter.hasNext() && offset <= index) {
	            var length = thisIter.peekLength();
	            var nextType = thisIter.peekType();
	            thisIter.next();
	            if (nextType === 'delete') {
	                index -= Math.min(length, index - offset);
	                continue;
	            }
	            else if (nextType === 'insert' && (offset < index || !priority)) {
	                index += length;
	            }
	            offset += length;
	        }
	        return index;
	    };
	    return Delta;
	}());
	/**
	 * Create an attributes object that is equivalent to applying the attributes of the target followed by the source.
	 *
	 * @param {Object} target Target attributes object which will have the source applied to
	 * @param {Object} source Source attributes object being applied to the target
	 * @param {Boolean} keepNull Whether to keep null values from source
	 * @returns {Object} A new attributes object (or undefined if empty) with both
	 */
	function composeAttributes$3(target, source, keepNull) {
	    if (target === void 0) { target = {}; }
	    if (source === void 0) { source = {}; }
	    var attributes = __assign$3({}, target, source);
	    if (!keepNull)
	        Object.keys(attributes).forEach(function (key) {
	            if (attributes[key] == null)
	                delete attributes[key];
	        });
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Finds the difference between two attributes objects. Returns the source attributes that are different from the
	 * target attributes.
	 *
	 * @param {Object} target An attributes object
	 * @param {Object} source An attributes object
	 * @returns {Object} The difference between the two attribute objects or undefined if there is none
	 */
	function diffAttributes$3(target, source) {
	    if (target === void 0) { target = {}; }
	    if (source === void 0) { source = {}; }
	    var attributes = Object.keys(target).concat(Object.keys(source)).reduce(function (attributes, key) {
	        if (!deepEqual$3(target[key], source[key])) {
	            attributes[key] = source[key] === undefined ? null : source[key];
	        }
	        return attributes;
	    }, {});
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Transforms the attributes of source over target (or the other way around if priority is set). Will return an
	 * attributes object which has all the values from source if priority if false or will have the values from source that
	 * are set on target.
	 *
	 * @param {Object} target An attributes object
	 * @param {Object} source An attributes object
	 * @param {Boolean} priority If target has priority over source
	 */
	function transformAttributes$3(target, source, priority) {
	    if (typeof target !== 'object')
	        return source;
	    if (typeof source !== 'object')
	        return undefined;
	    if (!priority)
	        return source; // b simply overwrites us without priority
	    var attributes = Object.keys(source).reduce(function (attributes, key) {
	        if (target[key] === undefined)
	            attributes[key] = source[key]; // null is a valid value
	        return attributes;
	    }, {});
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Determines the length of a Delta operation.
	 *
	 * @param {Object} op An operation entry from a Delta object
	 * @returns {Number} The length of the op
	 */
	function getOpLength$3(op) {
	    if (typeof op["delete"] === 'number') {
	        return op["delete"];
	    }
	    else if (typeof op.retain === 'number') {
	        return op.retain;
	    }
	    else {
	        return typeof op.insert === 'string' ? op.insert.length : 1;
	    }
	}
	/**
	 * An iterator to handle iterating over a list of Delta operations efficiently.
	 */
	var Iterator$3 = /** @class */ (function () {
	    function Iterator(ops) {
	        this.ops = ops;
	        this.index = 0;
	        this.offset = 0;
	    }
	    /**
	     * Determine if there will be another operation returned by `next`.
	     *
	     * @returns {Boolean} Whether there are more operations to iterate over
	     */
	    Iterator.prototype.hasNext = function () {
	        return this.peekLength() < Infinity;
	    };
	    /**
	     * Get the next operation, optionally limited/sliced by length. If an operation is sliced by length, the next call to
	     * `next` will return more of that operation until it is returned in full.
	     *
	     * @param {Number} length Optionally limit the returned operation by length, slicing it down as needed
	     */
	    Iterator.prototype.next = function (length) {
	        if (length === void 0) { length = Infinity; }
	        var nextOp = this.ops[this.index];
	        if (!nextOp)
	            return { retain: Infinity };
	        var offset = this.offset;
	        var opLength = getOpLength$3(nextOp);
	        // Update index and offset
	        if (length >= opLength - offset) {
	            length = opLength - offset;
	            this.index += 1;
	            this.offset = 0;
	        }
	        else {
	            this.offset += length;
	        }
	        if (typeof nextOp["delete"] === 'number') {
	            return { "delete": length };
	        }
	        else {
	            var retOp = {};
	            if (nextOp.attributes) {
	                retOp.attributes = nextOp.attributes;
	            }
	            if (typeof nextOp.retain === 'number') {
	                retOp.retain = length;
	            }
	            else if (typeof nextOp.insert === 'string') {
	                retOp.insert = nextOp.insert.substr(offset, length);
	            }
	            else {
	                // offset should === 0, length should === 1
	                retOp.insert = nextOp.insert;
	            }
	            return retOp;
	        }
	    };
	    /**
	     * Return the next entry.
	     *
	     * @returns {Object} The next entry in the ops array.
	     */
	    Iterator.prototype.peek = function () {
	        return this.ops[this.index];
	    };
	    /**
	     * Check the length of the next entry.
	     *
	     * @returns {Number} The length of the next entry or Infinity if there is no next entry
	     */
	    Iterator.prototype.peekLength = function () {
	        if (this.ops[this.index]) {
	            // Should never return 0 if our index is being managed correctly
	            return getOpLength$3(this.ops[this.index]) - this.offset;
	        }
	        else {
	            return Infinity;
	        }
	    };
	    /**
	     * Check the type of the next entry, delete, retain, or insert.
	     *
	     * @returns {String} The type of the next entry
	     */
	    Iterator.prototype.peekType = function () {
	        if (this.ops[this.index]) {
	            if (typeof this.ops[this.index]["delete"] === 'number') {
	                return 'delete';
	            }
	            else if (typeof this.ops[this.index].retain === 'number') {
	                return 'retain';
	            }
	            else {
	                return 'insert';
	            }
	        }
	        return 'retain';
	    };
	    Iterator.prototype.rest = function () {
	        if (!this.hasNext()) {
	            return [];
	        }
	        else if (this.offset === 0) {
	            return this.ops.slice(this.index);
	        }
	        else {
	            var offset = this.offset;
	            var index = this.index;
	            var next = this.next();
	            var rest = this.ops.slice(this.index);
	            this.offset = offset;
	            this.index = index;
	            return [next].concat(rest);
	        }
	    };
	    return Iterator;
	}());

	var SOURCE_API$3 = 'api';
	var SOURCE_USER$6 = 'user';
	var SOURCE_SILENT$3 = 'silent';
	var empty$3 = {};
	/**
	 * Event for text changes, called before the change has occurred. If a listener returns false the change will be
	 * canceled and not committed.
	 *
	 * @event Editor#text-changing
	 * @type  {Object}
	 * @property {Delta} change       The change which is being applied to the content
	 * @property {Delta} content      The new content after the change
	 * @property {Delta} oldContent   The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * Event for text changes, called after the change has occurred.
	 *
	 * @event Editor#text-change
	 * @type  {Object}
	 * @property {Delta} change       The change which is being applied to the content
	 * @property {Delta} content      The new content after the change
	 * @property {Delta} oldContent   The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * Event for selection changes. If part of a text change the `change`, `content`, and `oldContent` properties will be
	 * set. Otherwise they will not be set.
	 *
	 * @event Editor#selection-change
	 * @type  {Object}
	 * @property {Delta} change       [ Optional ] The change which is being applied to the content
	 * @property {Delta} content      [ Optional ] The new content after the change
	 * @property {Delta} oldContent   [ Optional ] The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * A Typewriter Editor handles the logic for selection and editing of contents. It has no dependency on browser APIs
	 * and can be used in Node.js as easily as the browser. It has no logic to limit formatting (i.e. it does not disallow
	 * using bold, headers, links, or FOOBAR), that will need to be limited outside of the editor itself.
	 *
	 * @fires Editor#text-changing
	 * @fires Editor#text-change
	 * @fires Editor#selection-change
	 *
	 * @readonly @property {Delta}  contents      The data model for the text editor
	 * @readonly @property {Number} length        The length of the contents
	 * @readonly @property {String} text          The text of the contents
	 * @readonly @property {Array}  selection     The current editor selection, a tuple of `[ from, to ]` or `null`
	 * @readonly @property {Object} activeFormats The currently active formats (formats that will apply on the next insert)
	 */
	var Editor$3 = /** @class */ (function (_super) {
	    __extends$3(Editor, _super);
	    /**
	     * Create a new Typewriter editor.
	     *
	     * @param {Object} options Options for this editor include initial `contents` and `modules`:
	     * @param {Delta}  options.contents The initial contents of this editor
	     */
	    function Editor(options) {
	        if (options === void 0) { options = {}; }
	        var _this = _super.call(this) || this;
	        _this.contents = null;
	        _this.length = 0;
	        _this.selection = null;
	        _this.activeFormats = empty$3;
	        setContents$3(_this, options.contents || _this.delta().insert('\n'));
	        _this._queuedEvents = []; // Event queuing ensure they are fired in order
	        return _this;
	    }
	    /**
	     * Convenience method for creating a new delta.
	     *
	     * @param {Array} ops [Optional] The initial ops for the delta
	     * @returns {Delta}   A new Delta object
	     */
	    Editor.prototype.delta = function (ops) {
	        return new Delta$3(ops);
	    };
	    /**
	     * Returns the contents or a slice of them.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {Delta}     The contents of this editor
	     */
	    Editor.prototype.getContents = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.contents.slice(from, to);
	    };
	    /**
	     * Returns the text for the editor or a slice of it.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {String}    The text in the editor
	     */
	    Editor.prototype.getText = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length - 1; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.getContents(from, to)
	            .filter(function (op) { return typeof op.insert === 'string'; })
	            .map(function (op) { return op.insert; })
	            .join('');
	    };
	    /**
	     * Returns the text for the editor with null characters in place of embeds. This can be used to determine the index of
	     * given words or lines of text within the contents.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {String}    The text in the editor with embed spaces
	     */
	    Editor.prototype.getExactText = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length - 1; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.getContents(from, to)
	            .map(function (op) { return typeof op.insert === 'string' ? op.insert : '\0'; })
	            .join('');
	    };
	    /**
	     * Set the selection to a new location (or null for no selection). Will return false if the new selection is the same
	     * as the old selection. Dispatches "selection-change" once the selection is changed. This "selection-change" event
	     * won't have { contents, oldContnts, change } in it since the selection is changing without any content updates.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Boolean}        Whether the selection changed or not
	     */
	    Editor.prototype.setSelection = function (from, to, source) {
	        var _this = this;
	        if (source === void 0) { source = SOURCE_USER$6; }
	        var _a;
	        var oldSelection = this.selection;
	        var selection;
	        if (from === null) {
	            selection = null;
	            if (typeof to === 'string')
	                source = to;
	        }
	        else {
	            _a = this._normalizeSelection(from, to, source), from = _a[0], to = _a[1], source = _a[2];
	            selection = [from, to].map(function (i) { return Math.min(i, _this.length - 1); });
	        }
	        if (shallowEqual$3(oldSelection, selection))
	            return false;
	        // Reset the active formats when selection changes (do this before setting selection)
	        this.activeFormats = selection ? this.getTextFormat(Math.min(selection[0], selection[1])) : empty$3;
	        this.selection = selection;
	        var event = { selection: selection, oldSelection: oldSelection, source: source };
	        if (source !== SOURCE_SILENT$3)
	            this.fire('selection-change', event);
	        this.fire('editor-change', event);
	        return true;
	    };
	    /**
	     * The method that all other methods use to update the contents (even setContents & setText). This method will
	     * dispatch the event "text-changing". If a listener returns `false` then the change will be canceled and null will
	     * be returned. Otherwise, the change will be successful and if the `source` is not "silent" a "text-change" event
	     * will be fired with an event object containing `{ contents, oldContents, selection, oldSelection, source }`. If the
	     * selection has changed as part of this update a "selection-change" event will also be fired with the same event
	     * object.
	     *
	     * @param {Delta} change    A delta change to the document
	     * @param {String} source   The source of the change, user, api, or silent
	     * @param {Array} selection Optional selection after the change has been applied
	     * @returns {Delta}         Returns the change when successful, or null if not
	     */
	    Editor.prototype.updateContents = function (change, source, selection) {
	        if (source === void 0) { source = SOURCE_API$3; }
	        if (!change.chop().ops.length)
	            return null;
	        if (typeof selection === 'number')
	            selection = [selection, selection];
	        var oldContents = this.contents;
	        var contents = normalizeContents$3(oldContents.compose(change));
	        var length = contents.length();
	        var oldSelection = this.selection;
	        if (!selection)
	            selection = oldSelection ? oldSelection.map(function (i) { return change.transform(i); }) : oldSelection;
	        selection = selection && this.getSelectedRange(selection, length - 1);
	        var changeEvent = { contents: contents, oldContents: oldContents, change: change, selection: selection, oldSelection: oldSelection, source: source };
	        var selectionChanged = !shallowEqual$3(oldSelection, selection);
	        if (!this.fire('text-changing', changeEvent))
	            return null;
	        setContents$3(this, contents);
	        if (selection) {
	            // Reset the active formats when selection changes (do this before setting selection)
	            this.activeFormats = selection ? this.getTextFormat(Math.min(selection[0], selection[1])) : empty$3;
	            this.selection = selection;
	        }
	        var events = [];
	        if (source !== SOURCE_SILENT$3) {
	            events.push(['text-change', changeEvent]);
	            if (selectionChanged)
	                events.push(['selection-change', changeEvent]);
	        }
	        events.push(['editor-change', changeEvent]);
	        this._queueEvents(events);
	        return change;
	    };
	    /**
	     * Sets the entire contents of the editor. This will calculate the difference between the old content and the new and
	     * only apply the difference, if any.
	     *
	     * @param {Delta} newContents The contents of the editor, as a delta object
	     * @param {String} source     The source of the change, user, api, or silent
	     * @param {Array} selection   Optional selection after the change has been applied
	     * @returns {Delta}           Returns the change when successful, or null if not
	     */
	    Editor.prototype.setContents = function (newContents, source, selection) {
	        var change = this.contents.diff(normalizeContents$3(newContents));
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Sets the text content of the editor, removing existing contents and formatting.
	     *
	     * @param {String} text     Set the contents of this editor as text
	     * @param {String} source   The source of the change, user, api, or silent
	     * @param {Array} selection Optional selection after the change has been applied
	     * @returns {Delta}         Returns the change when successful, or null if not
	     */
	    Editor.prototype.setText = function (text, source, selection) {
	        return this.setContents(this.delta().insert(text + '\n'), source, selection);
	    };
	    /**
	     * Inserts text into the content of the editor, removing text between from and to if provided. If `text` is a newline
	     * ("\n") then the formats will apply to the line, otherwise they will apply to the text only (even if there are
	     * newlines in the text).
	     *
	     * @param {Number} from      Insert the text at this index, can also be a range Array tuple, default 0
	     * @param {Number} to        If provided and not equal to `from` will delete the text between `from` and `to`
	     * @param {String} text      The text to insert into the editor's contents
	     * @param {Object} formats   The formats of the inserted text. If null the formats at `from` will be used.
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.insertText = function (from, to, text, formats, source, selection) {
	        var _a, _b, _c;
	        _a = this._normalizeRange(from, to, text, formats, source, selection), from = _a[0], to = _a[1], text = _a[2], formats = _a[3], source = _a[4], selection = _a[5];
	        // If we are not inserting a newline, make sure from and to are within the selectable range
	        if (text !== '\n')
	            _b = this.getSelectedRange([from, to]), from = _b[0], to = _b[1];
	        if (typeof formats === 'string')
	            _c = [null, formats, source], formats = _c[0], source = _c[1], selection = _c[2];
	        if (selection == null && this.selection !== null)
	            selection = from + text.length;
	        var change = this.delta().retain(from)["delete"](to - from);
	        if (text === '\n') {
	            change.insert('\n', formats || this.getLineFormat(from));
	        }
	        else {
	            var lineFormat_1 = text.indexOf('\n') === -1 ? null : this.getLineFormat(from);
	            var textFormat_1 = formats || this.getTextFormat(from);
	            text.split('\n').forEach(function (line, i) {
	                if (i)
	                    change.insert('\n', lineFormat_1);
	                line.length && change.insert(line, textFormat_1);
	            });
	        }
	        change = cleanDelete$3(this, from, to, change);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Inserts an embed into the content of the editor, removing text between from and to if provided.
	     *
	     * @param {Number} from      Insert the embed at this index, can also be a range Array tuple, default 0
	     * @param {Number} to        If provided and not equal to `from` will delete the text between `from` and `to`
	     * @param {String} embed     Insert the text into the editor's contents
	     * @param {mixed}  value     Insert the text into the editor's contents
	     * @param {String} formats   The formats of the inserted text. If null the formats at `from` will be used.
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.insertEmbed = function (from, to, embed, value, formats, source, selection) {
	        var _a, _b, _c;
	        _a = this._normalizeRange(from, to, embed, value, source, selection), from = _a[0], to = _a[1], embed = _a[2], value = _a[3], source = _a[4], selection = _a[5];
	        if (typeof formats === 'string')
	            _b = [null, formats, source], formats = _b[0], source = _b[1], selection = _b[2];
	        if (from >= this.length)
	            from = this.length - 1;
	        if (to >= this.length)
	            to = this.length - 1;
	        if (selection == null && this.selection !== null)
	            selection = from + 1;
	        var textFormat = formats || this.getTextFormat(from);
	        var change = this.delta().retain(from)["delete"](to - from).insert((_c = {}, _c[embed] = value, _c), textFormat);
	        change = cleanDelete$3(this, from, to, change);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Deletes text from `from` to `to`.
	     *
	     * @param {Number} from      Insert the text as this index, can also be a range Array tuple, default 0
	     * @param {Number} to        Will delete the text between `from` and `to`
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.deleteText = function (from, to, source, selection) {
	        var _a;
	        _a = this._normalizeRange(from, to, source, selection), from = _a[0], to = _a[1], source = _a[2], selection = _a[3];
	        if (from === to)
	            return null;
	        if (selection == null && this.selection !== null)
	            selection = from;
	        var change = this.delta().retain(from)["delete"](to - from);
	        change = cleanDelete$3(this, from, to, change);
	        // Keep the active format of the text to the right of the cursor when deleting
	        var activeFormats;
	        if (selection === from)
	            activeFormats = this.getTextFormat(from, from + 1);
	        var result = this.updateContents(change, source, selection);
	        if (result && activeFormats)
	            this.activeFormats = activeFormats;
	        return result;
	    };
	    /**
	     * Get the line formats for the line that `from` is in to the line that `to` is in. Returns only the common formats
	     * between all the lines. If `from` equals `to` (or `to` is not provided) the formats will be all of those for the
	     * line `from` is on. If two lines are touched and they have different formats, an empty object will be returned.
	     *
	     * @param {Number} from Getting line formats starting at `from`
	     * @param {Number} to   Getting line formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the lines which intersect from and to
	     */
	    Editor.prototype.getLineFormat = function (from, to) {
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        var formats;
	        this.contents.getLines(from, to).forEach(function (line) {
	            if (!line.attributes)
	                formats = {};
	            else if (!formats)
	                formats = __assign$3({}, line.attributes);
	            else
	                formats = combineFormats$3(formats, line.attributes);
	        });
	        return formats;
	    };
	    /**
	     * Get the text formats for all the text from `from` to `to`. Returns only the common formats between the two indexes.
	     * Will also return the `activeFormats`. Active formats are those which are toggled on when the selection is collapsed
	     * (from and to are equal) indicating inserted text should use (or not use) those formats.
	     *
	     * @param {Number} from Getting text formats starting at `from`
	     * @param {Number} to   Getting text formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the text
	     */
	    Editor.prototype.getTextFormat = function (from, to) {
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        var formats;
	        // optimize for current selection
	        var seleciton = this.selection;
	        if (from === to && shallowEqual$3(this.selection, [from, to])) {
	            return this.activeFormats;
	        }
	        this.contents.getOps(from, to).forEach(function (_a) {
	            var op = _a.op;
	            if (/^\n+$/.test(op.insert))
	                return;
	            if (!op.attributes)
	                formats = {};
	            else if (!formats)
	                formats = __assign$3({}, op.attributes);
	            else
	                formats = combineFormats$3(formats, op.attributes);
	        });
	        if (!formats)
	            formats = {};
	        return formats;
	    };
	    /**
	     * Get the text and line formats for all the lines and text from `from` to `to`.
	     *
	     * @param {Number} from Getting line and text formats starting at `from`
	     * @param {Number} to   Getting line and text formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the lines and text which intersect from and to
	     */
	    Editor.prototype.getFormat = function (from, to) {
	        return __assign$3({}, this.getTextFormat(from, to), this.getLineFormat(from, to));
	    };
	    /**
	     * Formats the lines intersected by `from` and `to` with the given line formats. To remove an existing format pass in
	     * `null` or `false` to turn it off (e.g. `{ blockquote: false }`).
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the line
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.formatLine = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var change = this.delta();
	        this.contents.getLines(from, to).forEach(function (line) {
	            if (!change.ops.length)
	                change.retain(line.end - 1);
	            else
	                change.retain(line.end - line.start - 1);
	            // Clear out old formats on the line
	            Object.keys(line.attributes).forEach(function (name) { return !formats[name] && (formats[name] = null); });
	            change.retain(1, formats);
	        });
	        change.chop();
	        return change.ops.length ? this.updateContents(change, source) : null;
	    };
	    /**
	     * Formats the text from `from` to `to` with the given text formats. To remove an existing format pass in `null` or
	     * `false` to turn it off (e.g. `{ bold: false }`).
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the text
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.formatText = function (from, to, formats, source) {
	        var _this = this;
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        if (from === to) {
	            if (this.activeFormats === empty$3)
	                this.activeFormats = {};
	            Object.keys(formats).forEach(function (key) {
	                var value = formats[key];
	                if (value == null || value === false)
	                    delete _this.activeFormats[key];
	                else
	                    _this.activeFormats[key] = value;
	            });
	            return;
	        }
	        Object.keys(formats).forEach(function (name) { return formats[name] === false && (formats[name] = null); });
	        var change = this.delta().retain(from);
	        this.getText(from, to).split('\n').forEach(function (line) {
	            line.length && change.retain(line.length, formats);
	            change.retain(1);
	        });
	        change.chop();
	        return this.updateContents(change, source);
	    };
	    /**
	     * Toggles the line formats from `from` to `to` with the given line formats. If the line has the exact formats already
	     * they will be removed, otherwise they will be added.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the line
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.toggleLineFormat = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var existing = this.getLineFormat(from, to);
	        if (deepEqual$3(existing, formats)) {
	            Object.keys(formats).forEach(function (key) { return formats[key] = null; });
	        }
	        return this.formatLine(from, to, formats, source);
	    };
	    /**
	     * Toggles the text formats from `from` to `to` with the given text formats. If the text has the exact formats already
	     * they will be removed, otherwise they will be added.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the text
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.toggleTextFormat = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var existing = this.getTextFormat(from, to);
	        var isSame = Object.keys(formats).every(function (key) { return formats[key] === existing[key]; });
	        if (isSame) {
	            Object.keys(formats).forEach(function (key) { return formats[key] = null; });
	        }
	        return this.formatText(from, to, formats, source);
	    };
	    /**
	     * Removes all formatting, text and line formats, for the text and lines from `from` to `to`.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.removeFormats = function (from, to, source) {
	        var _this = this;
	        var _a;
	        _a = this._normalizeRange(from, to, source), from = _a[0], to = _a[1], source = _a[2];
	        var formats = {};
	        this.contents.getOps(from, to).forEach(function (_a) {
	            var op = _a.op;
	            op.attributes && Object.keys(op.attributes).forEach(function (key) { return formats[key] = null; });
	        });
	        var change = this.delta().retain(from).retain(to - from, formats);
	        // If the last block was not captured be sure to clear that too
	        this.contents.getLines(from, to).forEach(function (line) {
	            var formats = {};
	            Object.keys(line.attributes).forEach(function (key) { return formats[key] = null; });
	            change = change.compose(_this.delta().retain(line.end - 1).retain(1, formats));
	        });
	        return this.updateContents(change, source);
	    };
	    /**
	     * Create a change delta calling one or more methods on the editor. The changes will not be applied as normal but will
	     * be collated into a single change delta and returned from this methnod. Example:
	     * ```js
	     * var change = editor.getChange(function() {
	     *   editor.deleteText(0, 5);
	     *   editor.insertText('\n', { blockquote: true });
	     *   editor.formatText(10, 20, { bold: true });
	     * });
	     *
	     * editor.updateContents(change, 'user');
	     * ```
	     *
	     * @param {Function} producer A function in which to call methods on the editor to produce a change
	     * @returns {Delta}           The sum of all the changes made within the producer
	     */
	    Editor.prototype.getChange = function (producer) {
	        var change = this.delta();
	        this.updateContents = function (singleChange) {
	            if (singleChange.ops.length) {
	                change = change.compose(singleChange);
	                return singleChange;
	            }
	            else {
	                return null;
	            }
	        };
	        producer(this);
	        delete this.updateContents;
	        return change;
	    };
	    /**
	     * Make several changes to the editor apply all at one in one commit. Changes made with the transaction will be
	     * applied all together and the "text-changing", "text-change", and "selection-change" events will be dispatched only
	     * once. Use this to combine multiple changes into one.
	     *
	     * @param {Function} producer A function which should make changes with the editor
	     * @param {String} source     The source of the change, user, api, or silent
	     * @param {Array} selection   Optional selection after the change has been applied
	     * @returns {Delta}           Returns the change when successful, or null if not
	     */
	    Editor.prototype.transaction = function (producer, source, selection) {
	        var change = this.getChange(producer);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Returns the selected range (or the provided range) in index order (lowest number first) and within the bounds of
	     * the content, between 0 and content.length() - 1 (the selection cannot be past the trailing newline).
	     *
	     * @param {Array} range Optional range, defaults to current selection
	     * @param {Number} max  The maxium number the range can be
	     */
	    Editor.prototype.getSelectedRange = function (range, max) {
	        if (range === void 0) { range = this.selection; }
	        if (max === void 0) { max = this.length - 1; }
	        var _a;
	        if (range == null)
	            return range;
	        if (typeof range === 'number')
	            range = [range, range];
	        if (range[0] > range[1])
	            _a = [range[1], range[0]], range[0] = _a[0], range[1] = _a[1];
	        return range.map(function (index) { return Math.max(0, Math.min(max, index)); });
	    };
	    Editor.prototype._queueEvents = function (events) {
	        var _a;
	        var alreadyRunning = this._queuedEvents.length;
	        (_a = this._queuedEvents).push.apply(_a, events);
	        if (alreadyRunning)
	            return;
	        while (this._queuedEvents.length) {
	            var event = this._queuedEvents.shift();
	            this.fire.apply(this, event);
	        }
	    };
	    /**
	     * Normalizes range values to a proper range if it is not already. A range is a `from` and a `to` index, e.g. 0, 4.
	     * This will ensure the lower index is first. Example usage:
	     * editor._normalizeRange(5); // [5, 5]
	     * editor._normalizeRange(-4, 100); // for a doc with length 10, [0, 10]
	     * editor._normalizeRange(25, 18); // [18, 25]
	     * editor._normalizeRange([12, 13]); // [12, 13]
	     * editor._normalizeRange(5, { bold: true }); // [5, 5, { bold: true }]
	     */
	    Editor.prototype._normalizeRange = function (from, to) {
	        var rest = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            rest[_i - 2] = arguments[_i];
	        }
	        var _a;
	        _a = this._normalizeSelection.apply(this, [from, to].concat(rest)), from = _a[0], to = _a[1], rest = _a.slice(2);
	        if (from > to) {
	            var toValue = from;
	            from = to;
	            to = toValue;
	        }
	        return [from, to].concat(rest);
	    };
	    Editor.prototype._normalizeSelection = function (from, to) {
	        var rest = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            rest[_i - 2] = arguments[_i];
	        }
	        var _a;
	        if (Array.isArray(from)) {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            _a = from, from = _a[0], to = _a[1];
	            if (to === undefined)
	                to = from;
	        }
	        else if (typeof from !== 'number') {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            if (from !== undefined || rest.length)
	                rest.unshift(from);
	            from = to = 0;
	        }
	        else if (typeof to !== 'number') {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            to = from;
	        }
	        from = Math.max(0, Math.min(this.length, Math.floor(from)));
	        to = Math.max(0, Math.min(this.length, Math.floor(to)));
	        return [from, to].concat(rest);
	    };
	    return Editor;
	}(EventDispatcher$3));
	// Ensures the format for the current line in a delete remains the same when multiple lines are deleted. This is needed
	// because the last line holds the formatting after a delete, but the first line is expected to be the retained format
	function cleanDelete$3(editor, from, to, change) {
	    if (from !== to) {
	        var line = editor.contents.getLine(from);
	        if (!line.ops.length() && to === from + 1)
	            return change;
	        var lineFormat_2 = editor.getLineFormat(from);
	        if (!deepEqual$3(lineFormat_2, editor.getLineFormat(to))) {
	            var lineChange = editor.getChange(function () { return editor.formatLine(to, lineFormat_2); });
	            change = change.compose(change.transform(lineChange));
	        }
	    }
	    return change;
	}
	// Ensures contents end with a newline
	function normalizeContents$3(contents) {
	    // Contents only have inserts. Deletes and retains belong to changes only.
	    contents.ops = contents.ops.filter(function (op) { return op.insert; });
	    var lastOp = contents.ops[contents.ops.length - 1];
	    if (!lastOp || typeof lastOp.insert !== 'string' || lastOp.insert.slice(-1) !== '\n')
	        contents.insert('\n');
	    return contents;
	}
	// Sets the contents onto the editor after ensuring they end in a newline, freezes the contents from change, and
	// updates the length and text of the editor to the latest
	function setContents$3(editor, contents) {
	    contents = normalizeContents$3(contents);
	    contents.freeze();
	    editor.contents = contents;
	    editor.length = contents.length();
	}
	// Combine formats removing ones that don't exist in both and creating an array for those with multiple values
	function combineFormats$3(formats, combined) {
	    return Object.keys(combined).reduce(function (merged, name) {
	        if (formats[name] == null)
	            return merged;
	        if (combined[name] === formats[name]) {
	            merged[name] = combined[name];
	        }
	        else if (Array.isArray(combined[name])) {
	            if (combined[name].indexOf(formats[name]) < 0) {
	                merged[name] = combined[name].concat([formats[name]]);
	            }
	        }
	        else {
	            merged[name] = [combined[name], formats[name]];
	        }
	        return merged;
	    }, {});
	}
	var isMac$2 = navigator.userAgent.indexOf('Macintosh') !== -1;

	var indexOf = [].indexOf;
	/**
	 * Get the position and size of a range as it is displayed in the DOM relative to the top left of visible document.
	 * You can use `getBounds(editor.selection)` to find the coordinates of the current selection and display a popup at
	 * that location.
	 */
	function getBounds(root, paper, range) {
	    return getBoudingBrowserRange(root, paper, range).getBoundingClientRect();
	}
	function getBoudingBrowserRange(root, paper, range) {
	    var browserRange = getBrowserRange(root, paper, range);
	    if (browserRange.endContainer.nodeType === Node.ELEMENT_NODE) {
	        try {
	            browserRange.setEnd(browserRange.endContainer, browserRange.endOffset + 1);
	        }
	        catch (e) { }
	    }
	    return browserRange;
	}
	// Get a browser range object for the given editor range tuple
	function getBrowserRange(root, paper, range) {
	    if (range[0] > range[1])
	        range = [range[1], range[0]];
	    var _a = getNodesForRange(root, paper, range), anchorNode = _a[0], anchorOffset = _a[1], focusNode = _a[2], focusOffset = _a[3];
	    var browserRange = document.createRange();
	    if (anchorNode && focusNode) {
	        browserRange.setStart(anchorNode, anchorOffset);
	        browserRange.setEnd(focusNode, focusOffset);
	    }
	    return browserRange;
	}
	// Get the browser nodes and offsets for the range (a tuple of indexes) of this view
	function getNodesForRange(root, paper, range) {
	    if (range == null) {
	        return [null, 0, null, 0];
	    }
	    else {
	        var _a = getNodeAndOffset(root, paper, range[0]), anchorNode = _a[0], anchorOffset = _a[1];
	        var _b = range[0] === range[1] ?
	            [anchorNode, anchorOffset] : getNodeAndOffset(root, paper, range[1]), focusNode = _b[0], focusOffset = _b[1];
	        return [anchorNode, anchorOffset, focusNode, focusOffset];
	    }
	}
	function getNodeAndOffset(root, paper, index) {
	    var inDom = root.ownerDocument.contains(root);
	    var blocks = paper.blocks, embeds = paper.embeds;
	    var walker = root.ownerDocument.createTreeWalker(root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, {
	        acceptNode: inDom ? acceptNodeInDom$1 : acceptNode$1
	    });
	    var count = 0, node, firstBlockSeen = false;
	    walker.currentNode = root;
	    while ((node = walker.nextNode())) {
	        if (node.nodeType === Node.TEXT_NODE) {
	            var size = node.nodeValue.length;
	            if (index <= count + size)
	                return [node, index - count];
	            count += size;
	        }
	        else if (node.className.indexOf('decorator') !== -1) {
	            continue;
	        }
	        else if (embeds.matches(node) && !isBRPlaceholder$1(paper, node)) {
	            count += 1;
	            // If the selection lands after this embed, and the next node isn't a text node, place the selection
	            var next = nextNonEmptyTextSibling(node);
	            if (count === index && (!next || next.nodeType !== Node.TEXT_NODE)) {
	                return [node.parentNode, indexOf.call(node.parentNode.childNodes, node) + 1];
	            }
	        }
	        else if (blocks.matches(node)) {
	            if (firstBlockSeen)
	                count += 1;
	            else
	                firstBlockSeen = true;
	            // If the selection lands at the beginning of a block, and the first node isn't a text node, place the selection
	            if (count === index) {
	                var first = firstNonEmptyTextChild(node);
	                if (!first)
	                    return [node, 0];
	                else if (first.nodeType !== Node.TEXT_NODE)
	                    return [node, indexOf.call(node.childNodes, first)];
	            }
	        }
	    }
	    return [null, 0];
	}
	function acceptNode$1(node) {
	    if (node.nodeType === Node.TEXT_NODE) {
	        return node.nodeValue.length ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
	    }
	    return NodeFilter.FILTER_REJECT;
	}
	function acceptNodeInDom$1(node) {
	    if (node.nodeType === Node.TEXT_NODE) {
	        return node.nodeValue.length ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
	    }
	    return NodeFilter.FILTER_ACCEPT;
	}
	function firstNonEmptyTextChild(parent) {
	    var node = parent.firstChild;
	    if (!node)
	        return null;
	    while (node && node.nodeValue === '') {
	        node = node.nextSibling;
	    }
	    return node;
	}
	function nextNonEmptyTextSibling(node) {
	    var nextSibling = node.nextSibling;
	    while (nextSibling && nextSibling.nodeValue === '') {
	        nextSibling = nextSibling.nextSibling;
	    }
	    return nextSibling;
	}

	/* src/ui/HoverMenu.svelte generated by Svelte v3.0.0-beta.21 */

	function add_css() {
		var style = internal_13$1("style");
		style.id = 'svelte-195m8fr-style';
		style.textContent = "@import url(https://fonts.googleapis.com/icon?family=Material+Icons);.menu.svelte-195m8fr{position:absolute;background-image:linear-gradient(to bottom, rgba(49, 49, 47, .99), #262625);border-radius:.25rem;opacity:0;z-index:10000;margin-top:-7px;white-space:nowrap}.menu.active.svelte-195m8fr{opacity:1;animation:svelte-195m8fr-pop-upwards 180ms forwards linear;transition:top 75ms ease-out, left 75ms ease-out}.menu.svelte-195m8fr::after{content:'';position:absolute;bottom:-13px;left:50%;margin-left:-7px;border:7px solid transparent;border-top-color:#262625}button.svelte-195m8fr{height:42px;line-height:42px;vertical-align:middle;border:none;padding:0 8px;margin:0;color:#fff;background:none;outline:none;cursor:pointer}button.svelte-195m8fr:first-child{padding-left:14px}button.svelte-195m8fr:last-child{padding-right:14px}button.active.svelte-195m8fr{color:#74b6ff}button[disabled].svelte-195m8fr{opacity:.5;cursor:default}.typewriter-icon.svelte-195m8fr{display:inline-block;font-family:'Material Icons';font-weight:normal;font-style:normal;font-size:24px;line-height:inherit;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:'liga';-webkit-font-smoothing:antialiased}.typewriter-icon.typewriter-bold.svelte-195m8fr::before{content:'\\E238'}.typewriter-icon.typewriter-italic.svelte-195m8fr::before{content:'\\E23F'}.typewriter-icon.typewriter-link.svelte-195m8fr::before{content:'\\E250'}.typewriter-icon.typewriter-heading1.svelte-195m8fr::before{content:'\\E264'}.typewriter-icon.typewriter-heading2.svelte-195m8fr::before{font-size:.75em;content:'\\E264'}.typewriter-icon.typewriter-blockquote.svelte-195m8fr::before{content:'\\E244'}.typewriter-separator.svelte-195m8fr{display:inline-block;vertical-align:middle;width:1px;margin:0 6px;height:24px;background:rgba(0, 0, 0, .2);box-shadow:1px 0 rgba(255, 255, 255, .2)}@keyframes svelte-195m8fr-pop-upwards{0%{transform:matrix(.97, 0, 0, 1, 0, 12);opacity:0\n    }20%{transform:matrix(.99, 0, 0, 1, 0, 2);opacity:.7\n    }40%{transform:matrix(1, 0, 0, 1, 0, -1);opacity:1\n    }70%{transform:matrix(1, 0, 0, 1, 0, 0);opacity:1\n    }100%{transform:matrix(1, 0, 0, 1, 0, 0);opacity:1\n    }}.link-input.svelte-195m8fr{position:absolute;top:0;width:100%;height:100%}.link-input.svelte-195m8fr input.svelte-195m8fr{width:100%;height:100%;background:none;border:none;color:#f7f7f9;padding:10px 24px 10px 12px;font-size:.875rem;outline:none;box-sizing:border-box}.link-input.svelte-195m8fr .close.svelte-195m8fr{position:absolute;right:12px;top:10px;color:#f7f7f9;opacity:.5}.link-input.svelte-195m8fr .close.svelte-195m8fr:hover{color:#f7f7f9;opacity:1}.menu.svelte-195m8fr:not(.input-mode) .link-input.svelte-195m8fr{display:none}.menu.input-mode.svelte-195m8fr .items.svelte-195m8fr{opacity:0}";
		internal_6$1(document.head, style);
	}

	function get_each_context(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.item = list[i];
		return child_ctx;
	}

	// (13:6) {:else}
	function create_else_block(ctx) {
		var div;

		return {
			c() {
				div = internal_13$1("div");
				div.className = "typewriter-separator svelte-195m8fr";
			},

			m(target, anchor) {
				internal_7$1(target, div, anchor);
			},

			p: internal_81$1,

			d(detaching) {
				if (detaching) {
					internal_8$1(div);
				}
			}
		};
	}

	// (9:6) {#if item}
	function create_if_block(ctx) {
		var button, i, i_class_value, button_class_value, button_disabled_value, dispose;

		function click_handler() {
			return ctx.click_handler(ctx);
		}

		return {
			c() {
				button = internal_13$1("button");
				i = internal_13$1("i");
				i.className = i_class_value = "typewriter-icon typewriter-" + (ctx.item.icon || ctx.item.name) + " svelte-195m8fr";
				button.className = button_class_value = "editor-menu-" + ctx.item.name + " svelte-195m8fr";
				button.disabled = button_disabled_value = ctx.item.disabled;
				internal_39$1(button, "active", ctx.item.active);
				dispose = internal_18$1(button, "click", click_handler);
			},

			m(target, anchor) {
				internal_7$1(target, button, anchor);
				internal_6$1(button, i);
			},

			p(changed, new_ctx) {
				ctx = new_ctx;
				if ((changed.items) && i_class_value !== (i_class_value = "typewriter-icon typewriter-" + (ctx.item.icon || ctx.item.name) + " svelte-195m8fr")) {
					i.className = i_class_value;
				}

				if ((changed.items) && button_class_value !== (button_class_value = "editor-menu-" + ctx.item.name + " svelte-195m8fr")) {
					button.className = button_class_value;
				}

				if ((changed.items) && button_disabled_value !== (button_disabled_value = ctx.item.disabled)) {
					button.disabled = button_disabled_value;
				}

				if ((changed.items || changed.items)) {
					internal_39$1(button, "active", ctx.item.active);
				}
			},

			d(detaching) {
				if (detaching) {
					internal_8$1(button);
				}

				dispose();
			}
		};
	}

	// (8:4) {#each items as item}
	function create_each_block(ctx) {
		var if_block_anchor;

		function select_block_type(ctx) {
			if (ctx.item) return create_if_block;
			return create_else_block;
		}

		var current_block_type = select_block_type(ctx);
		var if_block = current_block_type(ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = internal_17$1();
			},

			m(target, anchor) {
				if_block.m(target, anchor);
				internal_7$1(target, if_block_anchor, anchor);
			},

			p(changed, ctx) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);
					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},

			d(detaching) {
				if_block.d(detaching);

				if (detaching) {
					internal_8$1(if_block_anchor);
				}
			}
		};
	}

	function create_fragment(ctx) {
		var div2, div0, t0, div1, input_1, t1, i, dispose;

		var each_value = ctx.items;

		var each_blocks = [];

		for (var i_1 = 0; i_1 < each_value.length; i_1 += 1) {
			each_blocks[i_1] = create_each_block(get_each_context(ctx, each_value, i_1));
		}

		return {
			c() {
				div2 = internal_13$1("div");
				div0 = internal_13$1("div");

				for (var i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
					each_blocks[i_1].c();
				}

				t0 = internal_16$1();
				div1 = internal_13$1("div");
				input_1 = internal_13$1("input");
				t1 = internal_16$1();
				i = internal_13$1("i");
				i.textContent = "×";
				div0.className = "items svelte-195m8fr";
				input_1.placeholder = "https://example.com/";
				input_1.className = "svelte-195m8fr";
				i.className = "close svelte-195m8fr";
				div1.className = "link-input svelte-195m8fr";
				internal_33$1(div2, "top", "" + ctx.pos.top + "px");
				internal_33$1(div2, "left", "" + ctx.pos.left + "px");
				div2.className = "menu svelte-195m8fr";
				internal_39$1(div2, "active", ctx.active);
				internal_39$1(div2, "input-mode", ctx.inputMode);

				dispose = [
					internal_18$1(input_1, "input", ctx.input_1_input_handler),
					internal_18$1(input_1, "keydown", ctx.onKeyDown),
					internal_18$1(input_1, "blur", ctx.createLink),
					internal_18$1(i, "click", ctx.exitInput)
				];
			},

			m(target, anchor) {
				internal_7$1(target, div2, anchor);
				internal_6$1(div2, div0);

				for (var i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
					each_blocks[i_1].m(div0, null);
				}

				internal_6$1(div2, t0);
				internal_6$1(div2, div1);
				internal_6$1(div1, input_1);

				input_1.value = ctx.href;

				internal_62$1(() => ctx.input_1_binding(input_1, null));
				internal_6$1(div1, t1);
				internal_6$1(div1, i);
				internal_62$1(() => ctx.div2_binding(div2, null));
			},

			p(changed, ctx) {
				if (changed.items) {
					each_value = ctx.items;

					for (var i_1 = 0; i_1 < each_value.length; i_1 += 1) {
						const child_ctx = get_each_context(ctx, each_value, i_1);

						if (each_blocks[i_1]) {
							each_blocks[i_1].p(changed, child_ctx);
						} else {
							each_blocks[i_1] = create_each_block(child_ctx);
							each_blocks[i_1].c();
							each_blocks[i_1].m(div0, null);
						}
					}

					for (; i_1 < each_blocks.length; i_1 += 1) {
						each_blocks[i_1].d(1);
					}
					each_blocks.length = each_value.length;
				}

				if (changed.href) input_1.value = ctx.href;
				if (changed.items) {
					ctx.input_1_binding(null, input_1);
					ctx.input_1_binding(input_1, null);
				}
				if (changed.items) {
					ctx.div2_binding(null, div2);
					ctx.div2_binding(div2, null);
				}

				if (changed.pos) {
					internal_33$1(div2, "top", "" + ctx.pos.top + "px");
					internal_33$1(div2, "left", "" + ctx.pos.left + "px");
				}

				if (changed.active) {
					internal_39$1(div2, "active", ctx.active);
				}

				if (changed.inputMode) {
					internal_39$1(div2, "input-mode", ctx.inputMode);
				}
			},

			i: internal_81$1,
			o: internal_81$1,

			d(detaching) {
				if (detaching) {
					internal_8$1(div2);
				}

				internal_12$1(each_blocks, detaching);

				ctx.input_1_binding(null, input_1);
				ctx.div2_binding(null, div2);
				internal_88$1(dispose);
			}
		};
	}

	const SOURCE_USER$1$2 = 'user';

	function onClick(item) {
	if (item.action) {
	  item.action(item);
	}
	}

	function instance($$self, $$props, $$invalidate) {
		
	let menu;
	let { items = [], editor = null, root = null, paper = null, range = null, active = false, inputMode = false, pos = { left: 0, top: 0 }, href = '' } = $$props;
	let input;

	function reposition() {
	  if (!root || !range) {
	    pos = { top: -100000, left: -100000 }; $$invalidate('pos', pos);
	  } else {
	    if (!menu.offsetParent) return; // Removed from DOM
	    const container = menu.offsetParent.getBoundingClientRect();
	    const targetRect = getBounds(root, paper, range);
	    pos = {
	      top: targetRect.top - container.top - menu.offsetHeight,
	      left: targetRect.left - container.left + targetRect.width / 2 - menu.offsetWidth / 2,
	    }; $$invalidate('pos', pos);
	  }
	}

	function exitInput() {
	  inputMode = false; $$invalidate('inputMode', inputMode);
	  href = ''; $$invalidate('href', href);
	  root.focus();
	}

	function createLink() {
	  href = href.trim(); $$invalidate('href', href);
	  if (href) {
	    editor.formatText(range, { link: href }, SOURCE_USER$1$2);
	  }
	  exitInput();
	}

	function onKeyDown(event) {
	  if (event.keyCode === 27) {
	    event.preventDefault();
	    exitInput();
	  } else if (event.keyCode === 13) {
	    event.preventDefault();
	    createLink();
	  }
	}

	// Actions

	function inputLink() {
	  inputMode = true; $$invalidate('inputMode', inputMode);
	  href = ''; $$invalidate('href', href);
	  input.focus();
	}

	function onMarkClick(item) {
	  editor.toggleTextFormat(range, { [item.name]: true }, SOURCE_USER$1$2);
	  // Re-calculate the position of the menu
	  range = range.slice(); $$invalidate('range', range);
	}

	function onBlockClick(item) {
	  editor.toggleLineFormat(range, { [item.name]: item.value || true }, SOURCE_USER$1$2);
	  // Re-calculate the position of the menu
	  range = range.slice(); $$invalidate('range', range);
	}

	function onLinkClick() {
	  if (editor.getTextFormat(range).link) {
	    editor.formatText(range, { link: null }, SOURCE_USER$1$2);
	  } else {
	    inputLink();
	  }
	}

		function click_handler({ item }) {
			return onClick(item);
		}

		function input_1_input_handler() {
			href = this.value;
			$$invalidate('href', href);
		}

		function input_1_binding($$node, check) {
			input = $$node;
			$$invalidate('input', input);
		}

		function div2_binding($$node, check) {
			menu = $$node;
			$$invalidate('menu', menu);
		}

		$$self.$set = $$props => {
			if ('items' in $$props) $$invalidate('items', items = $$props.items);
			if ('editor' in $$props) $$invalidate('editor', editor = $$props.editor);
			if ('root' in $$props) $$invalidate('root', root = $$props.root);
			if ('paper' in $$props) $$invalidate('paper', paper = $$props.paper);
			if ('range' in $$props) $$invalidate('range', range = $$props.range);
			if ('active' in $$props) $$invalidate('active', active = $$props.active);
			if ('inputMode' in $$props) $$invalidate('inputMode', inputMode = $$props.inputMode);
			if ('pos' in $$props) $$invalidate('pos', pos = $$props.pos);
			if ('href' in $$props) $$invalidate('href', href = $$props.href);
		};

		$$self.$$.update = ($$dirty = { menu: 1, root: 1, range: 1, paper: 1, editor: 1, items: 1 }) => {
			if ($$dirty.menu || $$dirty.root || $$dirty.range) {
				if (menu && root && range) reposition();
			}
			if ($$dirty.paper || $$dirty.editor || $$dirty.range || $$dirty.items) {
	      items = []; $$invalidate('items', items);
	    
	      if (paper) {
	        const { blocks, marks } = paper;
	        const { header, blockquote } = blocks.types;
	        const { bold, italic, link } = marks.types;
	        const format = editor.getFormat(range);
	    
	        if (bold) {
	          items.push({
	            name: 'bold',
	            active: format.bold,
	            action: onMarkClick
	          });
	        }
	    
	        if (italic) {
	          items.push({
	            name: 'italic',
	            active: format.italic,
	            action: onMarkClick
	          });
	        }
	    
	        if (link) {
	          items.push({
	            name: 'link',
	            active: format.link,
	            action: onLinkClick
	          });
	        }
	    
	        if (items.length && (header || blockquote)) {
	          items.push(null);
	        }
	    
	        if (header) {
	          items.push({
	            name: 'header',
	            icon: 'heading1',
	            active: format.header === 2,
	            action: onBlockClick,
	            value: 2
	          }, {
	            name: 'header',
	            icon: 'heading2',
	            active: format.header === 3,
	            action: onBlockClick,
	            value: 3
	          });
	        }
	    
	        if (blockquote) {
	          items.push({
	            name: 'blockquote',
	            active: format.blockquote,
	            action: onBlockClick
	          });
	        }
	      }
	    }
		};

		return {
			menu,
			items,
			editor,
			root,
			paper,
			range,
			active,
			inputMode,
			pos,
			href,
			input,
			exitInput,
			createLink,
			onKeyDown,
			click_handler,
			input_1_input_handler,
			input_1_binding,
			div2_binding
		};
	}

	class HoverMenu extends internal_101$1 {
		constructor(options) {
			super();
			if (!document.getElementById("svelte-195m8fr-style")) add_css();
			internal_100$1(this, options, instance, create_fragment, internal_91$1, ["items", "editor", "root", "paper", "range", "active", "inputMode", "pos", "href"]);
		}

		get items() {
			return this.$$.ctx.items;
		}

		set items(items) {
			this.$set({ items });
			internal_63$1();
		}

		get editor() {
			return this.$$.ctx.editor;
		}

		set editor(editor) {
			this.$set({ editor });
			internal_63$1();
		}

		get root() {
			return this.$$.ctx.root;
		}

		set root(root) {
			this.$set({ root });
			internal_63$1();
		}

		get paper() {
			return this.$$.ctx.paper;
		}

		set paper(paper) {
			this.$set({ paper });
			internal_63$1();
		}

		get range() {
			return this.$$.ctx.range;
		}

		set range(range) {
			this.$set({ range });
			internal_63$1();
		}

		get active() {
			return this.$$.ctx.active;
		}

		set active(active) {
			this.$set({ active });
			internal_63$1();
		}

		get inputMode() {
			return this.$$.ctx.inputMode;
		}

		set inputMode(inputMode) {
			this.$set({ inputMode });
			internal_63$1();
		}

		get pos() {
			return this.$$.ctx.pos;
		}

		set pos(pos) {
			this.$set({ pos });
			internal_63$1();
		}

		get href() {
			return this.$$.ctx.href;
		}

		set href(href) {
			this.$set({ href });
			internal_63$1();
		}
	}

	function hoverMenu() {
	    return function (editor, root, paper) {
	        var menu = null, mousedown = false;
	        function show(range) {
	            if (range === void 0) { range = editor.selection; }
	            if (!menu) {
	                menu = new HoverMenu({
	                    target: root.parentNode,
	                    props: { editor: editor, root: root, paper: paper, range: range }
	                });
	                if (menu.items.length) {
	                    requestAnimationFrame(function () { return menu && (menu.active = true); });
	                }
	            }
	            else {
	                menu.range = range;
	            }
	        }
	        function hide() {
	            if (menu) {
	                menu.$destroy();
	                menu = null;
	            }
	        }
	        function update() {
	            var selection = editor.selection;
	            var validSelection = selection && selection[0] !== selection[1];
	            var inputMode = menu && menu.inputMode;
	            if (!validSelection || !root.contentEditable) {
	                if (!inputMode)
	                    hide();
	                return;
	            }
	            show();
	        }
	        function onEditorChange() {
	            if (!mousedown)
	                update();
	        }
	        function onMouseDown() {
	            root.ownerDocument.addEventListener('mouseup', onMouseUp);
	            mousedown = true;
	        }
	        function onMouseUp() {
	            mousedown = false;
	            setTimeout(update);
	        }
	        editor.on('editor-change', onEditorChange);
	        root.addEventListener('mousedown', onMouseDown);
	        return {
	            show: show,
	            hide: hide,
	            onDestroy: function () {
	                editor.off('editor-change', onEditorChange);
	                root.removeEventListener('mousedown', onMouseDown);
	                root.ownerDocument.removeEventListener('mouseup', onMouseUp);
	                hide();
	            }
	        };
	    };
	}

	/* src/Frame.svelte generated by Svelte v3.0.0-beta.21 */

	function create_fragment$1(ctx) {
		var iframe;

		return {
			c() {
				iframe = internal_13("iframe");
				iframe.title = true;
				iframe.className = "svelte-10vbnox";
			},

			m(target, anchor) {
				internal_7(target, iframe, anchor);
				internal_62(() => ctx.iframe_binding(iframe, null));
			},

			p(changed, ctx) {
				if (changed.items) {
					ctx.iframe_binding(null, iframe);
					ctx.iframe_binding(iframe, null);
				}
			},

			i: internal_81,
			o: internal_81,

			d(detaching) {
				if (detaching) {
					internal_8(iframe);
				}

				ctx.iframe_binding(null, iframe);
			}
		};
	}

	function instance$1($$self, $$props, $$invalidate) {
		let frame;
	let win;
	let doc;
	let head;
	let body;
	let content;
	let component;
	let props;

	function loadHandler() {
	  win = frame.contentWindow; $$invalidate('win', win);
	  doc = frame.contentDocument; $$invalidate('doc', doc);
	  head = doc.head; $$invalidate('head', head);
	  body = doc.body; $$invalidate('body', body);

	  doc.insertBefore(document.doctype.cloneNode(true), doc.documentElement);

	  const style = doc.createElement('style');
	  style.innerText = `html,body {
    background: none !important;
    margin: 0 !important;
    padding: 0px !important;
    overflow: hidden !important;
    height: 100% !important;
  }`;
	  head.appendChild(style);

	  Array.from(document.querySelectorAll('style, link[rel="stylesheet"]'))
	    .forEach(node => head.appendChild(node.cloneNode(true)));

	  if (component) {
	    content = new component({ target: body, props }); $$invalidate('content', content);
	  }
	}

		function iframe_binding($$node, check) {
			frame = $$node;
			$$invalidate('frame', frame);
		}

		$$self.$set = $$new_props => {
			$$invalidate('$$props', $$props = internal_83(internal_83({}, $$props), $$new_props));
		};

		$$self.$$.update = ($$dirty = { component: 1, props: 1, $$props: 1, content: 1, frame: 1 }) => {
			if ($$dirty.component || $$dirty.props || $$dirty.content) {
	      ({ component, ...props } = $$props); $$invalidate('component', component); $$invalidate('props', props);
	      if (content) content.set(props);
	    }
			if ($$dirty.frame) {
				if (frame) {
	      frame.addEventListener('load', loadHandler);
	      if (frame.contentDocument.readyState === 'complete' && frame.contentDocument.defaultView) {
	        loadHandler();
	      } else {
	        frame.addEventListener('load', loadHandler);
	      }
	    }
			}
		};

		return {
			frame,
			iframe_binding,
			$$props: $$props = internal_97($$props)
		};
	}

	class Frame extends internal_101 {
		constructor(options) {
			super();
			internal_100(this, options, instance$1, create_fragment$1, internal_90, []);
		}
	}

	var svelte$1 = createCommonjsModule(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });





	exports.onMount = internal.onMount;
	exports.onDestroy = internal.onDestroy;
	exports.beforeUpdate = internal.beforeUpdate;
	exports.afterUpdate = internal.afterUpdate;
	exports.setContext = internal.setContext;
	exports.getContext = internal.getContext;
	exports.tick = internal.tick;
	exports.createEventDispatcher = internal.createEventDispatcher;
	});

	unwrapExports(svelte$1);
	var svelte_1$1 = svelte$1.onMount;
	var svelte_2$1 = svelte$1.onDestroy;
	var svelte_3$1 = svelte$1.beforeUpdate;
	var svelte_4$1 = svelte$1.afterUpdate;
	var svelte_5$1 = svelte$1.setContext;
	var svelte_6$1 = svelte$1.getContext;
	var svelte_7$1 = svelte$1.tick;
	var svelte_8$1 = svelte$1.createEventDispatcher;

	function unwrapExports$2 (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
	}

	function createCommonjsModule$2(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var internal$2 = createCommonjsModule$2(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });

	function noop() {}

	const identity = x => x;

	function assign(tar, src) {
		for (const k in src) tar[k] = src[k];
		return tar;
	}

	function is_promise(value) {
		return value && typeof value.then === 'function';
	}

	function add_location(element, file, line, column, char) {
		element.__svelte_meta = {
			loc: { file, line, column, char }
		};
	}

	function run(fn) {
		return fn();
	}

	function blank_object() {
		return Object.create(null);
	}

	function run_all(fns) {
		fns.forEach(run);
	}

	function is_function(thing) {
		return typeof thing === 'function';
	}

	function safe_not_equal(a, b) {
		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function not_equal(a, b) {
		return a != a ? b == b : a !== b;
	}

	function validate_store(store, name) {
		if (!store || typeof store.subscribe !== 'function') {
			throw new Error(`'${name}' is not a store with a 'subscribe' method`);
		}
	}

	function subscribe(component, store, callback) {
		component.$$.on_destroy.push(store.subscribe(callback));
	}

	function create_slot(definition, ctx, fn) {
		if (definition) {
			const slot_ctx = get_slot_context(definition, ctx, fn);
			return definition[0](slot_ctx);
		}
	}

	function get_slot_context(definition, ctx, fn) {
		return definition[1]
			? assign({}, assign(ctx.$$scope.ctx, definition[1](fn ? fn(ctx) : {})))
			: ctx.$$scope.ctx;
	}

	function get_slot_changes(definition, ctx, changed, fn) {
		return definition[1]
			? assign({}, assign(ctx.$$scope.changed || {}, definition[1](fn ? fn(changed) : {})))
			: ctx.$$scope.changed || {};
	}

	function exclude_internal_props(props) {
		const result = {};
		for (const k in props) if (k[0] !== '$') result[k] = props[k];
		return result;
	}

	const tasks = new Set();
	let running = false;

	function run_tasks() {
		tasks.forEach(task => {
			if (!task[0](window.performance.now())) {
				tasks.delete(task);
				task[1]();
			}
		});

		running = tasks.size > 0;
		if (running) requestAnimationFrame(run_tasks);
	}

	function clear_loops() {
		// for testing...
		tasks.forEach(task => tasks.delete(task));
		running = false;
	}

	function loop(fn) {
		let task;

		if (!running) {
			running = true;
			requestAnimationFrame(run_tasks);
		}

		return {
			promise: new Promise(fulfil => {
				tasks.add(task = [fn, fulfil]);
			}),
			abort() {
				tasks.delete(task);
			}
		};
	}

	function append(target, node) {
		target.appendChild(node);
	}

	function insert(target, node, anchor) {
		target.insertBefore(node, anchor);
	}

	function detach(node) {
		node.parentNode.removeChild(node);
	}

	function detach_between(before, after) {
		while (before.nextSibling && before.nextSibling !== after) {
			before.parentNode.removeChild(before.nextSibling);
		}
	}

	function detach_before(after) {
		while (after.previousSibling) {
			after.parentNode.removeChild(after.previousSibling);
		}
	}

	function detach_after(before) {
		while (before.nextSibling) {
			before.parentNode.removeChild(before.nextSibling);
		}
	}

	function destroy_each(iterations, detaching) {
		for (let i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d(detaching);
		}
	}

	function element(name) {
		return document.createElement(name);
	}

	function svg_element(name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	}

	function text(data) {
		return document.createTextNode(data);
	}

	function space() {
		return text(' ');
	}

	function empty() {
		return text('');
	}

	function listen(node, event, handler, options) {
		node.addEventListener(event, handler, options);
		return () => node.removeEventListener(event, handler, options);
	}

	function prevent_default(fn) {
		return function(event) {
			event.preventDefault();
			return fn.call(this, event);
		};
	}

	function stop_propagation(fn) {
		return function(event) {
			event.stopPropagation();
			return fn.call(this, event);
		};
	}

	function attr(node, attribute, value) {
		if (value == null) node.removeAttribute(attribute);
		else node.setAttribute(attribute, value);
	}

	function set_attributes(node, attributes) {
		for (const key in attributes) {
			if (key === 'style') {
				node.style.cssText = attributes[key];
			} else if (key in node) {
				node[key] = attributes[key];
			} else {
				attr(node, key, attributes[key]);
			}
		}
	}

	function set_custom_element_data(node, prop, value) {
		if (prop in node) {
			node[prop] = value;
		} else {
			attr(node, prop, value);
		}
	}

	function xlink_attr(node, attribute, value) {
		node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
	}

	function get_binding_group_value(group) {
		const value = [];
		for (let i = 0; i < group.length; i += 1) {
			if (group[i].checked) value.push(group[i].__value);
		}
		return value;
	}

	function to_number(value) {
		return value === '' ? undefined : +value;
	}

	function time_ranges_to_array(ranges) {
		const array = [];
		for (let i = 0; i < ranges.length; i += 1) {
			array.push({ start: ranges.start(i), end: ranges.end(i) });
		}
		return array;
	}

	function children(element) {
		return Array.from(element.childNodes);
	}

	function claim_element(nodes, name, attributes, svg) {
		for (let i = 0; i < nodes.length; i += 1) {
			const node = nodes[i];
			if (node.nodeName === name) {
				for (let j = 0; j < node.attributes.length; j += 1) {
					const attribute = node.attributes[j];
					if (!attributes[attribute.name]) node.removeAttribute(attribute.name);
				}
				return nodes.splice(i, 1)[0]; // TODO strip unwanted attributes
			}
		}

		return svg ? svg_element(name) : element(name);
	}

	function claim_text(nodes, data) {
		for (let i = 0; i < nodes.length; i += 1) {
			const node = nodes[i];
			if (node.nodeType === 3) {
				node.data = data;
				return nodes.splice(i, 1)[0];
			}
		}

		return text(data);
	}

	function set_data(text, data) {
		text.data = '' + data;
	}

	function set_input_type(input, type) {
		try {
			input.type = type;
		} catch (e) {
			// do nothing
		}
	}

	function set_style(node, key, value) {
		node.style.setProperty(key, value);
	}

	function select_option(select, value) {
		for (let i = 0; i < select.options.length; i += 1) {
			const option = select.options[i];

			if (option.__value === value) {
				option.selected = true;
				return;
			}
		}
	}

	function select_options(select, value) {
		for (let i = 0; i < select.options.length; i += 1) {
			const option = select.options[i];
			option.selected = ~value.indexOf(option.__value);
		}
	}

	function select_value(select) {
		const selected_option = select.querySelector(':checked') || select.options[0];
		return selected_option && selected_option.__value;
	}

	function select_multiple_value(select) {
		return [].map.call(select.querySelectorAll(':checked'), option => option.__value);
	}

	function add_resize_listener(element, fn) {
		if (getComputedStyle(element).position === 'static') {
			element.style.position = 'relative';
		}

		const object = document.createElement('object');
		object.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;');
		object.type = 'text/html';

		let win;

		object.onload = () => {
			win = object.contentDocument.defaultView;
			win.addEventListener('resize', fn);
		};

		if (/Trident/.test(navigator.userAgent)) {
			element.appendChild(object);
			object.data = 'about:blank';
		} else {
			object.data = 'about:blank';
			element.appendChild(object);
		}

		return {
			cancel: () => {
				win && win.removeEventListener && win.removeEventListener('resize', fn);
				element.removeChild(object);
			}
		};
	}

	function toggle_class(element, name, toggle) {
		element.classList[toggle ? 'add' : 'remove'](name);
	}

	function custom_event(type, detail) {
		const e = document.createEvent('CustomEvent');
		e.initCustomEvent(type, false, false, detail);
		return e;
	}

	let stylesheet;
	let active = 0;
	let current_rules = {};

	// https://github.com/darkskyapp/string-hash/blob/master/index.js
	function hash(str) {
		let hash = 5381;
		let i = str.length;

		while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
		return hash >>> 0;
	}

	function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
		const step = 16.666 / duration;
		let keyframes = '{\n';

		for (let p = 0; p <= 1; p += step) {
			const t = a + (b - a) * ease(p);
			keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
		}

		const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
		const name = `__svelte_${hash(rule)}_${uid}`;

		if (!current_rules[name]) {
			if (!stylesheet) {
				const style = element('style');
				document.head.appendChild(style);
				stylesheet = style.sheet;
			}

			current_rules[name] = true;
			stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
		}

		const animation = node.style.animation || '';
		node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;

		active += 1;
		return name;
	}

	function delete_rule(node, name) {
		node.style.animation = (node.style.animation || '')
			.split(', ')
			.filter(name
				? anim => anim.indexOf(name) < 0 // remove specific animation
				: anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
			)
			.join(', ');

		if (name && !--active) clear_rules();
	}

	function clear_rules() {
		requestAnimationFrame(() => {
			if (active) return;
			let i = stylesheet.cssRules.length;
			while (i--) stylesheet.deleteRule(i);
			current_rules = {};
		});
	}

	function create_animation(node, from, fn, params) {
		if (!from) return noop;

		const to = node.getBoundingClientRect();
		if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom) return noop;

		const {
			delay = 0,
			duration = 300,
			easing = identity,
			start: start_time = window.performance.now() + delay,
			end = start_time + duration,
			tick = noop,
			css
		} = fn(node, { from, to }, params);

		let running = true;
		let started = false;
		let name;

		const css_text = node.style.cssText;

		function start() {
			if (css) {
				if (delay) node.style.cssText = css_text; // TODO create delayed animation instead?
				name = create_rule(node, 0, 1, duration, 0, easing, css);
			}

			started = true;
		}

		function stop() {
			if (css) delete_rule(node, name);
			running = false;
		}

		loop(now => {
			if (!started && now >= start_time) {
				start();
			}

			if (started && now >= end) {
				tick(1, 0);
				stop();
			}

			if (!running) {
				return false;
			}

			if (started) {
				const p = now - start_time;
				const t = 0 + 1 * easing(p / duration);
				tick(t, 1 - t);
			}

			return true;
		});

		if (delay) {
			if (css) node.style.cssText += css(0, 1);
		} else {
			start();
		}

		tick(0, 1);

		return stop;
	}

	function fix_position(node) {
		const style = getComputedStyle(node);

		if (style.position !== 'absolute' && style.position !== 'fixed') {
			const { width, height } = style;
			const a = node.getBoundingClientRect();
			node.style.position = 'absolute';
			node.style.width = width;
			node.style.height = height;
			const b = node.getBoundingClientRect();

			if (a.left !== b.left || a.top !== b.top) {
				const style = getComputedStyle(node);
				const transform = style.transform === 'none' ? '' : style.transform;

				node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;
			}
		}
	}

	function set_current_component(component) {
		exports.current_component = component;
	}

	function get_current_component() {
		if (!exports.current_component) throw new Error(`Function called outside component initialization`);
		return exports.current_component;
	}

	function beforeUpdate(fn) {
		get_current_component().$$.before_render.push(fn);
	}

	function onMount(fn) {
		get_current_component().$$.on_mount.push(fn);
	}

	function afterUpdate(fn) {
		get_current_component().$$.after_render.push(fn);
	}

	function onDestroy(fn) {
		get_current_component().$$.on_destroy.push(fn);
	}

	function createEventDispatcher() {
		const component = exports.current_component;

		return (type, detail) => {
			const callbacks = component.$$.callbacks[type];

			if (callbacks) {
				// TODO are there situations where events could be dispatched
				// in a server (non-DOM) environment?
				const event = custom_event(type, detail);
				callbacks.slice().forEach(fn => {
					fn.call(component, event);
				});
			}
		};
	}

	function setContext(key, context) {
		get_current_component().$$.context.set(key, context);
	}

	function getContext(key) {
		return get_current_component().$$.context.get(key);
	}

	// TODO figure out if we still want to support
	// shorthand events, or if we want to implement
	// a real bubbling mechanism
	function bubble(component, event) {
		const callbacks = component.$$.callbacks[event.type];

		if (callbacks) {
			callbacks.slice().forEach(fn => fn(event));
		}
	}

	const dirty_components = [];
	const intros = { enabled: false };

	let update_promise;
	const binding_callbacks = [];
	const render_callbacks = [];

	function schedule_update() {
		if (!update_promise) {
			update_promise = Promise.resolve();
			update_promise.then(flush);
		}
	}

	function add_render_callback(fn) {
		render_callbacks.push(fn);
	}

	function tick() {
		schedule_update();
		return update_promise;
	}

	function add_binding_callback(fn) {
		binding_callbacks.push(fn);
	}

	function flush() {
		const seen_callbacks = new Set();

		do {
			// first, call beforeUpdate functions
			// and update components
			while (dirty_components.length) {
				const component = dirty_components.shift();
				set_current_component(component);
				update(component.$$);
			}

			while (binding_callbacks.length) binding_callbacks.shift()();

			// then, once components are updated, call
			// afterUpdate functions. This may cause
			// subsequent updates...
			while (render_callbacks.length) {
				const callback = render_callbacks.pop();
				if (!seen_callbacks.has(callback)) {
					callback();

					// ...so guard against infinite loops
					seen_callbacks.add(callback);
				}
			}
		} while (dirty_components.length);

		update_promise = null;
	}

	function update($$) {
		if ($$.fragment) {
			$$.update($$.dirty);
			run_all($$.before_render);
			$$.fragment.p($$.dirty, $$.ctx);
			$$.dirty = null;

			$$.after_render.forEach(add_render_callback);
		}
	}

	let promise;

	function wait() {
		if (!promise) {
			promise = Promise.resolve();
			promise.then(() => {
				promise = null;
			});
		}

		return promise;
	}

	function dispatch(node, direction, kind) {
		node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
	}

	let outros;

	function group_outros() {
		outros = {
			remaining: 0,
			callbacks: []
		};
	}

	function check_outros() {
		if (!outros.remaining) {
			run_all(outros.callbacks);
		}
	}

	function on_outro(callback) {
		outros.callbacks.push(callback);
	}

	function create_in_transition(node, fn, params) {
		let config = fn(node, params);
		let running = false;
		let animation_name;
		let task;
		let uid = 0;

		function cleanup() {
			if (animation_name) delete_rule(node, animation_name);
		}

		function go() {
			const {
				delay = 0,
				duration = 300,
				easing = identity,
				tick: tick$$1 = noop,
				css
			} = config;

			if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
			tick$$1(0, 1);

			const start_time = window.performance.now() + delay;
			const end_time = start_time + duration;

			if (task) task.abort();
			running = true;

			task = loop(now => {
				if (running) {
					if (now >= end_time) {
						tick$$1(1, 0);
						cleanup();
						return running = false;
					}

					if (now >= start_time) {
						const t = easing((now - start_time) / duration);
						tick$$1(t, 1 - t);
					}
				}

				return running;
			});
		}

		let started = false;

		return {
			start() {
				if (started) return;

				delete_rule(node);

				if (typeof config === 'function') {
					config = config();
					wait().then(go);
				} else {
					go();
				}
			},

			invalidate() {
				started = false;
			},

			end() {
				if (running) {
					cleanup();
					running = false;
				}
			}
		};
	}

	function create_out_transition(node, fn, params) {
		let config = fn(node, params);
		let running = true;
		let animation_name;

		const group = outros;

		group.remaining += 1;

		function go() {
			const {
				delay = 0,
				duration = 300,
				easing = identity,
				tick: tick$$1 = noop,
				css
			} = config;

			if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);

			const start_time = window.performance.now() + delay;
			const end_time = start_time + duration;

			loop(now => {
				if (running) {
					if (now >= end_time) {
						tick$$1(0, 1);

						if (!--group.remaining) {
							// this will result in `end()` being called,
							// so we don't need to clean up here
							run_all(group.callbacks);
						}

						return false;
					}

					if (now >= start_time) {
						const t = easing((now - start_time) / duration);
						tick$$1(1 - t, t);
					}
				}

				return running;
			});
		}

		if (typeof config === 'function') {
			wait().then(() => {
				config = config();
				go();
			});
		} else {
			go();
		}

		return {
			end(reset) {
				if (reset && config.tick) {
					config.tick(1, 0);
				}

				if (running) {
					if (animation_name) delete_rule(node, animation_name);
					running = false;
				}
			}
		};
	}

	function create_bidirectional_transition(node, fn, params, intro) {
		let config = fn(node, params);

		let t = intro ? 0 : 1;

		let running_program = null;
		let pending_program = null;
		let animation_name = null;

		function clear_animation() {
			if (animation_name) delete_rule(node, animation_name);
		}

		function init(program, duration) {
			const d = program.b - t;
			duration *= Math.abs(d);

			return {
				a: t,
				b: program.b,
				d,
				duration,
				start: program.start,
				end: program.start + duration,
				group: program.group
			};
		}

		function go(b) {
			const {
				delay = 0,
				duration = 300,
				easing = identity,
				tick: tick$$1 = noop,
				css
			} = config;

			const program = {
				start: window.performance.now() + delay,
				b
			};

			if (!b) {
				program.group = outros;
				outros.remaining += 1;
			}

			if (running_program) {
				pending_program = program;
			} else {
				// if this is an intro, and there's a delay, we need to do
				// an initial tick and/or apply CSS animation immediately
				if (css) {
					clear_animation();
					animation_name = create_rule(node, t, b, duration, delay, easing, css);
				}

				if (b) tick$$1(0, 1);

				running_program = init(program, duration);
				add_render_callback(() => dispatch(node, b, 'start'));

				loop(now => {
					if (pending_program && now > pending_program.start) {
						running_program = init(pending_program, duration);
						pending_program = null;

						dispatch(node, running_program.b, 'start');

						if (css) {
							clear_animation();
							animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
						}
					}

					if (running_program) {
						if (now >= running_program.end) {
							tick$$1(t = running_program.b, 1 - t);
							dispatch(node, running_program.b, 'end');

							if (!pending_program) {
								// we're done
								if (running_program.b) {
									// intro — we can tidy up immediately
									clear_animation();
								} else {
									// outro — needs to be coordinated
									if (!--running_program.group.remaining) run_all(running_program.group.callbacks);
								}
							}

							running_program = null;
						}

						else if (now >= running_program.start) {
							const p = now - running_program.start;
							t = running_program.a + running_program.d * easing(p / running_program.duration);
							tick$$1(t, 1 - t);
						}
					}

					return !!(running_program || pending_program);
				});
			}
		}

		return {
			run(b) {
				if (typeof config === 'function') {
					wait().then(() => {
						config = config();
						go(b);
					});
				} else {
					go(b);
				}
			},

			end() {
				clear_animation();
				running_program = pending_program = null;
			}
		};
	}

	function handle_promise(promise, info) {
		const token = info.token = {};

		function update(type, index, key, value) {
			if (info.token !== token) return;

			info.resolved = key && { [key]: value };

			const child_ctx = assign(assign({}, info.ctx), info.resolved);
			const block = type && (info.current = type)(child_ctx);

			if (info.block) {
				if (info.blocks) {
					info.blocks.forEach((block, i) => {
						if (i !== index && block) {
							group_outros();
							on_outro(() => {
								block.d(1);
								info.blocks[i] = null;
							});
							block.o(1);
							check_outros();
						}
					});
				} else {
					info.block.d(1);
				}

				block.c();
				if (block.i) block.i(1);
				block.m(info.mount(), info.anchor);

				flush();
			}

			info.block = block;
			if (info.blocks) info.blocks[index] = block;
		}

		if (is_promise(promise)) {
			promise.then(value => {
				update(info.then, 1, info.value, value);
			}, error => {
				update(info.catch, 2, info.error, error);
			});

			// if we previously had a then/catch block, destroy it
			if (info.current !== info.pending) {
				update(info.pending, 0);
				return true;
			}
		} else {
			if (info.current !== info.then) {
				update(info.then, 1, info.value, promise);
				return true;
			}

			info.resolved = { [info.value]: promise };
		}
	}

	function destroy_block(block, lookup) {
		block.d(1);
		lookup[block.key] = null;
	}

	function outro_and_destroy_block(block, lookup) {
		on_outro(() => {
			destroy_block(block, lookup);
		});

		block.o(1);
	}

	function fix_and_outro_and_destroy_block(block, lookup) {
		block.f();
		outro_and_destroy_block(block, lookup);
	}

	function update_keyed_each(old_blocks, changed, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
		let o = old_blocks.length;
		let n = list.length;

		let i = o;
		const old_indexes = {};
		while (i--) old_indexes[old_blocks[i].key] = i;

		const new_blocks = [];
		const new_lookup = {};
		const deltas = {};

		i = n;
		while (i--) {
			const child_ctx = get_context(ctx, list, i);
			const key = get_key(child_ctx);
			let block = lookup[key];

			if (!block) {
				block = create_each_block(key, child_ctx);
				block.c();
			} else if (dynamic) {
				block.p(changed, child_ctx);
			}

			new_blocks[i] = new_lookup[key] = block;

			if (key in old_indexes) deltas[key] = Math.abs(i - old_indexes[key]);
		}

		const will_move = {};
		const did_move = {};

		function insert(block) {
			if (block.i) block.i(1);
			block.m(node, next);
			lookup[block.key] = block;
			next = block.first;
			n--;
		}

		while (o && n) {
			const new_block = new_blocks[n - 1];
			const old_block = old_blocks[o - 1];
			const new_key = new_block.key;
			const old_key = old_block.key;

			if (new_block === old_block) {
				// do nothing
				next = new_block.first;
				o--;
				n--;
			}

			else if (!new_lookup[old_key]) {
				// remove old block
				destroy(old_block, lookup);
				o--;
			}

			else if (!lookup[new_key] || will_move[new_key]) {
				insert(new_block);
			}

			else if (did_move[old_key]) {
				o--;

			} else if (deltas[new_key] > deltas[old_key]) {
				did_move[new_key] = true;
				insert(new_block);

			} else {
				will_move[old_key] = true;
				o--;
			}
		}

		while (o--) {
			const old_block = old_blocks[o];
			if (!new_lookup[old_block.key]) destroy(old_block, lookup);
		}

		while (n) insert(new_blocks[n - 1]);

		return new_blocks;
	}

	function measure(blocks) {
		const rects = {};
		let i = blocks.length;
		while (i--) rects[blocks[i].key] = blocks[i].node.getBoundingClientRect();
		return rects;
	}

	function get_spread_update(levels, updates) {
		const update = {};

		const to_null_out = {};
		const accounted_for = {};

		let i = levels.length;
		while (i--) {
			const o = levels[i];
			const n = updates[i];

			if (n) {
				for (const key in o) {
					if (!(key in n)) to_null_out[key] = 1;
				}

				for (const key in n) {
					if (!accounted_for[key]) {
						update[key] = n[key];
						accounted_for[key] = 1;
					}
				}

				levels[i] = n;
			} else {
				for (const key in o) {
					accounted_for[key] = 1;
				}
			}
		}

		for (const key in to_null_out) {
			if (!(key in update)) update[key] = undefined;
		}

		return update;
	}

	const invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
	// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
	// https://infra.spec.whatwg.org/#noncharacter

	function spread(args) {
		const attributes = Object.assign({}, ...args);
		let str = '';

		Object.keys(attributes).forEach(name => {
			if (invalid_attribute_name_character.test(name)) return;

			const value = attributes[name];
			if (value === undefined) return;
			if (value === true) str += " " + name;

			const escaped = String(value)
				.replace(/"/g, '&#34;')
				.replace(/'/g, '&#39;');

			str += " " + name + "=" + JSON.stringify(escaped);
		});

		return str;
	}

	const escaped = {
		'"': '&quot;',
		"'": '&#39;',
		'&': '&amp;',
		'<': '&lt;',
		'>': '&gt;'
	};

	function escape(html) {
		return String(html).replace(/["'&<>]/g, match => escaped[match]);
	}

	function each(items, fn) {
		let str = '';
		for (let i = 0; i < items.length; i += 1) {
			str += fn(items[i], i);
		}
		return str;
	}

	const missing_component = {
		$$render: () => ''
	};

	function validate_component(component, name) {
		if (!component || !component.$$render) {
			if (name === 'svelte:component') name += ' this={...}';
			throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
		}

		return component;
	}

	function debug(file, line, column, values) {
		console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console
		console.log(values); // eslint-disable-line no-console
		return '';
	}

	let on_destroy;

	function create_ssr_component(fn) {
		function $$render(result, props, bindings, slots) {
			const parent_component = exports.current_component;

			const $$ = {
				on_destroy,
				context: new Map(parent_component ? parent_component.$$.context : []),

				// these will be immediately discarded
				on_mount: [],
				before_render: [],
				after_render: [],
				callbacks: blank_object()
			};

			set_current_component({ $$ });

			const html = fn(result, props, bindings, slots);

			set_current_component(parent_component);
			return html;
		}

		return {
			render: (props = {}, options = {}) => {
				on_destroy = [];

				const result = { head: '', css: new Set() };
				const html = $$render(result, props, {}, options);

				run_all(on_destroy);

				return {
					html,
					css: {
						code: Array.from(result.css).map(css => css.code).join('\n'),
						map: null // TODO
					},
					head: result.head
				};
			},

			$$render
		};
	}

	function get_store_value(store) {
		let value;
		store.subscribe(_ => value = _)();
		return value;
	}

	function bind(component, name, callback) {
		if (component.$$.props.indexOf(name) === -1) return;
		component.$$.bound[name] = callback;
		callback(component.$$.ctx[name]);
	}

	function mount_component(component, target, anchor) {
		const { fragment, on_mount, on_destroy, after_render } = component.$$;

		fragment.m(target, anchor);

		// onMount happens after the initial afterUpdate. Because
		// afterUpdate callbacks happen in reverse order (inner first)
		// we schedule onMount callbacks before afterUpdate callbacks
		add_render_callback(() => {
			const new_on_destroy = on_mount.map(run).filter(is_function);
			if (on_destroy) {
				on_destroy.push(...new_on_destroy);
			} else {
				// Edge case - component was destroyed immediately,
				// most likely as a result of a binding initialising
				run_all(new_on_destroy);
			}
			component.$$.on_mount = [];
		});

		after_render.forEach(add_render_callback);
	}

	function destroy(component, detaching) {
		if (component.$$) {
			run_all(component.$$.on_destroy);
			component.$$.fragment.d(detaching);

			// TODO null out other refs, including component.$$ (but need to
			// preserve final state?)
			component.$$.on_destroy = component.$$.fragment = null;
			component.$$.ctx = {};
		}
	}

	function make_dirty(component, key) {
		if (!component.$$.dirty) {
			dirty_components.push(component);
			schedule_update();
			component.$$.dirty = {};
		}
		component.$$.dirty[key] = true;
	}

	function init(component, options, instance, create_fragment, not_equal$$1, prop_names) {
		const parent_component = exports.current_component;
		set_current_component(component);

		const props = options.props || {};

		const $$ = component.$$ = {
			fragment: null,
			ctx: null,

			// state
			props: prop_names,
			update: noop,
			not_equal: not_equal$$1,
			bound: blank_object(),

			// lifecycle
			on_mount: [],
			on_destroy: [],
			before_render: [],
			after_render: [],
			context: new Map(parent_component ? parent_component.$$.context : []),

			// everything else
			callbacks: blank_object(),
			dirty: null
		};

		let ready = false;

		$$.ctx = instance
			? instance(component, props, (key, value) => {
				if ($$.bound[key]) $$.bound[key](value);

				if ($$.ctx) {
					const changed = not_equal$$1(value, $$.ctx[key]);
					if (ready && changed) {
						make_dirty(component, key);
					}

					$$.ctx[key] = value;
					return changed;
				}
			})
			: props;

		$$.update();
		ready = true;
		run_all($$.before_render);
		$$.fragment = create_fragment($$.ctx);

		if (options.target) {
			if (options.hydrate) {
				$$.fragment.l(children(options.target));
			} else {
				$$.fragment.c();
			}

			if (options.intro && component.$$.fragment.i) component.$$.fragment.i();
			mount_component(component, options.target, options.anchor);
			flush();
		}

		set_current_component(parent_component);
	}
	if (typeof HTMLElement !== 'undefined') {
		exports.SvelteElement = class extends HTMLElement {
			constructor() {
				super();
				this.attachShadow({ mode: 'open' });
			}

			connectedCallback() {
				for (const key in this.$$.slotted) {
					this.appendChild(this.$$.slotted[key]);
				}
			}

			attributeChangedCallback(attr$$1, oldValue, newValue) {
				this[attr$$1] = newValue;
			}

			$destroy() {
				destroy(this, true);
				this.$destroy = noop;
			}

			$on(type, callback) {
				// TODO should this delegate to addEventListener?
				const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
				callbacks.push(callback);

				return () => {
					const index = callbacks.indexOf(callback);
					if (index !== -1) callbacks.splice(index, 1);
				};
			}

			$set() {
				// overridden by instance, if it has props
			}
		};
	}

	class SvelteComponent {
		$destroy() {
			destroy(this, true);
			this.$destroy = noop;
		}

		$on(type, callback) {
			const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
			callbacks.push(callback);

			return () => {
				const index = callbacks.indexOf(callback);
				if (index !== -1) callbacks.splice(index, 1);
			};
		}

		$set() {
			// overridden by instance, if it has props
		}
	}

	class SvelteComponentDev extends SvelteComponent {
		constructor(options) {
			if (!options || (!options.target && !options.$$inline)) {
				throw new Error(`'target' is a required option`);
			}

			super();
		}

		$destroy() {
			super.$destroy();
			this.$destroy = () => {
				console.warn(`Component was already destroyed`); // eslint-disable-line no-console
			};
		}
	}

	exports.create_animation = create_animation;
	exports.fix_position = fix_position;
	exports.handle_promise = handle_promise;
	exports.append = append;
	exports.insert = insert;
	exports.detach = detach;
	exports.detach_between = detach_between;
	exports.detach_before = detach_before;
	exports.detach_after = detach_after;
	exports.destroy_each = destroy_each;
	exports.element = element;
	exports.svg_element = svg_element;
	exports.text = text;
	exports.space = space;
	exports.empty = empty;
	exports.listen = listen;
	exports.prevent_default = prevent_default;
	exports.stop_propagation = stop_propagation;
	exports.attr = attr;
	exports.set_attributes = set_attributes;
	exports.set_custom_element_data = set_custom_element_data;
	exports.xlink_attr = xlink_attr;
	exports.get_binding_group_value = get_binding_group_value;
	exports.to_number = to_number;
	exports.time_ranges_to_array = time_ranges_to_array;
	exports.children = children;
	exports.claim_element = claim_element;
	exports.claim_text = claim_text;
	exports.set_data = set_data;
	exports.set_input_type = set_input_type;
	exports.set_style = set_style;
	exports.select_option = select_option;
	exports.select_options = select_options;
	exports.select_value = select_value;
	exports.select_multiple_value = select_multiple_value;
	exports.add_resize_listener = add_resize_listener;
	exports.toggle_class = toggle_class;
	exports.custom_event = custom_event;
	exports.destroy_block = destroy_block;
	exports.outro_and_destroy_block = outro_and_destroy_block;
	exports.fix_and_outro_and_destroy_block = fix_and_outro_and_destroy_block;
	exports.update_keyed_each = update_keyed_each;
	exports.measure = measure;
	exports.set_current_component = set_current_component;
	exports.beforeUpdate = beforeUpdate;
	exports.onMount = onMount;
	exports.afterUpdate = afterUpdate;
	exports.onDestroy = onDestroy;
	exports.createEventDispatcher = createEventDispatcher;
	exports.setContext = setContext;
	exports.getContext = getContext;
	exports.bubble = bubble;
	exports.clear_loops = clear_loops;
	exports.loop = loop;
	exports.dirty_components = dirty_components;
	exports.intros = intros;
	exports.schedule_update = schedule_update;
	exports.add_render_callback = add_render_callback;
	exports.tick = tick;
	exports.add_binding_callback = add_binding_callback;
	exports.flush = flush;
	exports.get_spread_update = get_spread_update;
	exports.invalid_attribute_name_character = invalid_attribute_name_character;
	exports.spread = spread;
	exports.escaped = escaped;
	exports.escape = escape;
	exports.each = each;
	exports.missing_component = missing_component;
	exports.validate_component = validate_component;
	exports.debug = debug;
	exports.create_ssr_component = create_ssr_component;
	exports.get_store_value = get_store_value;
	exports.group_outros = group_outros;
	exports.check_outros = check_outros;
	exports.on_outro = on_outro;
	exports.create_in_transition = create_in_transition;
	exports.create_out_transition = create_out_transition;
	exports.create_bidirectional_transition = create_bidirectional_transition;
	exports.noop = noop;
	exports.identity = identity;
	exports.assign = assign;
	exports.is_promise = is_promise;
	exports.add_location = add_location;
	exports.run = run;
	exports.blank_object = blank_object;
	exports.run_all = run_all;
	exports.is_function = is_function;
	exports.safe_not_equal = safe_not_equal;
	exports.not_equal = not_equal;
	exports.validate_store = validate_store;
	exports.subscribe = subscribe;
	exports.create_slot = create_slot;
	exports.get_slot_context = get_slot_context;
	exports.get_slot_changes = get_slot_changes;
	exports.exclude_internal_props = exclude_internal_props;
	exports.bind = bind;
	exports.mount_component = mount_component;
	exports.init = init;
	exports.SvelteComponent = SvelteComponent;
	exports.SvelteComponentDev = SvelteComponentDev;
	});

	unwrapExports$2(internal$2);
	var internal_1$2 = internal$2.current_component;
	var internal_2$2 = internal$2.SvelteElement;
	var internal_3$2 = internal$2.create_animation;
	var internal_4$2 = internal$2.fix_position;
	var internal_5$2 = internal$2.handle_promise;
	var internal_6$2 = internal$2.append;
	var internal_7$2 = internal$2.insert;
	var internal_8$2 = internal$2.detach;
	var internal_9$2 = internal$2.detach_between;
	var internal_10$2 = internal$2.detach_before;
	var internal_11$2 = internal$2.detach_after;
	var internal_12$2 = internal$2.destroy_each;
	var internal_13$2 = internal$2.element;
	var internal_14$2 = internal$2.svg_element;
	var internal_15$2 = internal$2.text;
	var internal_16$2 = internal$2.space;
	var internal_17$2 = internal$2.empty;
	var internal_18$2 = internal$2.listen;
	var internal_19$2 = internal$2.prevent_default;
	var internal_20$2 = internal$2.stop_propagation;
	var internal_21$2 = internal$2.attr;
	var internal_22$2 = internal$2.set_attributes;
	var internal_23$2 = internal$2.set_custom_element_data;
	var internal_24$2 = internal$2.xlink_attr;
	var internal_25$2 = internal$2.get_binding_group_value;
	var internal_26$2 = internal$2.to_number;
	var internal_27$2 = internal$2.time_ranges_to_array;
	var internal_28$2 = internal$2.children;
	var internal_29$2 = internal$2.claim_element;
	var internal_30$2 = internal$2.claim_text;
	var internal_31$2 = internal$2.set_data;
	var internal_32$2 = internal$2.set_input_type;
	var internal_33$2 = internal$2.set_style;
	var internal_34$2 = internal$2.select_option;
	var internal_35$2 = internal$2.select_options;
	var internal_36$2 = internal$2.select_value;
	var internal_37$2 = internal$2.select_multiple_value;
	var internal_38$2 = internal$2.add_resize_listener;
	var internal_39$2 = internal$2.toggle_class;
	var internal_40$2 = internal$2.custom_event;
	var internal_41$2 = internal$2.destroy_block;
	var internal_42$2 = internal$2.outro_and_destroy_block;
	var internal_43$2 = internal$2.fix_and_outro_and_destroy_block;
	var internal_44$2 = internal$2.update_keyed_each;
	var internal_45$2 = internal$2.measure;
	var internal_46$2 = internal$2.set_current_component;
	var internal_47$2 = internal$2.beforeUpdate;
	var internal_48$2 = internal$2.onMount;
	var internal_49$2 = internal$2.afterUpdate;
	var internal_50$2 = internal$2.onDestroy;
	var internal_51$2 = internal$2.createEventDispatcher;
	var internal_52$2 = internal$2.setContext;
	var internal_53$2 = internal$2.getContext;
	var internal_54$2 = internal$2.bubble;
	var internal_55$2 = internal$2.clear_loops;
	var internal_56$2 = internal$2.loop;
	var internal_57$2 = internal$2.dirty_components;
	var internal_58$2 = internal$2.intros;
	var internal_59$2 = internal$2.schedule_update;
	var internal_60$2 = internal$2.add_render_callback;
	var internal_61$2 = internal$2.tick;
	var internal_62$2 = internal$2.add_binding_callback;
	var internal_63$2 = internal$2.flush;
	var internal_64$2 = internal$2.get_spread_update;
	var internal_65$2 = internal$2.invalid_attribute_name_character;
	var internal_66$2 = internal$2.spread;
	var internal_67$2 = internal$2.escaped;
	var internal_68$2 = internal$2.escape;
	var internal_69$2 = internal$2.each;
	var internal_70$2 = internal$2.missing_component;
	var internal_71$2 = internal$2.validate_component;
	var internal_72$2 = internal$2.debug;
	var internal_73$2 = internal$2.create_ssr_component;
	var internal_74$2 = internal$2.get_store_value;
	var internal_75$2 = internal$2.group_outros;
	var internal_76$2 = internal$2.check_outros;
	var internal_77$2 = internal$2.on_outro;
	var internal_78$2 = internal$2.create_in_transition;
	var internal_79$2 = internal$2.create_out_transition;
	var internal_80$2 = internal$2.create_bidirectional_transition;
	var internal_81$2 = internal$2.noop;
	var internal_82$2 = internal$2.identity;
	var internal_83$2 = internal$2.assign;
	var internal_84$2 = internal$2.is_promise;
	var internal_85$2 = internal$2.add_location;
	var internal_86$2 = internal$2.run;
	var internal_87$2 = internal$2.blank_object;
	var internal_88$2 = internal$2.run_all;
	var internal_89$2 = internal$2.is_function;
	var internal_90$2 = internal$2.safe_not_equal;
	var internal_91$2 = internal$2.not_equal;
	var internal_92$2 = internal$2.validate_store;
	var internal_93$2 = internal$2.subscribe;
	var internal_94$2 = internal$2.create_slot;
	var internal_95$2 = internal$2.get_slot_context;
	var internal_96$2 = internal$2.get_slot_changes;
	var internal_97$2 = internal$2.exclude_internal_props;
	var internal_98$2 = internal$2.bind;
	var internal_99$2 = internal$2.mount_component;
	var internal_100$2 = internal$2.init;
	var internal_101$2 = internal$2.SvelteComponent;
	var internal_102$2 = internal$2.SvelteComponentDev;

	var svelte$2 = createCommonjsModule$2(function (module, exports) {

	Object.defineProperty(exports, '__esModule', { value: true });





	exports.onMount = internal$2.onMount;
	exports.onDestroy = internal$2.onDestroy;
	exports.beforeUpdate = internal$2.beforeUpdate;
	exports.afterUpdate = internal$2.afterUpdate;
	exports.setContext = internal$2.setContext;
	exports.getContext = internal$2.getContext;
	exports.tick = internal$2.tick;
	exports.createEventDispatcher = internal$2.createEventDispatcher;
	});

	unwrapExports$2(svelte$2);
	var svelte_1$2 = svelte$2.onMount;
	var svelte_2$2 = svelte$2.onDestroy;
	var svelte_3$2 = svelte$2.beforeUpdate;
	var svelte_4$2 = svelte$2.afterUpdate;
	var svelte_5$2 = svelte$2.setContext;
	var svelte_6$2 = svelte$2.getContext;
	var svelte_7$2 = svelte$2.tick;
	var svelte_8$2 = svelte$2.createEventDispatcher;

	/* src/components/InlineContents.svelte generated by Svelte v3.0.0-beta.21 */

	function get_each_context$1(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.child = list[i];
		return child_ctx;
	}

	// (4:2) {:else}
	function create_else_block$1(ctx) {
		var switch_instance_anchor, current;

		var switch_value = ctx.child.component;

		function switch_props(ctx) {
			return {
				props: {
				attrs: ctx.child.attrs,
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
			};
		}

		if (switch_value) {
			var switch_instance = new switch_value(switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) switch_instance.$$.fragment.c();
				switch_instance_anchor = internal_17$2();
			},

			m(target, anchor) {
				if (switch_instance) {
					internal_99$2(switch_instance, target, anchor);
				}

				internal_7$2(target, switch_instance_anchor, anchor);
				current = true;
			},

			p(changed, ctx) {
				var switch_instance_changes = {};
				if (changed.children) switch_instance_changes.attrs = ctx.child.attrs;
				if (changed.children) switch_instance_changes.$$scope = { changed, ctx };

				if (switch_value !== (switch_value = ctx.child.component)) {
					if (switch_instance) {
						internal_75$2();
						const old_component = switch_instance;
						internal_77$2(() => {
							old_component.$destroy();
						});
						old_component.$$.fragment.o(1);
						internal_76$2();
					}

					if (switch_value) {
						switch_instance = new switch_value(switch_props(ctx));

						switch_instance.$$.fragment.c();
						switch_instance.$$.fragment.i(1);
						internal_99$2(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				}

				else if (switch_value) {
					switch_instance.$set(switch_instance_changes);
				}
			},

			i(local) {
				if (current) return;
				if (switch_instance) switch_instance.$$.fragment.i(local);

				current = true;
			},

			o(local) {
				if (switch_instance) switch_instance.$$.fragment.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(switch_instance_anchor);
				}

				if (switch_instance) switch_instance.$destroy(detaching);
			}
		};
	}

	// (2:2) {#if typeof child === 'string'}
	function create_if_block$1(ctx) {
		var t_value = ctx.child, t;

		return {
			c() {
				t = internal_15$2(t_value);
			},

			m(target, anchor) {
				internal_7$2(target, t, anchor);
			},

			p(changed, ctx) {
				if ((changed.children) && t_value !== (t_value = ctx.child)) {
					internal_31$2(t, t_value);
				}
			},

			i: internal_81$2,
			o: internal_81$2,

			d(detaching) {
				if (detaching) {
					internal_8$2(t);
				}
			}
		};
	}

	// (5:63) {#if child.children}
	function create_if_block_1(ctx) {
		var current;

		var inlinecontents = new InlineContents({ props: { children: ctx.child.children } });

		return {
			c() {
				inlinecontents.$$.fragment.c();
			},

			m(target, anchor) {
				internal_99$2(inlinecontents, target, anchor);
				current = true;
			},

			p(changed, ctx) {
				var inlinecontents_changes = {};
				if (changed.children) inlinecontents_changes.children = ctx.child.children;
				inlinecontents.$set(inlinecontents_changes);
			},

			i(local) {
				if (current) return;
				inlinecontents.$$.fragment.i(local);

				current = true;
			},

			o(local) {
				inlinecontents.$$.fragment.o(local);
				current = false;
			},

			d(detaching) {
				inlinecontents.$destroy(detaching);
			}
		};
	}

	// (5:2) <svelte:component this={child.component} attrs={child.attrs}>
	function create_default_slot(ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.child.children) && create_if_block_1(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = internal_17$2();
			},

			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				internal_7$2(target, if_block_anchor, anchor);
				current = true;
			},

			p(changed, ctx) {
				if (ctx.child.children) {
					if (if_block) {
						if_block.p(changed, ctx);
						if_block.i(1);
					} else {
						if_block = create_if_block_1(ctx);
						if_block.c();
						if_block.i(1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					internal_75$2();
					internal_77$2(() => {
						if_block.d(1);
						if_block = null;
					});

					if_block.o(1);
					internal_76$2();
				}
			},

			i(local) {
				if (current) return;
				if (if_block) if_block.i();
				current = true;
			},

			o(local) {
				if (if_block) if_block.o();
				current = false;
			},

			d(detaching) {
				if (if_block) if_block.d(detaching);

				if (detaching) {
					internal_8$2(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#each children as child}
	function create_each_block$1(ctx) {
		var current_block_type_index, if_block, if_block_anchor, current;

		var if_block_creators = [
			create_if_block$1,
			create_else_block$1
		];

		var if_blocks = [];

		function select_block_type(ctx) {
			if (typeof ctx.child === 'string') return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = internal_17$2();
			},

			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				internal_7$2(target, if_block_anchor, anchor);
				current = true;
			},

			p(changed, ctx) {
				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);
				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(changed, ctx);
				} else {
					internal_75$2();
					internal_77$2(() => {
						if_blocks[previous_block_index].d(1);
						if_blocks[previous_block_index] = null;
					});
					if_block.o(1);
					internal_76$2();

					if_block = if_blocks[current_block_type_index];
					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}
					if_block.i(1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},

			i(local) {
				if (current) return;
				if (if_block) if_block.i();
				current = true;
			},

			o(local) {
				if (if_block) if_block.o();
				current = false;
			},

			d(detaching) {
				if_blocks[current_block_type_index].d(detaching);

				if (detaching) {
					internal_8$2(if_block_anchor);
				}
			}
		};
	}

	function create_fragment$2(ctx) {
		var each_1_anchor, current;

		var each_value = ctx.children;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
		}

		function outro_block(i, detaching, local) {
			if (each_blocks[i]) {
				if (detaching) {
					internal_77$2(() => {
						each_blocks[i].d(detaching);
						each_blocks[i] = null;
					});
				}

				each_blocks[i].o(local);
			}
		}

		return {
			c() {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = internal_17$2();
			},

			m(target, anchor) {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(target, anchor);
				}

				internal_7$2(target, each_1_anchor, anchor);
				current = true;
			},

			p(changed, ctx) {
				if (changed.children) {
					each_value = ctx.children;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$1(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
							each_blocks[i].i(1);
						} else {
							each_blocks[i] = create_each_block$1(child_ctx);
							each_blocks[i].c();
							each_blocks[i].i(1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					internal_75$2();
					for (; i < each_blocks.length; i += 1) outro_block(i, 1, 1);
					internal_76$2();
				}
			},

			i(local) {
				if (current) return;
				for (var i = 0; i < each_value.length; i += 1) each_blocks[i].i();

				current = true;
			},

			o(local) {
				each_blocks = each_blocks.filter(Boolean);
				for (let i = 0; i < each_blocks.length; i += 1) outro_block(i, 0);

				current = false;
			},

			d(detaching) {
				internal_12$2(each_blocks, detaching);

				if (detaching) {
					internal_8$2(each_1_anchor);
				}
			}
		};
	}

	function instance$2($$self, $$props, $$invalidate) {
		let { children } = $$props;

		$$self.$set = $$props => {
			if ('children' in $$props) $$invalidate('children', children = $$props.children);
		};

		return { children };
	}

	class InlineContents extends internal_101$2 {
		constructor(options) {
			super();
			internal_100$2(this, options, instance$2, create_fragment$2, internal_91$2, ["children"]);
		}
	}

	/* src/components/Br.svelte generated by Svelte v3.0.0-beta.21 */

	function create_fragment$1$1(ctx) {
		var br;

		return {
			c() {
				br = internal_13$2("br");
			},

			m(target, anchor) {
				internal_7$2(target, br, anchor);
			},

			p: internal_81$2,
			i: internal_81$2,
			o: internal_81$2,

			d(detaching) {
				if (detaching) {
					internal_8$2(br);
				}
			}
		};
	}

	class Br extends internal_101$2 {
		constructor(options) {
			super();
			internal_100$2(this, options, null, create_fragment$1$1, internal_91$2, []);
		}
	}

	/* src/components/Paragraph.svelte generated by Svelte v3.0.0-beta.21 */

	function create_fragment$2$1(ctx) {
		var p, current;

		const default_slot_1 = ctx.$$slots.default;
		const default_slot = internal_94$2(default_slot_1, ctx, null);

		return {
			c() {
				p = internal_13$2("p");

				if (default_slot) default_slot.c();
			},

			l(nodes) {
				if (default_slot) default_slot.l(p_nodes);
			},

			m(target, anchor) {
				internal_7$2(target, p, anchor);

				if (default_slot) {
					default_slot.m(p, null);
				}

				current = true;
			},

			p(changed, ctx) {
				if (default_slot && default_slot.p && changed.$$scope) {
					default_slot.p(internal_96$2(default_slot_1, ctx, changed,), internal_95$2(default_slot_1, ctx, null));
				}
			},

			i(local) {
				if (current) return;
				if (default_slot && default_slot.i) default_slot.i(local);
				current = true;
			},

			o(local) {
				if (default_slot && default_slot.o) default_slot.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(p);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	function instance$1$1($$self, $$props, $$invalidate) {
		let { $$slots = {}, $$scope } = $$props;

		$$self.$set = $$props => {
			if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
		};

		return { $$slots, $$scope };
	}

	class Paragraph extends internal_101$2 {
		constructor(options) {
			super();
			internal_100$2(this, options, instance$1$1, create_fragment$2$1, internal_91$2, []);
		}
	}

	/* src/components/Header.svelte generated by Svelte v3.0.0-beta.21 */

	// (11:40) 
	function create_if_block_5(ctx) {
		var h6, current;

		const default_slot_1 = ctx.$$slots.default;
		const default_slot = internal_94$2(default_slot_1, ctx, null);

		return {
			c() {
				h6 = internal_13$2("h6");

				if (default_slot) default_slot.c();
			},

			l(nodes) {
				if (default_slot) default_slot.l(h6_nodes);
			},

			m(target, anchor) {
				internal_7$2(target, h6, anchor);

				if (default_slot) {
					default_slot.m(h6, null);
				}

				current = true;
			},

			p(changed, ctx) {
				if (default_slot && default_slot.p && changed.$$scope) {
					default_slot.p(internal_96$2(default_slot_1, ctx, changed,), internal_95$2(default_slot_1, ctx, null));
				}
			},

			i(local) {
				if (current) return;
				if (default_slot && default_slot.i) default_slot.i(local);
				current = true;
			},

			o(local) {
				if (default_slot && default_slot.o) default_slot.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(h6);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	// (9:40) 
	function create_if_block_4(ctx) {
		var h5, current;

		const default_slot_1 = ctx.$$slots.default;
		const default_slot = internal_94$2(default_slot_1, ctx, null);

		return {
			c() {
				h5 = internal_13$2("h5");

				if (default_slot) default_slot.c();
			},

			l(nodes) {
				if (default_slot) default_slot.l(h5_nodes);
			},

			m(target, anchor) {
				internal_7$2(target, h5, anchor);

				if (default_slot) {
					default_slot.m(h5, null);
				}

				current = true;
			},

			p(changed, ctx) {
				if (default_slot && default_slot.p && changed.$$scope) {
					default_slot.p(internal_96$2(default_slot_1, ctx, changed,), internal_95$2(default_slot_1, ctx, null));
				}
			},

			i(local) {
				if (current) return;
				if (default_slot && default_slot.i) default_slot.i(local);
				current = true;
			},

			o(local) {
				if (default_slot && default_slot.o) default_slot.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(h5);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	// (7:40) 
	function create_if_block_3(ctx) {
		var h4, current;

		const default_slot_1 = ctx.$$slots.default;
		const default_slot = internal_94$2(default_slot_1, ctx, null);

		return {
			c() {
				h4 = internal_13$2("h4");

				if (default_slot) default_slot.c();
			},

			l(nodes) {
				if (default_slot) default_slot.l(h4_nodes);
			},

			m(target, anchor) {
				internal_7$2(target, h4, anchor);

				if (default_slot) {
					default_slot.m(h4, null);
				}

				current = true;
			},

			p(changed, ctx) {
				if (default_slot && default_slot.p && changed.$$scope) {
					default_slot.p(internal_96$2(default_slot_1, ctx, changed,), internal_95$2(default_slot_1, ctx, null));
				}
			},

			i(local) {
				if (current) return;
				if (default_slot && default_slot.i) default_slot.i(local);
				current = true;
			},

			o(local) {
				if (default_slot && default_slot.o) default_slot.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(h4);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	// (5:40) 
	function create_if_block_2(ctx) {
		var h3, current;

		const default_slot_1 = ctx.$$slots.default;
		const default_slot = internal_94$2(default_slot_1, ctx, null);

		return {
			c() {
				h3 = internal_13$2("h3");

				if (default_slot) default_slot.c();
			},

			l(nodes) {
				if (default_slot) default_slot.l(h3_nodes);
			},

			m(target, anchor) {
				internal_7$2(target, h3, anchor);

				if (default_slot) {
					default_slot.m(h3, null);
				}

				current = true;
			},

			p(changed, ctx) {
				if (default_slot && default_slot.p && changed.$$scope) {
					default_slot.p(internal_96$2(default_slot_1, ctx, changed,), internal_95$2(default_slot_1, ctx, null));
				}
			},

			i(local) {
				if (current) return;
				if (default_slot && default_slot.i) default_slot.i(local);
				current = true;
			},

			o(local) {
				if (default_slot && default_slot.o) default_slot.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(h3);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	// (3:40) 
	function create_if_block_1$1(ctx) {
		var h2, current;

		const default_slot_1 = ctx.$$slots.default;
		const default_slot = internal_94$2(default_slot_1, ctx, null);

		return {
			c() {
				h2 = internal_13$2("h2");

				if (default_slot) default_slot.c();
			},

			l(nodes) {
				if (default_slot) default_slot.l(h2_nodes);
			},

			m(target, anchor) {
				internal_7$2(target, h2, anchor);

				if (default_slot) {
					default_slot.m(h2, null);
				}

				current = true;
			},

			p(changed, ctx) {
				if (default_slot && default_slot.p && changed.$$scope) {
					default_slot.p(internal_96$2(default_slot_1, ctx, changed,), internal_95$2(default_slot_1, ctx, null));
				}
			},

			i(local) {
				if (current) return;
				if (default_slot && default_slot.i) default_slot.i(local);
				current = true;
			},

			o(local) {
				if (default_slot && default_slot.o) default_slot.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(h2);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	// (1:0) {#if block.attributes.header === 1}
	function create_if_block$1$1(ctx) {
		var h1, current;

		const default_slot_1 = ctx.$$slots.default;
		const default_slot = internal_94$2(default_slot_1, ctx, null);

		return {
			c() {
				h1 = internal_13$2("h1");

				if (default_slot) default_slot.c();
			},

			l(nodes) {
				if (default_slot) default_slot.l(h1_nodes);
			},

			m(target, anchor) {
				internal_7$2(target, h1, anchor);

				if (default_slot) {
					default_slot.m(h1, null);
				}

				current = true;
			},

			p(changed, ctx) {
				if (default_slot && default_slot.p && changed.$$scope) {
					default_slot.p(internal_96$2(default_slot_1, ctx, changed,), internal_95$2(default_slot_1, ctx, null));
				}
			},

			i(local) {
				if (current) return;
				if (default_slot && default_slot.i) default_slot.i(local);
				current = true;
			},

			o(local) {
				if (default_slot && default_slot.o) default_slot.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(h1);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	function create_fragment$3(ctx) {
		var current_block_type_index, if_block, if_block_anchor, current;

		var if_block_creators = [
			create_if_block$1$1,
			create_if_block_1$1,
			create_if_block_2,
			create_if_block_3,
			create_if_block_4,
			create_if_block_5
		];

		var if_blocks = [];

		function select_block_type(ctx) {
			if (ctx.block.attributes.header === 1) return 0;
			if (ctx.block.attributes.header === 2) return 1;
			if (ctx.block.attributes.header === 3) return 2;
			if (ctx.block.attributes.header === 4) return 3;
			if (ctx.block.attributes.header === 5) return 4;
			if (ctx.block.attributes.header === 6) return 5;
			return -1;
		}

		if (~(current_block_type_index = select_block_type(ctx))) {
			if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = internal_17$2();
			},

			m(target, anchor) {
				if (~current_block_type_index) if_blocks[current_block_type_index].m(target, anchor);
				internal_7$2(target, if_block_anchor, anchor);
				current = true;
			},

			p(changed, ctx) {
				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);
				if (current_block_type_index === previous_block_index) {
					if (~current_block_type_index) if_blocks[current_block_type_index].p(changed, ctx);
				} else {
					if (if_block) {
						internal_75$2();
						internal_77$2(() => {
							if_blocks[previous_block_index].d(1);
							if_blocks[previous_block_index] = null;
						});
						if_block.o(1);
						internal_76$2();
					}

					if (~current_block_type_index) {
						if_block = if_blocks[current_block_type_index];
						if (!if_block) {
							if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block.c();
						}
						if_block.i(1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					} else {
						if_block = null;
					}
				}
			},

			i(local) {
				if (current) return;
				if (if_block) if_block.i();
				current = true;
			},

			o(local) {
				if (if_block) if_block.o();
				current = false;
			},

			d(detaching) {
				if (~current_block_type_index) if_blocks[current_block_type_index].d(detaching);

				if (detaching) {
					internal_8$2(if_block_anchor);
				}
			}
		};
	}

	function instance$2$1($$self, $$props, $$invalidate) {
		let { block } = $$props;

		let { $$slots = {}, $$scope } = $$props;

		$$self.$set = $$props => {
			if ('block' in $$props) $$invalidate('block', block = $$props.block);
			if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
		};

		return { block, $$slots, $$scope };
	}

	class Header extends internal_101$2 {
		constructor(options) {
			super();
			internal_100$2(this, options, instance$2$1, create_fragment$3, internal_91$2, ["block"]);
		}
	}

	/* src/components/ListContents.svelte generated by Svelte v3.0.0-beta.21 */

	const get_default_slot_changes_2 = ({ block }) => ({ block: block });
	const get_default_slot_context_2 = ({ block }) => ({ block: block });

	const get_default_slot_changes_1 = ({ block }) => ({ block: block });
	const get_default_slot_context_1 = ({ block }) => ({ block: block });

	const get_default_slot_changes = ({ item, child }) => ({ block: item });
	const get_default_slot_context = ({ item, child }) => ({ block: child });

	function get_each_context$1$1(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.child = list[i];
		child_ctx.i = i;
		return child_ctx;
	}

	// (4:33) 
	function create_if_block_2$1(ctx) {
		var current;

		var listcontainer = new ListContainer({
			props: {
			item: ctx.child,
			$$slots: {
			default: [create_default_slot_1, ({ block }) => ({ block })]
		},
			$$scope: { ctx }
		}
		});

		return {
			c() {
				listcontainer.$$.fragment.c();
			},

			m(target, anchor) {
				internal_99$2(listcontainer, target, anchor);
				current = true;
			},

			p(changed, ctx) {
				var listcontainer_changes = {};
				if (changed.item) listcontainer_changes.item = ctx.child;
				listcontainer.$set(listcontainer_changes);
			},

			i(local) {
				if (current) return;
				listcontainer.$$.fragment.i(local);

				current = true;
			},

			o(local) {
				listcontainer.$$.fragment.o(local);
				current = false;
			},

			d(detaching) {
				listcontainer.$destroy(detaching);
			}
		};
	}

	// (2:2) {#if child.contents}
	function create_if_block$2(ctx) {
		var li, current;

		const default_slot_1 = ctx.$$slots.default;
		const default_slot = internal_94$2(default_slot_1, ctx, get_default_slot_context);

		var if_block = (ctx.item.children[ctx.i + 1] && ctx.item.children[ctx.i + 1].list) && create_if_block_1$2(ctx);

		return {
			c() {
				li = internal_13$2("li");

				if (default_slot) default_slot.c();
				if (if_block) if_block.c();
			},

			l(nodes) {
				if (default_slot) default_slot.l(li_nodes);
			},

			m(target, anchor) {
				internal_7$2(target, li, anchor);

				if (default_slot) {
					default_slot.m(li, null);
				}

				if (if_block) if_block.m(li, null);
				current = true;
			},

			p(changed, ctx) {
				if (default_slot && default_slot.p && (changed.$$scope || changed.item)) {
					default_slot.p(internal_96$2(default_slot_1, ctx, changed, get_default_slot_changes), internal_95$2(default_slot_1, ctx, get_default_slot_context));
				}

				if (ctx.item.children[ctx.i + 1] && ctx.item.children[ctx.i + 1].list) {
					if (if_block) {
						if_block.p(changed, ctx);
						if_block.i(1);
					} else {
						if_block = create_if_block_1$2(ctx);
						if_block.c();
						if_block.i(1);
						if_block.m(li, null);
					}
				} else if (if_block) {
					internal_75$2();
					internal_77$2(() => {
						if_block.d(1);
						if_block = null;
					});

					if_block.o(1);
					internal_76$2();
				}
			},

			i(local) {
				if (current) return;
				if (default_slot && default_slot.i) default_slot.i(local);
				if (if_block) if_block.i();
				current = true;
			},

			o(local) {
				if (default_slot && default_slot.o) default_slot.o(local);
				if (if_block) if_block.o();
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(li);
				}

				if (default_slot) default_slot.d(detaching);
				if (if_block) if_block.d();
			}
		};
	}

	// (5:2) <ListContainer item={child} let:block>
	function create_default_slot_1(ctx) {
		var current;

		const default_slot_1 = ctx.$$slots.default;
		const default_slot = internal_94$2(default_slot_1, ctx, get_default_slot_context_2);

		return {
			c() {
				if (default_slot) default_slot.c();
			},

			l(nodes) {
				if (default_slot) default_slot.l(nodes);
			},

			m(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},

			p(changed, ctx) {
				if (default_slot && default_slot.p && (changed.$$scope || changed.block)) {
					default_slot.p(internal_96$2(default_slot_1, ctx, changed, get_default_slot_changes_2), internal_95$2(default_slot_1, ctx, get_default_slot_context_2));
				}
			},

			i(local) {
				if (current) return;
				if (default_slot && default_slot.i) default_slot.i(local);
				current = true;
			},

			o(local) {
				if (default_slot && default_slot.o) default_slot.o(local);
				current = false;
			},

			d(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	// (3:33) {#if item.children[i + 1] && item.children[i + 1].list}
	function create_if_block_1$2(ctx) {
		var current;

		var listcontainer = new ListContainer({
			props: {
			item: ctx.item.children[ctx.i + 1],
			$$slots: {
			default: [create_default_slot$1, ({ block }) => ({ block })]
		},
			$$scope: { ctx }
		}
		});

		return {
			c() {
				listcontainer.$$.fragment.c();
			},

			m(target, anchor) {
				internal_99$2(listcontainer, target, anchor);
				current = true;
			},

			p(changed, ctx) {
				var listcontainer_changes = {};
				if (changed.item) listcontainer_changes.item = ctx.item.children[ctx.i + 1];
				listcontainer.$set(listcontainer_changes);
			},

			i(local) {
				if (current) return;
				listcontainer.$$.fragment.i(local);

				current = true;
			},

			o(local) {
				listcontainer.$$.fragment.o(local);
				current = false;
			},

			d(detaching) {
				listcontainer.$destroy(detaching);
			}
		};
	}

	// (3:88) <ListContainer item={item.children[i + 1]} let:block>
	function create_default_slot$1(ctx) {
		var current;

		const default_slot_1 = ctx.$$slots.default;
		const default_slot = internal_94$2(default_slot_1, ctx, get_default_slot_context_1);

		return {
			c() {
				if (default_slot) default_slot.c();
			},

			l(nodes) {
				if (default_slot) default_slot.l(nodes);
			},

			m(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},

			p(changed, ctx) {
				if (default_slot && default_slot.p && (changed.$$scope || changed.block)) {
					default_slot.p(internal_96$2(default_slot_1, ctx, changed, get_default_slot_changes_1), internal_95$2(default_slot_1, ctx, get_default_slot_context_1));
				}
			},

			i(local) {
				if (current) return;
				if (default_slot && default_slot.i) default_slot.i(local);
				current = true;
			},

			o(local) {
				if (default_slot && default_slot.o) default_slot.o(local);
				current = false;
			},

			d(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	// (1:0) {#each item.children as child, i}
	function create_each_block$1$1(ctx) {
		var current_block_type_index, if_block, if_block_anchor, current;

		var if_block_creators = [
			create_if_block$2,
			create_if_block_2$1
		];

		var if_blocks = [];

		function select_block_type(ctx) {
			if (ctx.child.contents) return 0;
			if (ctx.child.list && ctx.i == 0) return 1;
			return -1;
		}

		if (~(current_block_type_index = select_block_type(ctx))) {
			if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = internal_17$2();
			},

			m(target, anchor) {
				if (~current_block_type_index) if_blocks[current_block_type_index].m(target, anchor);
				internal_7$2(target, if_block_anchor, anchor);
				current = true;
			},

			p(changed, ctx) {
				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);
				if (current_block_type_index === previous_block_index) {
					if (~current_block_type_index) if_blocks[current_block_type_index].p(changed, ctx);
				} else {
					if (if_block) {
						internal_75$2();
						internal_77$2(() => {
							if_blocks[previous_block_index].d(1);
							if_blocks[previous_block_index] = null;
						});
						if_block.o(1);
						internal_76$2();
					}

					if (~current_block_type_index) {
						if_block = if_blocks[current_block_type_index];
						if (!if_block) {
							if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block.c();
						}
						if_block.i(1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					} else {
						if_block = null;
					}
				}
			},

			i(local) {
				if (current) return;
				if (if_block) if_block.i();
				current = true;
			},

			o(local) {
				if (if_block) if_block.o();
				current = false;
			},

			d(detaching) {
				if (~current_block_type_index) if_blocks[current_block_type_index].d(detaching);

				if (detaching) {
					internal_8$2(if_block_anchor);
				}
			}
		};
	}

	function create_fragment$4(ctx) {
		var each_1_anchor, current;

		var each_value = ctx.item.children;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$1$1(get_each_context$1$1(ctx, each_value, i));
		}

		function outro_block(i, detaching, local) {
			if (each_blocks[i]) {
				if (detaching) {
					internal_77$2(() => {
						each_blocks[i].d(detaching);
						each_blocks[i] = null;
					});
				}

				each_blocks[i].o(local);
			}
		}

		return {
			c() {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = internal_17$2();
			},

			m(target, anchor) {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(target, anchor);
				}

				internal_7$2(target, each_1_anchor, anchor);
				current = true;
			},

			p(changed, ctx) {
				if (changed.item || changed.$$scope) {
					each_value = ctx.item.children;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$1$1(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
							each_blocks[i].i(1);
						} else {
							each_blocks[i] = create_each_block$1$1(child_ctx);
							each_blocks[i].c();
							each_blocks[i].i(1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					internal_75$2();
					for (; i < each_blocks.length; i += 1) outro_block(i, 1, 1);
					internal_76$2();
				}
			},

			i(local) {
				if (current) return;
				for (var i = 0; i < each_value.length; i += 1) each_blocks[i].i();

				current = true;
			},

			o(local) {
				each_blocks = each_blocks.filter(Boolean);
				for (let i = 0; i < each_blocks.length; i += 1) outro_block(i, 0);

				current = false;
			},

			d(detaching) {
				internal_12$2(each_blocks, detaching);

				if (detaching) {
					internal_8$2(each_1_anchor);
				}
			}
		};
	}

	function instance$3($$self, $$props, $$invalidate) {
		let { item } = $$props;

		let { $$slots = {}, $$scope } = $$props;

		$$self.$set = $$props => {
			if ('item' in $$props) $$invalidate('item', item = $$props.item);
			if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
		};

		return { item, $$slots, $$scope };
	}

	class ListContents extends internal_101$2 {
		constructor(options) {
			super();
			internal_100$2(this, options, instance$3, create_fragment$4, internal_91$2, ["item"]);
		}
	}

	/* src/components/ListContainer.svelte generated by Svelte v3.0.0-beta.21 */

	const get_default_slot_changes_1$1 = ({ block }) => ({ block: block });
	const get_default_slot_context_1$1 = ({ block }) => ({ block: block });

	const get_default_slot_changes$1 = ({ block }) => ({ block: block });
	const get_default_slot_context$1 = ({ block }) => ({ block: block });

	// (3:0) {:else}
	function create_else_block$1$1(ctx) {
		var ul, current;

		var listcontents = new ListContents({
			props: {
			item: ctx.item,
			$$slots: {
			default: [create_default_slot_1$1, ({ block }) => ({ block })]
		},
			$$scope: { ctx }
		}
		});

		return {
			c() {
				ul = internal_13$2("ul");
				listcontents.$$.fragment.c();
			},

			m(target, anchor) {
				internal_7$2(target, ul, anchor);
				internal_99$2(listcontents, ul, null);
				current = true;
			},

			p(changed, ctx) {
				var listcontents_changes = {};
				if (changed.item) listcontents_changes.item = ctx.item;
				listcontents.$set(listcontents_changes);
			},

			i(local) {
				if (current) return;
				listcontents.$$.fragment.i(local);

				current = true;
			},

			o(local) {
				listcontents.$$.fragment.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(ul);
				}

				listcontents.$destroy();
			}
		};
	}

	// (1:0) {#if item.list === 'ordered'}
	function create_if_block$3(ctx) {
		var ol, ol_start_value, ol_type_value, current;

		var listcontents = new ListContents({
			props: {
			item: ctx.item,
			$$slots: {
			default: [create_default_slot$2, ({ block }) => ({ block })]
		},
			$$scope: { ctx }
		}
		});

		return {
			c() {
				ol = internal_13$2("ol");
				listcontents.$$.fragment.c();
				ol.start = ol_start_value = ctx.item.start == null ? 1 : ctx.item.start;
				internal_21$2(ol, "type", ol_type_value = ctx.item.type);
			},

			m(target, anchor) {
				internal_7$2(target, ol, anchor);
				internal_99$2(listcontents, ol, null);
				current = true;
			},

			p(changed, ctx) {
				var listcontents_changes = {};
				if (changed.item) listcontents_changes.item = ctx.item;
				listcontents.$set(listcontents_changes);

				if ((!current || changed.item) && ol_start_value !== (ol_start_value = ctx.item.start == null ? 1 : ctx.item.start)) {
					ol.start = ol_start_value;
				}

				if ((!current || changed.item) && ol_type_value !== (ol_type_value = ctx.item.type)) {
					internal_21$2(ol, "type", ol_type_value);
				}
			},

			i(local) {
				if (current) return;
				listcontents.$$.fragment.i(local);

				current = true;
			},

			o(local) {
				listcontents.$$.fragment.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(ol);
				}

				listcontents.$destroy();
			}
		};
	}

	// (4:4) <ListContents {item} let:block>
	function create_default_slot_1$1(ctx) {
		var current;

		const default_slot_1 = ctx.$$slots.default;
		const default_slot = internal_94$2(default_slot_1, ctx, get_default_slot_context_1$1);

		return {
			c() {
				if (default_slot) default_slot.c();
			},

			l(nodes) {
				if (default_slot) default_slot.l(nodes);
			},

			m(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},

			p(changed, ctx) {
				if (default_slot && default_slot.p && (changed.$$scope || changed.block)) {
					default_slot.p(internal_96$2(default_slot_1, ctx, changed, get_default_slot_changes_1$1), internal_95$2(default_slot_1, ctx, get_default_slot_context_1$1));
				}
			},

			i(local) {
				if (current) return;
				if (default_slot && default_slot.i) default_slot.i(local);
				current = true;
			},

			o(local) {
				if (default_slot && default_slot.o) default_slot.o(local);
				current = false;
			},

			d(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	// (2:65) <ListContents {item} let:block>
	function create_default_slot$2(ctx) {
		var current;

		const default_slot_1 = ctx.$$slots.default;
		const default_slot = internal_94$2(default_slot_1, ctx, get_default_slot_context$1);

		return {
			c() {
				if (default_slot) default_slot.c();
			},

			l(nodes) {
				if (default_slot) default_slot.l(nodes);
			},

			m(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},

			p(changed, ctx) {
				if (default_slot && default_slot.p && (changed.$$scope || changed.block)) {
					default_slot.p(internal_96$2(default_slot_1, ctx, changed, get_default_slot_changes$1), internal_95$2(default_slot_1, ctx, get_default_slot_context$1));
				}
			},

			i(local) {
				if (current) return;
				if (default_slot && default_slot.i) default_slot.i(local);
				current = true;
			},

			o(local) {
				if (default_slot && default_slot.o) default_slot.o(local);
				current = false;
			},

			d(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	function create_fragment$5(ctx) {
		var current_block_type_index, if_block, if_block_anchor, current;

		var if_block_creators = [
			create_if_block$3,
			create_else_block$1$1
		];

		var if_blocks = [];

		function select_block_type(ctx) {
			if (ctx.item.list === 'ordered') return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = internal_17$2();
			},

			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				internal_7$2(target, if_block_anchor, anchor);
				current = true;
			},

			p(changed, ctx) {
				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);
				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(changed, ctx);
				} else {
					internal_75$2();
					internal_77$2(() => {
						if_blocks[previous_block_index].d(1);
						if_blocks[previous_block_index] = null;
					});
					if_block.o(1);
					internal_76$2();

					if_block = if_blocks[current_block_type_index];
					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}
					if_block.i(1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},

			i(local) {
				if (current) return;
				if (if_block) if_block.i();
				current = true;
			},

			o(local) {
				if (if_block) if_block.o();
				current = false;
			},

			d(detaching) {
				if_blocks[current_block_type_index].d(detaching);

				if (detaching) {
					internal_8$2(if_block_anchor);
				}
			}
		};
	}

	function instance$4($$self, $$props, $$invalidate) {
		let { item } = $$props;

		let { $$slots = {}, $$scope } = $$props;

		$$self.$set = $$props => {
			if ('item' in $$props) $$invalidate('item', item = $$props.item);
			if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
		};

		return { item, $$slots, $$scope };
	}

	class ListContainer extends internal_101$2 {
		constructor(options) {
			super();
			internal_100$2(this, options, instance$4, create_fragment$5, internal_91$2, ["item"]);
		}
	}

	/* src/components/List.svelte generated by Svelte v3.0.0-beta.21 */

	const get_default_slot_changes$2 = ({ block }) => ({ block: block });
	const get_default_slot_context$2 = ({ block }) => ({ block: block });

	function get_each_context$2(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.item = list[i];
		return child_ctx;
	}

	// (2:0) <ListContainer {item} let:block>
	function create_default_slot$3(ctx) {
		var current;

		const default_slot_1 = ctx.$$slots.default;
		const default_slot = internal_94$2(default_slot_1, ctx, get_default_slot_context$2);

		return {
			c() {
				if (default_slot) default_slot.c();
			},

			l(nodes) {
				if (default_slot) default_slot.l(nodes);
			},

			m(target, anchor) {
				if (default_slot) {
					default_slot.m(target, anchor);
				}

				current = true;
			},

			p(changed, ctx) {
				if (default_slot && default_slot.p && (changed.$$scope || changed.block)) {
					default_slot.p(internal_96$2(default_slot_1, ctx, changed, get_default_slot_changes$2), internal_95$2(default_slot_1, ctx, get_default_slot_context$2));
				}
			},

			i(local) {
				if (current) return;
				if (default_slot && default_slot.i) default_slot.i(local);
				current = true;
			},

			o(local) {
				if (default_slot && default_slot.o) default_slot.o(local);
				current = false;
			},

			d(detaching) {
				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	// (1:0) {#each items as item}
	function create_each_block$2(ctx) {
		var current;

		var listcontainer = new ListContainer({
			props: {
			item: ctx.item,
			$$slots: {
			default: [create_default_slot$3, ({ block }) => ({ block })]
		},
			$$scope: { ctx }
		}
		});

		return {
			c() {
				listcontainer.$$.fragment.c();
			},

			m(target, anchor) {
				internal_99$2(listcontainer, target, anchor);
				current = true;
			},

			p(changed, ctx) {
				var listcontainer_changes = {};
				if (changed.items) listcontainer_changes.item = ctx.item;
				listcontainer.$set(listcontainer_changes);
			},

			i(local) {
				if (current) return;
				listcontainer.$$.fragment.i(local);

				current = true;
			},

			o(local) {
				listcontainer.$$.fragment.o(local);
				current = false;
			},

			d(detaching) {
				listcontainer.$destroy(detaching);
			}
		};
	}

	function create_fragment$6(ctx) {
		var each_1_anchor, current;

		var each_value = ctx.items;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
		}

		function outro_block(i, detaching, local) {
			if (each_blocks[i]) {
				if (detaching) {
					internal_77$2(() => {
						each_blocks[i].d(detaching);
						each_blocks[i] = null;
					});
				}

				each_blocks[i].o(local);
			}
		}

		return {
			c() {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = internal_17$2();
			},

			m(target, anchor) {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(target, anchor);
				}

				internal_7$2(target, each_1_anchor, anchor);
				current = true;
			},

			p(changed, ctx) {
				if (changed.items || changed.$$scope) {
					each_value = ctx.items;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$2(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
							each_blocks[i].i(1);
						} else {
							each_blocks[i] = create_each_block$2(child_ctx);
							each_blocks[i].c();
							each_blocks[i].i(1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					internal_75$2();
					for (; i < each_blocks.length; i += 1) outro_block(i, 1, 1);
					internal_76$2();
				}
			},

			i(local) {
				if (current) return;
				for (var i = 0; i < each_value.length; i += 1) each_blocks[i].i();

				current = true;
			},

			o(local) {
				each_blocks = each_blocks.filter(Boolean);
				for (let i = 0; i < each_blocks.length; i += 1) outro_block(i, 0);

				current = false;
			},

			d(detaching) {
				internal_12$2(each_blocks, detaching);

				if (detaching) {
					internal_8$2(each_1_anchor);
				}
			}
		};
	}

	function compare(list, attrs) {
	if (!list) return true;
	return list.list === attrs.list && (list.start === attrs.start || (list.start && !attrs.start)) && list.type === attrs.type;
	}

	function create(attrs) {
	return { list: attrs.list, start: attrs.start, type: attrs.type, children: [] };
	}

	function instance$5($$self, $$props, $$invalidate) {
		

	let { blocks } = $$props;

	let items = [];

		let { $$slots = {}, $$scope } = $$props;

		$$self.$set = $$props => {
			if ('blocks' in $$props) $$invalidate('blocks', blocks = $$props.blocks);
			if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
		};

		$$self.$$.update = ($$dirty = { items: 1, blocks: 1 }) => {
			if ($$dirty.items || $$dirty.blocks) {
	      items = []; $$invalidate('items', items);
	      let levels = [];
	      let currentChildren = items;
	    
	      blocks.forEach(block => {
	        const depth = block.attributes.indent || 0;
	    
	        if (depth < levels.length) {
	          while (depth + 1 < levels.length || !compare(levels[levels.length - 1], block.attributes)) {
	            levels.pop();
	            currentChildren = levels.length ? levels[levels.length - 1].children : items;
	          }
	        }
	    
	        while (depth >= levels.length) {
	          const list = create(block.attributes);
	          currentChildren.push(list);
	          currentChildren = list.children;
	          levels.push(list);
	        }
	    
	        currentChildren.push(block);
	      });
	    }
		};

		return { blocks, items, $$slots, $$scope };
	}

	class List extends internal_101$2 {
		constructor(options) {
			super();
			internal_100$2(this, options, instance$5, create_fragment$6, internal_91$2, ["blocks"]);
		}
	}

	/* src/components/Blockquote.svelte generated by Svelte v3.0.0-beta.21 */

	const get_default_slot_changes$3 = ({ blocks, block }) => ({ block: blocks });
	const get_default_slot_context$3 = ({ blocks, block }) => ({ block: block });

	function get_each_context$3(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.block = list[i];
		return child_ctx;
	}

	// (2:0) {#each blocks as block}
	function create_each_block$3(ctx) {
		var p, current;

		const default_slot_1 = ctx.$$slots.default;
		const default_slot = internal_94$2(default_slot_1, ctx, get_default_slot_context$3);

		return {
			c() {
				p = internal_13$2("p");

				if (default_slot) default_slot.c();
			},

			l(nodes) {
				if (default_slot) default_slot.l(p_nodes);
			},

			m(target, anchor) {
				internal_7$2(target, p, anchor);

				if (default_slot) {
					default_slot.m(p, null);
				}

				current = true;
			},

			p(changed, ctx) {
				if (default_slot && default_slot.p && (changed.$$scope || changed.blocks)) {
					default_slot.p(internal_96$2(default_slot_1, ctx, changed, get_default_slot_changes$3), internal_95$2(default_slot_1, ctx, get_default_slot_context$3));
				}
			},

			i(local) {
				if (current) return;
				if (default_slot && default_slot.i) default_slot.i(local);
				current = true;
			},

			o(local) {
				if (default_slot && default_slot.o) default_slot.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(p);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	function create_fragment$7(ctx) {
		var blockquote, current;

		var each_value = ctx.blocks;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
		}

		function outro_block(i, detaching, local) {
			if (each_blocks[i]) {
				if (detaching) {
					internal_77$2(() => {
						each_blocks[i].d(detaching);
						each_blocks[i] = null;
					});
				}

				each_blocks[i].o(local);
			}
		}

		return {
			c() {
				blockquote = internal_13$2("blockquote");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
			},

			m(target, anchor) {
				internal_7$2(target, blockquote, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(blockquote, null);
				}

				current = true;
			},

			p(changed, ctx) {
				if (changed.$$scope || changed.blocks) {
					each_value = ctx.blocks;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$3(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
							each_blocks[i].i(1);
						} else {
							each_blocks[i] = create_each_block$3(child_ctx);
							each_blocks[i].c();
							each_blocks[i].i(1);
							each_blocks[i].m(blockquote, null);
						}
					}

					internal_75$2();
					for (; i < each_blocks.length; i += 1) outro_block(i, 1, 1);
					internal_76$2();
				}
			},

			i(local) {
				if (current) return;
				for (var i = 0; i < each_value.length; i += 1) each_blocks[i].i();

				current = true;
			},

			o(local) {
				each_blocks = each_blocks.filter(Boolean);
				for (let i = 0; i < each_blocks.length; i += 1) outro_block(i, 0);

				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(blockquote);
				}

				internal_12$2(each_blocks, detaching);
			}
		};
	}

	function instance$6($$self, $$props, $$invalidate) {
		let { blocks } = $$props;

		let { $$slots = {}, $$scope } = $$props;

		$$self.$set = $$props => {
			if ('blocks' in $$props) $$invalidate('blocks', blocks = $$props.blocks);
			if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
		};

		return { blocks, $$slots, $$scope };
	}

	class Blockquote extends internal_101$2 {
		constructor(options) {
			super();
			internal_100$2(this, options, instance$6, create_fragment$7, internal_91$2, ["blocks"]);
		}
	}

	/* src/components/Codeblock.svelte generated by Svelte v3.0.0-beta.21 */

	const get_default_slot_changes$4 = ({ blocks, block }) => ({ block: blocks });
	const get_default_slot_context$4 = ({ blocks, block }) => ({ block: block });

	function get_each_context$4(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.block = list[i];
		return child_ctx;
	}

	// (2:0) {#each blocks as block}
	function create_each_block$4(ctx) {
		var code, t_value = '\n', t, current;

		const default_slot_1 = ctx.$$slots.default;
		const default_slot = internal_94$2(default_slot_1, ctx, get_default_slot_context$4);

		return {
			c() {
				code = internal_13$2("code");

				if (default_slot) default_slot.c();
				t = internal_15$2(t_value);
			},

			l(nodes) {
				if (default_slot) default_slot.l(code_nodes);
			},

			m(target, anchor) {
				internal_7$2(target, code, anchor);

				if (default_slot) {
					default_slot.m(code, null);
				}

				internal_7$2(target, t, anchor);
				current = true;
			},

			p(changed, ctx) {
				if (default_slot && default_slot.p && (changed.$$scope || changed.blocks)) {
					default_slot.p(internal_96$2(default_slot_1, ctx, changed, get_default_slot_changes$4), internal_95$2(default_slot_1, ctx, get_default_slot_context$4));
				}
			},

			i(local) {
				if (current) return;
				if (default_slot && default_slot.i) default_slot.i(local);
				current = true;
			},

			o(local) {
				if (default_slot && default_slot.o) default_slot.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(code);
				}

				if (default_slot) default_slot.d(detaching);

				if (detaching) {
					internal_8$2(t);
				}
			}
		};
	}

	function create_fragment$8(ctx) {
		var pre, current;

		var each_value = ctx.blocks;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
		}

		function outro_block(i, detaching, local) {
			if (each_blocks[i]) {
				if (detaching) {
					internal_77$2(() => {
						each_blocks[i].d(detaching);
						each_blocks[i] = null;
					});
				}

				each_blocks[i].o(local);
			}
		}

		return {
			c() {
				pre = internal_13$2("pre");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}
			},

			m(target, anchor) {
				internal_7$2(target, pre, anchor);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(pre, null);
				}

				current = true;
			},

			p(changed, ctx) {
				if (changed.$$scope || changed.blocks) {
					each_value = ctx.blocks;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$4(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
							each_blocks[i].i(1);
						} else {
							each_blocks[i] = create_each_block$4(child_ctx);
							each_blocks[i].c();
							each_blocks[i].i(1);
							each_blocks[i].m(pre, null);
						}
					}

					internal_75$2();
					for (; i < each_blocks.length; i += 1) outro_block(i, 1, 1);
					internal_76$2();
				}
			},

			i(local) {
				if (current) return;
				for (var i = 0; i < each_value.length; i += 1) each_blocks[i].i();

				current = true;
			},

			o(local) {
				each_blocks = each_blocks.filter(Boolean);
				for (let i = 0; i < each_blocks.length; i += 1) outro_block(i, 0);

				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(pre);
				}

				internal_12$2(each_blocks, detaching);
			}
		};
	}

	function instance$7($$self, $$props, $$invalidate) {
		let { blocks } = $$props;

		let { $$slots = {}, $$scope } = $$props;

		$$self.$set = $$props => {
			if ('blocks' in $$props) $$invalidate('blocks', blocks = $$props.blocks);
			if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
		};

		return { blocks, $$slots, $$scope };
	}

	class Codeblock extends internal_101$2 {
		constructor(options) {
			super();
			internal_100$2(this, options, instance$7, create_fragment$8, internal_91$2, ["blocks"]);
		}
	}

	/* src/components/Hr.svelte generated by Svelte v3.0.0-beta.21 */

	function create_fragment$9(ctx) {
		var hr;

		return {
			c() {
				hr = internal_13$2("hr");
			},

			m(target, anchor) {
				internal_7$2(target, hr, anchor);
			},

			p: internal_81$2,
			i: internal_81$2,
			o: internal_81$2,

			d(detaching) {
				if (detaching) {
					internal_8$2(hr);
				}
			}
		};
	}

	class Hr extends internal_101$2 {
		constructor(options) {
			super();
			internal_100$2(this, options, null, create_fragment$9, internal_91$2, []);
		}
	}

	/* src/components/Bold.svelte generated by Svelte v3.0.0-beta.21 */

	function create_fragment$a(ctx) {
		var strong, current;

		const default_slot_1 = ctx.$$slots.default;
		const default_slot = internal_94$2(default_slot_1, ctx, null);

		return {
			c() {
				strong = internal_13$2("strong");

				if (default_slot) default_slot.c();
			},

			l(nodes) {
				if (default_slot) default_slot.l(strong_nodes);
			},

			m(target, anchor) {
				internal_7$2(target, strong, anchor);

				if (default_slot) {
					default_slot.m(strong, null);
				}

				current = true;
			},

			p(changed, ctx) {
				if (default_slot && default_slot.p && changed.$$scope) {
					default_slot.p(internal_96$2(default_slot_1, ctx, changed,), internal_95$2(default_slot_1, ctx, null));
				}
			},

			i(local) {
				if (current) return;
				if (default_slot && default_slot.i) default_slot.i(local);
				current = true;
			},

			o(local) {
				if (default_slot && default_slot.o) default_slot.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(strong);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	function instance$8($$self, $$props, $$invalidate) {
		let { $$slots = {}, $$scope } = $$props;

		$$self.$set = $$props => {
			if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
		};

		return { $$slots, $$scope };
	}

	class Bold extends internal_101$2 {
		constructor(options) {
			super();
			internal_100$2(this, options, instance$8, create_fragment$a, internal_91$2, []);
		}
	}

	/* src/components/Italic.svelte generated by Svelte v3.0.0-beta.21 */

	function create_fragment$b(ctx) {
		var em, current;

		const default_slot_1 = ctx.$$slots.default;
		const default_slot = internal_94$2(default_slot_1, ctx, null);

		return {
			c() {
				em = internal_13$2("em");

				if (default_slot) default_slot.c();
			},

			l(nodes) {
				if (default_slot) default_slot.l(em_nodes);
			},

			m(target, anchor) {
				internal_7$2(target, em, anchor);

				if (default_slot) {
					default_slot.m(em, null);
				}

				current = true;
			},

			p(changed, ctx) {
				if (default_slot && default_slot.p && changed.$$scope) {
					default_slot.p(internal_96$2(default_slot_1, ctx, changed,), internal_95$2(default_slot_1, ctx, null));
				}
			},

			i(local) {
				if (current) return;
				if (default_slot && default_slot.i) default_slot.i(local);
				current = true;
			},

			o(local) {
				if (default_slot && default_slot.o) default_slot.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(em);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	function instance$9($$self, $$props, $$invalidate) {
		let { $$slots = {}, $$scope } = $$props;

		$$self.$set = $$props => {
			if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
		};

		return { $$slots, $$scope };
	}

	class Italic extends internal_101$2 {
		constructor(options) {
			super();
			internal_100$2(this, options, instance$9, create_fragment$b, internal_91$2, []);
		}
	}

	/* src/components/Link.svelte generated by Svelte v3.0.0-beta.21 */

	function create_fragment$c(ctx) {
		var a, a_href_value, current;

		const default_slot_1 = ctx.$$slots.default;
		const default_slot = internal_94$2(default_slot_1, ctx, null);

		return {
			c() {
				a = internal_13$2("a");

				if (default_slot) default_slot.c();

				a.href = a_href_value = ctx.attrs.link;
				a.target = "_blank";
			},

			l(nodes) {
				if (default_slot) default_slot.l(a_nodes);
			},

			m(target, anchor) {
				internal_7$2(target, a, anchor);

				if (default_slot) {
					default_slot.m(a, null);
				}

				current = true;
			},

			p(changed, ctx) {
				if (default_slot && default_slot.p && changed.$$scope) {
					default_slot.p(internal_96$2(default_slot_1, ctx, changed,), internal_95$2(default_slot_1, ctx, null));
				}

				if ((!current || changed.attrs) && a_href_value !== (a_href_value = ctx.attrs.link)) {
					a.href = a_href_value;
				}
			},

			i(local) {
				if (current) return;
				if (default_slot && default_slot.i) default_slot.i(local);
				current = true;
			},

			o(local) {
				if (default_slot && default_slot.o) default_slot.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(a);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	function instance$a($$self, $$props, $$invalidate) {
		let { attrs } = $$props;

		let { $$slots = {}, $$scope } = $$props;

		$$self.$set = $$props => {
			if ('attrs' in $$props) $$invalidate('attrs', attrs = $$props.attrs);
			if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
		};

		return { attrs, $$slots, $$scope };
	}

	class Link extends internal_101$2 {
		constructor(options) {
			super();
			internal_100$2(this, options, instance$a, create_fragment$c, internal_91$2, ["attrs"]);
		}
	}

	/* src/components/Image.svelte generated by Svelte v3.0.0-beta.21 */

	function create_fragment$d(ctx) {
		var img;

		var img_levels = [
			ctx.props
		];

		var img_data = {};
		for (var i = 0; i < img_levels.length; i += 1) {
			img_data = internal_83$2(img_data, img_levels[i]);
		}

		return {
			c() {
				img = internal_13$2("img");
				internal_22$2(img, img_data);
			},

			m(target, anchor) {
				internal_7$2(target, img, anchor);
			},

			p(changed, ctx) {
				internal_22$2(img, internal_64$2(img_levels, [
					(changed.props) && ctx.props
				]));
			},

			i: internal_81$2,
			o: internal_81$2,

			d(detaching) {
				if (detaching) {
					internal_8$2(img);
				}
			}
		};
	}

	function instance$b($$self, $$props, $$invalidate) {
		let { attrs } = $$props;
		let props;

		$$self.$set = $$props => {
			if ('attrs' in $$props) $$invalidate('attrs', attrs = $$props.attrs);
		};

		$$self.$$.update = ($$dirty = { attrs: 1 }) => {
			if ($$dirty.attrs) {
					let { image, ...rest } = attrs;
					props = { src: image, ...rest }; $$invalidate('props', props);
				}
		};

		return { attrs, props };
	}

	class Image extends internal_101$2 {
		constructor(options) {
			super();
			internal_100$2(this, options, instance$b, create_fragment$d, internal_91$2, ["attrs"]);
		}
	}

	/* src/components/Decorator.svelte generated by Svelte v3.0.0-beta.21 */

	function create_fragment$e(ctx) {
		var span, current;

		const default_slot_1 = ctx.$$slots.default;
		const default_slot = internal_94$2(default_slot_1, ctx, null);

		var span_levels = [
			ctx.props
		];

		var span_data = {};
		for (var i = 0; i < span_levels.length; i += 1) {
			span_data = internal_83$2(span_data, span_levels[i]);
		}

		return {
			c() {
				span = internal_13$2("span");

				if (default_slot) default_slot.c();

				internal_22$2(span, span_data);
			},

			l(nodes) {
				if (default_slot) default_slot.l(span_nodes);
			},

			m(target, anchor) {
				internal_7$2(target, span, anchor);

				if (default_slot) {
					default_slot.m(span, null);
				}

				current = true;
			},

			p(changed, ctx) {
				if (default_slot && default_slot.p && changed.$$scope) {
					default_slot.p(internal_96$2(default_slot_1, ctx, changed,), internal_95$2(default_slot_1, ctx, null));
				}

				internal_22$2(span, internal_64$2(span_levels, [
					(changed.props) && ctx.props
				]));
			},

			i(local) {
				if (current) return;
				if (default_slot && default_slot.i) default_slot.i(local);
				current = true;
			},

			o(local) {
				if (default_slot && default_slot.o) default_slot.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(span);
				}

				if (default_slot) default_slot.d(detaching);
			}
		};
	}

	function instance$c($$self, $$props, $$invalidate) {
		let { attrs } = $$props;
	let props;

		let { $$slots = {}, $$scope } = $$props;

		$$self.$set = $$props => {
			if ('attrs' in $$props) $$invalidate('attrs', attrs = $$props.attrs);
			if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
		};

		$$self.$$.update = ($$dirty = { attrs: 1, props: 1 }) => {
			if ($$dirty.attrs || $$dirty.props) {
	      props = { ...attrs.decorator }; $$invalidate('props', props);
	      props.class = props.class ? props.class + ' decorator' : 'decorator'; $$invalidate('props', props);
	    }
		};

		return { attrs, props, $$slots, $$scope };
	}

	class Decorator extends internal_101$2 {
		constructor(options) {
			super();
			internal_100$2(this, options, instance$c, create_fragment$e, internal_91$2, ["attrs"]);
		}
	}

	var components = {};
	function registerComponent(name, component, rendersMultiple) {
	    component.rendersMultiple = rendersMultiple;
	    components[name] = component;
	}
	function getComponent(name) {
	    return components[name];
	}
	registerComponent('paragraph', Paragraph);
	registerComponent('header', Header);
	registerComponent('list', List, true);
	registerComponent('blockquote', Blockquote, true);
	registerComponent('code-block', Codeblock, true);
	registerComponent('hr', Hr);
	registerComponent('bold', Bold);
	registerComponent('italic', Italic);
	registerComponent('code', Italic);
	registerComponent('link', Link);
	registerComponent('image', Image);
	registerComponent('br', Br);
	registerComponent('decorator', Decorator);

	/* src/components/BlockContents.svelte generated by Svelte v3.0.0-beta.21 */

	// (1:0) {#if children.length}
	function create_if_block$4(ctx) {
		var current;

		var inlinecontents = new InlineContents({ props: { children: ctx.children } });

		return {
			c() {
				inlinecontents.$$.fragment.c();
			},

			m(target, anchor) {
				internal_99$2(inlinecontents, target, anchor);
				current = true;
			},

			p(changed, ctx) {
				var inlinecontents_changes = {};
				if (changed.children) inlinecontents_changes.children = ctx.children;
				inlinecontents.$set(inlinecontents_changes);
			},

			i(local) {
				if (current) return;
				inlinecontents.$$.fragment.i(local);

				current = true;
			},

			o(local) {
				inlinecontents.$$.fragment.o(local);
				current = false;
			},

			d(detaching) {
				inlinecontents.$destroy(detaching);
			}
		};
	}

	function create_fragment$f(ctx) {
		var if_block_anchor, current;

		var if_block = (ctx.children.length) && create_if_block$4(ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = internal_17$2();
			},

			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				internal_7$2(target, if_block_anchor, anchor);
				current = true;
			},

			p(changed, ctx) {
				if (ctx.children.length) {
					if (if_block) {
						if_block.p(changed, ctx);
						if_block.i(1);
					} else {
						if_block = create_if_block$4(ctx);
						if_block.c();
						if_block.i(1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					internal_75$2();
					internal_77$2(() => {
						if_block.d(1);
						if_block = null;
					});

					if_block.o(1);
					internal_76$2();
				}
			},

			i(local) {
				if (current) return;
				if (if_block) if_block.i();
				current = true;
			},

			o(local) {
				if (if_block) if_block.o();
				current = false;
			},

			d(detaching) {
				if (if_block) if_block.d(detaching);

				if (detaching) {
					internal_8$2(if_block_anchor);
				}
			}
		};
	}

	function mergeChildren(oldChildren) {
	const children = [];
	oldChildren.forEach((next, i) => {
	  const prev = children[children.length - 1];

	  if (prev && prev.mark && next.mark === prev.mark && next.value === prev.value) {
	    prev.children.push(...next.children);
	  } else {
	    children.push(next);
	  }
	});
	return children;
	}

	function instance$d($$self, $$props, $$invalidate) {
		

	let { contents, paper } = $$props;
	let children;
	const br = { component: Br };

		$$self.$set = $$props => {
			if ('contents' in $$props) $$invalidate('contents', contents = $$props.contents);
			if ('paper' in $$props) $$invalidate('paper', paper = $$props.paper);
		};

		$$self.$$.update = ($$dirty = { contents: 1, paper: 1, children: 1 }) => {
			if ($$dirty.contents || $$dirty.paper || $$dirty.children) {
	      children = []; $$invalidate('children', children);
	    
	      if (contents) {
	        // Collect block children
	        contents.forEach((op, i) => {
	          let nodeChildren = [];
	          if (typeof op.insert === 'string') {
	            const prev = contents[i - 1];
	            const next = contents[i + 1];
	            let text = op.insert.replace(/  /g, '\xA0 ');
	            if (!prev) text = text.replace(/^ /, '\xA0');
	            if (!next || (typeof op.insert === 'string' && next.insert[0] === ' ')) text = text.replace(/ $/, '\xA0');
	            nodeChildren.push(text);
	          } else {
	            const component = getComponent(paper.embeds.findByAttributes(op.insert).name);
	            if (component) nodeChildren.push({ component, attrs: op.insert });
	          }
	    
	          if (op.attributes) {
	            // Sort them by the order found in marks and be efficient
	            Object.keys(op.attributes).sort((a, b) => paper.marks.priority(b) - paper.marks.priority(a)).forEach(name => {
	              const component = getComponent(name);
	              if (component) nodeChildren = [ { component, attrs: op.attributes, children: nodeChildren }];
	            });
	          }
	    
	          children.push(...nodeChildren);
	        });
	    
	        // Merge marks to optimize
	        children = mergeChildren(children); $$invalidate('children', children);
	    
	        let last;
	        if (!children.length || ((last = children[children.length - 1].component) && (last.name === 'Br' || last.name === 'Decorator'))) {
	          children.push(br);
	        }
	      }
	    }
		};

		return { contents, paper, children };
	}

	class BlockContents extends internal_101$2 {
		constructor(options) {
			super();
			internal_100$2(this, options, instance$d, create_fragment$f, internal_91$2, ["contents", "paper"]);
		}
	}

	var dispatcherEvents$4 = new WeakMap();
	var EventDispatcher$4 = /** @class */ (function () {
	    function EventDispatcher() {
	    }
	    EventDispatcher.prototype.on = function (type, listener) {
	        getEventListeners$4(this, type, true).add(listener);
	    };
	    EventDispatcher.prototype.off = function (type, listener) {
	        var events = getEventListeners$4(this, type);
	        events && events["delete"](listener);
	    };
	    EventDispatcher.prototype.once = function (type, listener) {
	        function once() {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            this.off(type, once);
	            listener.apply(this, args);
	        }
	        this.on(type, once);
	    };
	    EventDispatcher.prototype.fire = function (type) {
	        var _this = this;
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        var uncanceled = true;
	        var events = getEventListeners$4(this, type);
	        if (events)
	            events.forEach(function (listener) {
	                uncanceled && listener.apply(_this, args) !== false || (uncanceled = false);
	            });
	        return uncanceled;
	    };
	    return EventDispatcher;
	}());
	function getEventListeners$4(obj, type, autocreate) {
	    if (autocreate === void 0) { autocreate = false; }
	    var events = dispatcherEvents$4.get(obj);
	    if (!events && autocreate)
	        dispatcherEvents$4.set(obj, events = Object.create(null));
	    return events && events[type] || autocreate && (events[type] = new Set());
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics$4 = function(d, b) {
	    extendStatics$4 = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return extendStatics$4(d, b);
	};

	function __extends$4(d, b) {
	    extendStatics$4(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign$4 = function() {
	    __assign$4 = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$4.apply(this, arguments);
	};

	/**
	 * This library modifies the diff-patch-match library by Neil Fraser
	 * by removing the patch and match functionality and certain advanced
	 * options in the diff function. The original license is as follows:
	 *
	 * ===
	 *
	 * Diff Match and Patch
	 *
	 * Copyright 2006 Google Inc.
	 * http://code.google.com/p/google-diff-match-patch/
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * The data structure representing a diff is an array of tuples:
	 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
	 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
	 */
	var DIFF_DELETE$4 = -1;
	var DIFF_INSERT$4 = 1;
	var DIFF_EQUAL$4 = 0;
	/**
	 * Find the differences between two texts.  Simplifies the problem by stripping
	 * any common prefix or suffix off the texts before diffing.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {Int} cursor_pos Expected edit position in text1 (optional)
	 * @return {Array} Array of diff tuples.
	 */
	function diff$4(text1, text2, cursor_pos) {
	    // Check for equality (speedup).
	    if (text1 == text2) {
	        if (text1) {
	            return [[DIFF_EQUAL$4, text1]];
	        }
	        return [];
	    }
	    // Check cursor_pos within bounds
	    if (cursor_pos < 0 || text1.length < cursor_pos) {
	        cursor_pos = null;
	    }
	    // Trim off common prefix (speedup).
	    var commonlength = diff_commonPrefix$4(text1, text2);
	    var commonprefix = text1.substring(0, commonlength);
	    text1 = text1.substring(commonlength);
	    text2 = text2.substring(commonlength);
	    // Trim off common suffix (speedup).
	    commonlength = diff_commonSuffix$4(text1, text2);
	    var commonsuffix = text1.substring(text1.length - commonlength);
	    text1 = text1.substring(0, text1.length - commonlength);
	    text2 = text2.substring(0, text2.length - commonlength);
	    // Compute the diff on the middle block.
	    var diffs = diff_compute_$4(text1, text2);
	    // Restore the prefix and suffix.
	    if (commonprefix) {
	        diffs.unshift([DIFF_EQUAL$4, commonprefix]);
	    }
	    if (commonsuffix) {
	        diffs.push([DIFF_EQUAL$4, commonsuffix]);
	    }
	    diff_cleanupMerge$4(diffs);
	    if (cursor_pos != null) {
	        diffs = fix_cursor$4(diffs, cursor_pos);
	    }
	    diffs = fix_emoji$4(diffs);
	    return diffs;
	}
	/**
	 * Find the differences between two texts.  Assumes that the texts do not
	 * have any common prefix or suffix.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @return {Array} Array of diff tuples.
	 */
	function diff_compute_$4(text1, text2) {
	    var diffs;
	    if (!text1) {
	        // Just add some text (speedup).
	        return [[DIFF_INSERT$4, text2]];
	    }
	    if (!text2) {
	        // Just delete some text (speedup).
	        return [[DIFF_DELETE$4, text1]];
	    }
	    var longtext = text1.length > text2.length ? text1 : text2;
	    var shorttext = text1.length > text2.length ? text2 : text1;
	    var i = longtext.indexOf(shorttext);
	    if (i != -1) {
	        // Shorter text is inside the longer text (speedup).
	        diffs = [[DIFF_INSERT$4, longtext.substring(0, i)],
	            [DIFF_EQUAL$4, shorttext],
	            [DIFF_INSERT$4, longtext.substring(i + shorttext.length)]];
	        // Swap insertions for deletions if diff is reversed.
	        if (text1.length > text2.length) {
	            diffs[0][0] = diffs[2][0] = DIFF_DELETE$4;
	        }
	        return diffs;
	    }
	    if (shorttext.length == 1) {
	        // Single character string.
	        // After the previous speedup, the character can't be an equality.
	        return [[DIFF_DELETE$4, text1], [DIFF_INSERT$4, text2]];
	    }
	    // Check to see if the problem can be split in two.
	    var hm = diff_halfMatch_$4(text1, text2);
	    if (hm) {
	        // A half-match was found, sort out the return data.
	        var text1_a = hm[0];
	        var text1_b = hm[1];
	        var text2_a = hm[2];
	        var text2_b = hm[3];
	        var mid_common = hm[4];
	        // Send both pairs off for separate processing.
	        var diffs_a = diff$4(text1_a, text2_a);
	        var diffs_b = diff$4(text1_b, text2_b);
	        // Merge the results.
	        return diffs_a.concat([[DIFF_EQUAL$4, mid_common]], diffs_b);
	    }
	    return diff_bisect_$4(text1, text2);
	}
	/**
	 * Find the 'middle snake' of a diff, split the problem in two
	 * and return the recursively constructed diff.
	 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @return {Array} Array of diff tuples.
	 * @private
	 */
	function diff_bisect_$4(text1, text2) {
	    // Cache the text lengths to prevent multiple calls.
	    var text1_length = text1.length;
	    var text2_length = text2.length;
	    var max_d = Math.ceil((text1_length + text2_length) / 2);
	    var v_offset = max_d;
	    var v_length = 2 * max_d;
	    var v1 = new Array(v_length);
	    var v2 = new Array(v_length);
	    // Setting all elements to -1 is faster in Chrome & Firefox than mixing
	    // integers and undefined.
	    for (var x = 0; x < v_length; x++) {
	        v1[x] = -1;
	        v2[x] = -1;
	    }
	    v1[v_offset + 1] = 0;
	    v2[v_offset + 1] = 0;
	    var delta = text1_length - text2_length;
	    // If the total number of characters is odd, then the front path will collide
	    // with the reverse path.
	    var front = (delta % 2 != 0);
	    // Offsets for start and end of k loop.
	    // Prevents mapping of space beyond the grid.
	    var k1start = 0;
	    var k1end = 0;
	    var k2start = 0;
	    var k2end = 0;
	    for (var d = 0; d < max_d; d++) {
	        // Walk the front path one step.
	        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
	            var k1_offset = v_offset + k1;
	            var x1;
	            if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
	                x1 = v1[k1_offset + 1];
	            }
	            else {
	                x1 = v1[k1_offset - 1] + 1;
	            }
	            var y1 = x1 - k1;
	            while (x1 < text1_length && y1 < text2_length &&
	                text1.charAt(x1) == text2.charAt(y1)) {
	                x1++;
	                y1++;
	            }
	            v1[k1_offset] = x1;
	            if (x1 > text1_length) {
	                // Ran off the right of the graph.
	                k1end += 2;
	            }
	            else if (y1 > text2_length) {
	                // Ran off the bottom of the graph.
	                k1start += 2;
	            }
	            else if (front) {
	                var k2_offset = v_offset + delta - k1;
	                if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
	                    // Mirror x2 onto top-left coordinate system.
	                    var x2 = text1_length - v2[k2_offset];
	                    if (x1 >= x2) {
	                        // Overlap detected.
	                        return diff_bisectSplit_$4(text1, text2, x1, y1);
	                    }
	                }
	            }
	        }
	        // Walk the reverse path one step.
	        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
	            var k2_offset = v_offset + k2;
	            var x2;
	            if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
	                x2 = v2[k2_offset + 1];
	            }
	            else {
	                x2 = v2[k2_offset - 1] + 1;
	            }
	            var y2 = x2 - k2;
	            while (x2 < text1_length && y2 < text2_length &&
	                text1.charAt(text1_length - x2 - 1) ==
	                    text2.charAt(text2_length - y2 - 1)) {
	                x2++;
	                y2++;
	            }
	            v2[k2_offset] = x2;
	            if (x2 > text1_length) {
	                // Ran off the left of the graph.
	                k2end += 2;
	            }
	            else if (y2 > text2_length) {
	                // Ran off the top of the graph.
	                k2start += 2;
	            }
	            else if (!front) {
	                var k1_offset = v_offset + delta - k2;
	                if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
	                    var x1 = v1[k1_offset];
	                    var y1 = v_offset + x1 - k1_offset;
	                    // Mirror x2 onto top-left coordinate system.
	                    x2 = text1_length - x2;
	                    if (x1 >= x2) {
	                        // Overlap detected.
	                        return diff_bisectSplit_$4(text1, text2, x1, y1);
	                    }
	                }
	            }
	        }
	    }
	    // Diff took too long and hit the deadline or
	    // number of diffs equals number of characters, no commonality at all.
	    return [[DIFF_DELETE$4, text1], [DIFF_INSERT$4, text2]];
	}
	/**
	 * Given the location of the 'middle snake', split the diff in two parts
	 * and recurse.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} x Index of split point in text1.
	 * @param {number} y Index of split point in text2.
	 * @return {Array} Array of diff tuples.
	 */
	function diff_bisectSplit_$4(text1, text2, x, y) {
	    var text1a = text1.substring(0, x);
	    var text2a = text2.substring(0, y);
	    var text1b = text1.substring(x);
	    var text2b = text2.substring(y);
	    // Compute both diffs serially.
	    var diffs = diff$4(text1a, text2a);
	    var diffsb = diff$4(text1b, text2b);
	    return diffs.concat(diffsb);
	}
	/**
	 * Determine the common prefix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the start of each
	 *     string.
	 */
	function diff_commonPrefix$4(text1, text2) {
	    // Quick check for common null cases.
	    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
	        return 0;
	    }
	    // Binary search.
	    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	    var pointermin = 0;
	    var pointermax = Math.min(text1.length, text2.length);
	    var pointermid = pointermax;
	    var pointerstart = 0;
	    while (pointermin < pointermid) {
	        if (text1.substring(pointerstart, pointermid) ==
	            text2.substring(pointerstart, pointermid)) {
	            pointermin = pointermid;
	            pointerstart = pointermin;
	        }
	        else {
	            pointermax = pointermid;
	        }
	        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }
	    return pointermid;
	}
	/**
	 * Determine the common suffix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the end of each string.
	 */
	function diff_commonSuffix$4(text1, text2) {
	    // Quick check for common null cases.
	    if (!text1 || !text2 ||
	        text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
	        return 0;
	    }
	    // Binary search.
	    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	    var pointermin = 0;
	    var pointermax = Math.min(text1.length, text2.length);
	    var pointermid = pointermax;
	    var pointerend = 0;
	    while (pointermin < pointermid) {
	        if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
	            text2.substring(text2.length - pointermid, text2.length - pointerend)) {
	            pointermin = pointermid;
	            pointerend = pointermin;
	        }
	        else {
	            pointermax = pointermid;
	        }
	        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }
	    return pointermid;
	}
	/**
	 * Do the two texts share a substring which is at least half the length of the
	 * longer text?
	 * This speedup can produce non-minimal diffs.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {Array.<string>} Five element Array, containing the prefix of
	 *     text1, the suffix of text1, the prefix of text2, the suffix of
	 *     text2 and the common middle.  Or null if there was no match.
	 */
	function diff_halfMatch_$4(text1, text2) {
	    var longtext = text1.length > text2.length ? text1 : text2;
	    var shorttext = text1.length > text2.length ? text2 : text1;
	    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
	        return null; // Pointless.
	    }
	    /**
	     * Does a substring of shorttext exist within longtext such that the substring
	     * is at least half the length of longtext?
	     * Closure, but does not reference any external variables.
	     * @param {string} longtext Longer string.
	     * @param {string} shorttext Shorter string.
	     * @param {number} i Start index of quarter length substring within longtext.
	     * @return {Array.<string>} Five element Array, containing the prefix of
	     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
	     *     of shorttext and the common middle.  Or null if there was no match.
	     * @private
	     */
	    function diff_halfMatchI_(longtext, shorttext, i) {
	        // Start with a 1/4 length substring at position i as a seed.
	        var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
	        var j = -1;
	        var best_common = '';
	        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
	        while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
	            var prefixLength = diff_commonPrefix$4(longtext.substring(i), shorttext.substring(j));
	            var suffixLength = diff_commonSuffix$4(longtext.substring(0, i), shorttext.substring(0, j));
	            if (best_common.length < suffixLength + prefixLength) {
	                best_common = shorttext.substring(j - suffixLength, j) +
	                    shorttext.substring(j, j + prefixLength);
	                best_longtext_a = longtext.substring(0, i - suffixLength);
	                best_longtext_b = longtext.substring(i + prefixLength);
	                best_shorttext_a = shorttext.substring(0, j - suffixLength);
	                best_shorttext_b = shorttext.substring(j + prefixLength);
	            }
	        }
	        if (best_common.length * 2 >= longtext.length) {
	            return [best_longtext_a, best_longtext_b,
	                best_shorttext_a, best_shorttext_b, best_common];
	        }
	        else {
	            return null;
	        }
	    }
	    // First check if the second quarter is the seed for a half-match.
	    var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
	    // Check again based on the third quarter.
	    var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
	    var hm;
	    if (!hm1 && !hm2) {
	        return null;
	    }
	    else if (!hm2) {
	        hm = hm1;
	    }
	    else if (!hm1) {
	        hm = hm2;
	    }
	    else {
	        // Both matched.  Select the longest.
	        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
	    }
	    // A half-match was found, sort out the return data.
	    var text1_a, text1_b, text2_a, text2_b;
	    if (text1.length > text2.length) {
	        text1_a = hm[0];
	        text1_b = hm[1];
	        text2_a = hm[2];
	        text2_b = hm[3];
	    }
	    else {
	        text2_a = hm[0];
	        text2_b = hm[1];
	        text1_a = hm[2];
	        text1_b = hm[3];
	    }
	    var mid_common = hm[4];
	    return [text1_a, text1_b, text2_a, text2_b, mid_common];
	}
	/**
	 * Reorder and merge like edit sections.  Merge equalities.
	 * Any edit section can move as long as it doesn't cross an equality.
	 * @param {Array} diffs Array of diff tuples.
	 */
	function diff_cleanupMerge$4(diffs) {
	    diffs.push([DIFF_EQUAL$4, '']); // Add a dummy entry at the end.
	    var pointer = 0;
	    var count_delete = 0;
	    var count_insert = 0;
	    var text_delete = '';
	    var text_insert = '';
	    var commonlength;
	    while (pointer < diffs.length) {
	        switch (diffs[pointer][0]) {
	            case DIFF_INSERT$4:
	                count_insert++;
	                text_insert += diffs[pointer][1];
	                pointer++;
	                break;
	            case DIFF_DELETE$4:
	                count_delete++;
	                text_delete += diffs[pointer][1];
	                pointer++;
	                break;
	            case DIFF_EQUAL$4:
	                // Upon reaching an equality, check for prior redundancies.
	                if (count_delete + count_insert > 1) {
	                    if (count_delete !== 0 && count_insert !== 0) {
	                        // Factor out any common prefixies.
	                        commonlength = diff_commonPrefix$4(text_insert, text_delete);
	                        if (commonlength !== 0) {
	                            if ((pointer - count_delete - count_insert) > 0 &&
	                                diffs[pointer - count_delete - count_insert - 1][0] ==
	                                    DIFF_EQUAL$4) {
	                                diffs[pointer - count_delete - count_insert - 1][1] +=
	                                    text_insert.substring(0, commonlength);
	                            }
	                            else {
	                                diffs.splice(0, 0, [DIFF_EQUAL$4,
	                                    text_insert.substring(0, commonlength)]);
	                                pointer++;
	                            }
	                            text_insert = text_insert.substring(commonlength);
	                            text_delete = text_delete.substring(commonlength);
	                        }
	                        // Factor out any common suffixies.
	                        commonlength = diff_commonSuffix$4(text_insert, text_delete);
	                        if (commonlength !== 0) {
	                            diffs[pointer][1] = text_insert.substring(text_insert.length -
	                                commonlength) + diffs[pointer][1];
	                            text_insert = text_insert.substring(0, text_insert.length -
	                                commonlength);
	                            text_delete = text_delete.substring(0, text_delete.length -
	                                commonlength);
	                        }
	                    }
	                    // Delete the offending records and add the merged ones.
	                    if (count_delete === 0) {
	                        diffs.splice(pointer - count_insert, count_delete + count_insert, [DIFF_INSERT$4, text_insert]);
	                    }
	                    else if (count_insert === 0) {
	                        diffs.splice(pointer - count_delete, count_delete + count_insert, [DIFF_DELETE$4, text_delete]);
	                    }
	                    else {
	                        diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [DIFF_DELETE$4, text_delete], [DIFF_INSERT$4, text_insert]);
	                    }
	                    pointer = pointer - count_delete - count_insert +
	                        (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
	                }
	                else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL$4) {
	                    // Merge this equality with the previous one.
	                    diffs[pointer - 1][1] += diffs[pointer][1];
	                    diffs.splice(pointer, 1);
	                }
	                else {
	                    pointer++;
	                }
	                count_insert = 0;
	                count_delete = 0;
	                text_delete = '';
	                text_insert = '';
	                break;
	        }
	    }
	    if (diffs[diffs.length - 1][1] === '') {
	        diffs.pop(); // Remove the dummy entry at the end.
	    }
	    // Second pass: look for single edits surrounded on both sides by equalities
	    // which can be shifted sideways to eliminate an equality.
	    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
	    var changes = false;
	    pointer = 1;
	    // Intentionally ignore the first and last element (don't need checking).
	    while (pointer < diffs.length - 1) {
	        if (diffs[pointer - 1][0] == DIFF_EQUAL$4 &&
	            diffs[pointer + 1][0] == DIFF_EQUAL$4) {
	            // This is a single edit surrounded by equalities.
	            if (diffs[pointer][1].substring(diffs[pointer][1].length -
	                diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
	                // Shift the edit over the previous equality.
	                diffs[pointer][1] = diffs[pointer - 1][1] +
	                    diffs[pointer][1].substring(0, diffs[pointer][1].length -
	                        diffs[pointer - 1][1].length);
	                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
	                diffs.splice(pointer - 1, 1);
	                changes = true;
	            }
	            else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
	                diffs[pointer + 1][1]) {
	                // Shift the edit over the next equality.
	                diffs[pointer - 1][1] += diffs[pointer + 1][1];
	                diffs[pointer][1] =
	                    diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
	                        diffs[pointer + 1][1];
	                diffs.splice(pointer + 1, 1);
	                changes = true;
	            }
	        }
	        pointer++;
	    }
	    // If shifts were made, the diff needs reordering and another shift sweep.
	    if (changes) {
	        diff_cleanupMerge$4(diffs);
	    }
	}
	diff$4.INSERT = DIFF_INSERT$4;
	diff$4.DELETE = DIFF_DELETE$4;
	diff$4.EQUAL = DIFF_EQUAL$4;
	/*
	 * Modify a diff such that the cursor position points to the start of a change:
	 * E.g.
	 *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)
	 *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]
	 *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)
	 *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
	 * @return {Array} A tuple [cursor location in the modified diff, modified diff]
	 */
	function cursor_normalize_diff$4(diffs, cursor_pos) {
	    if (cursor_pos === 0) {
	        return [DIFF_EQUAL$4, diffs];
	    }
	    for (var current_pos = 0, i = 0; i < diffs.length; i++) {
	        var d = diffs[i];
	        if (d[0] === DIFF_DELETE$4 || d[0] === DIFF_EQUAL$4) {
	            var next_pos = current_pos + d[1].length;
	            if (cursor_pos === next_pos) {
	                return [i + 1, diffs];
	            }
	            else if (cursor_pos < next_pos) {
	                // copy to prevent side effects
	                diffs = diffs.slice();
	                // split d into two diff changes
	                var split_pos = cursor_pos - current_pos;
	                var d_left = [d[0], d[1].slice(0, split_pos)];
	                var d_right = [d[0], d[1].slice(split_pos)];
	                diffs.splice(i, 1, d_left, d_right);
	                return [i + 1, diffs];
	            }
	            else {
	                current_pos = next_pos;
	            }
	        }
	    }
	    throw new Error('cursor_pos is out of bounds!');
	}
	/*
	 * Modify a diff such that the edit position is "shifted" to the proposed edit location (cursor_position).
	 *
	 * Case 1)
	 *   Check if a naive shift is possible:
	 *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)
	 *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result
	 * Case 2)
	 *   Check if the following shifts are possible:
	 *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']
	 *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']
	 *         ^            ^
	 *         d          d_next
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
	 * @return {Array} Array of diff tuples
	 */
	function fix_cursor$4(diffs, cursor_pos) {
	    var norm = cursor_normalize_diff$4(diffs, cursor_pos);
	    var ndiffs = norm[1];
	    var cursor_pointer = norm[0];
	    var d = ndiffs[cursor_pointer];
	    var d_next = ndiffs[cursor_pointer + 1];
	    if (d == null) {
	        // Text was deleted from end of original string,
	        // cursor is now out of bounds in new string
	        return diffs;
	    }
	    else if (d[0] !== DIFF_EQUAL$4) {
	        // A modification happened at the cursor location.
	        // This is the expected outcome, so we can return the original diff.
	        return diffs;
	    }
	    else {
	        if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
	            // Case 1)
	            // It is possible to perform a naive shift
	            ndiffs.splice(cursor_pointer, 2, d_next, d);
	            return merge_tuples$4(ndiffs, cursor_pointer, 2);
	        }
	        else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
	            // Case 2)
	            // d[1] is a prefix of d_next[1]
	            // We can assume that d_next[0] !== 0, since d[0] === 0
	            // Shift edit locations..
	            ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
	            var suffix = d_next[1].slice(d[1].length);
	            if (suffix.length > 0) {
	                ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
	            }
	            return merge_tuples$4(ndiffs, cursor_pointer, 3);
	        }
	        else {
	            // Not possible to perform any modification
	            return diffs;
	        }
	    }
	}
	/*
	 * Check diff did not split surrogate pairs.
	 * Ex. [0, '\uD83D'], [-1, '\uDC36'], [1, '\uDC2F'] -> [-1, '\uD83D\uDC36'], [1, '\uD83D\uDC2F']
	 *     '\uD83D\uDC36' === '🐶', '\uD83D\uDC2F' === '🐯'
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @return {Array} Array of diff tuples
	 */
	function fix_emoji$4(diffs) {
	    var compact = false;
	    var starts_with_pair_end = function (str) {
	        return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;
	    };
	    var ends_with_pair_start = function (str) {
	        return str.charCodeAt(str.length - 1) >= 0xD800 && str.charCodeAt(str.length - 1) <= 0xDBFF;
	    };
	    for (var i = 2; i < diffs.length; i += 1) {
	        if (diffs[i - 2][0] === DIFF_EQUAL$4 && ends_with_pair_start(diffs[i - 2][1]) &&
	            diffs[i - 1][0] === DIFF_DELETE$4 && starts_with_pair_end(diffs[i - 1][1]) &&
	            diffs[i][0] === DIFF_INSERT$4 && starts_with_pair_end(diffs[i][1])) {
	            compact = true;
	            diffs[i - 1][1] = diffs[i - 2][1].slice(-1) + diffs[i - 1][1];
	            diffs[i][1] = diffs[i - 2][1].slice(-1) + diffs[i][1];
	            diffs[i - 2][1] = diffs[i - 2][1].slice(0, -1);
	        }
	    }
	    if (!compact) {
	        return diffs;
	    }
	    var fixed_diffs = [];
	    for (var i = 0; i < diffs.length; i += 1) {
	        if (diffs[i][1].length > 0) {
	            fixed_diffs.push(diffs[i]);
	        }
	    }
	    return fixed_diffs;
	}
	/*
	 * Try to merge tuples with their neigbors in a given range.
	 * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']
	 *
	 * @param {Array} diffs Array of diff tuples.
	 * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).
	 * @param {Int} length Number of consecutive elements to check.
	 * @return {Array} Array of merged diff tuples.
	 */
	function merge_tuples$4(diffs, start, length) {
	    // Check from (start-1) to (start+length).
	    for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {
	        if (i + 1 < diffs.length) {
	            var left_d = diffs[i];
	            var right_d = diffs[i + 1];
	            if (left_d[0] === right_d[1]) {
	                diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
	            }
	        }
	    }
	    return diffs;
	}

	function shallowEqual$4(valueA, valueB) {
	    return valueEqual$4(valueA, valueB, strictEqual$4);
	}
	function deepEqual$4(valueA, valueB) {
	    return valueEqual$4(valueA, valueB, valueEqual$4);
	}
	function strictEqual$4(valueA, valueB) {
	    return valueA === valueB;
	}
	function valueEqual$4(valueA, valueB, propEqual) {
	    if (valueA === valueB)
	        return true;
	    if (valueA instanceof Date && valueB instanceof Date)
	        return valueA.getTime() === valueB.getTime();
	    if (!valueA || !valueB || typeof valueA !== 'object' && typeof valueB !== 'object')
	        return valueA === valueB;
	    return objectEqual$4(valueA, valueB, propEqual);
	}
	function objectEqual$4(objA, objB, propEqual) {
	    if (objA.prototype !== objB.prototype)
	        return false;
	    var keysA = Object.keys(objA);
	    var keysB = Object.keys(objB);
	    if (keysA.length !== keysB.length)
	        return false;
	    return keysA.every(function (key, i) { return key === keysB[i] && propEqual(objA[key], objB[key], propEqual); });
	}

	var NULL_CHARACTER$4 = String.fromCharCode(0); // Placeholder char for embed in diff()
	var Delta$4 = /** @class */ (function () {
	    function Delta(ops) {
	        if (ops === void 0) { ops = []; }
	        this.ops = ops;
	    }
	    /**
	     * Appends an insert operation. Returns this for chainability.
	     *
	     * @param {String|Object} text Represents text or embed to insert
	     * @param {Object} attributes Optional attributes to apply
	     */
	    Delta.prototype.insert = function (text, attributes) {
	        var newOp = {};
	        if (text.length === 0)
	            return this;
	        newOp.insert = text;
	        if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
	            newOp.attributes = attributes;
	        }
	        return this._push(newOp);
	    };
	    /**
	     * Appends a delete operation. Returns this for chainability.
	     *
	     * @param {Number} length Number of characters to delete
	     */
	    Delta.prototype["delete"] = function (length) {
	        if (length <= 0)
	            return this;
	        return this._push({ "delete": length });
	    };
	    /**
	     * Appends a retain operation. Returns this for chainability.
	     *
	     * @param {Number} length Number of characters to retain
	     * @param {Object} attributes Optional attributes to apply
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.retain = function (length, attributes) {
	        if (length <= 0)
	            return this;
	        var newOp = { retain: length };
	        if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
	            newOp.attributes = attributes;
	        }
	        return this._push(newOp);
	    };
	    /**
	     * Freezes delta from future modifications. Returns this for chainability.
	     *
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.freeze = function () {
	        var _this = this;
	        this._push = function () { return _this; };
	        return this;
	    };
	    /**
	     * Adds a new operation. Returns this for chainability.
	     *
	     * @param {Object} newOp A new operation
	     * @returns {Delta} This delta
	     */
	    Delta.prototype._push = function (newOp) {
	        var index = this.ops.length;
	        var lastOp = this.ops[index - 1];
	        if (typeof lastOp === 'object') {
	            if (typeof newOp["delete"] === 'number' && typeof lastOp["delete"] === 'number') {
	                this.ops[index - 1] = { "delete": lastOp["delete"] + newOp["delete"] };
	                return this;
	            }
	            // Since it does not matter if we insert before or after deleting at the same index,
	            // always prefer to insert first
	            if (typeof lastOp["delete"] === 'number' && newOp.insert != null) {
	                index -= 1;
	                lastOp = this.ops[index - 1];
	                if (typeof lastOp !== 'object') {
	                    this.ops.unshift(newOp);
	                    return this;
	                }
	            }
	            if (deepEqual$4(newOp.attributes, lastOp.attributes)) {
	                if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {
	                    this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };
	                    if (typeof newOp.attributes === 'object')
	                        this.ops[index - 1].attributes = newOp.attributes;
	                    return this;
	                }
	                else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {
	                    this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };
	                    if (typeof newOp.attributes === 'object')
	                        this.ops[index - 1].attributes = newOp.attributes;
	                    return this;
	                }
	            }
	        }
	        if (index === this.ops.length) {
	            this.ops.push(newOp);
	        }
	        else {
	            this.ops.splice(index, 0, newOp);
	        }
	        return this;
	    };
	    /**
	     * Chops off trailing retain instructions to make the delta concise.
	     *
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.chop = function () {
	        var lastOp = this.ops[this.ops.length - 1];
	        if (lastOp && lastOp.retain && !lastOp.attributes) {
	            this.ops.pop();
	        }
	        return this;
	    };
	    /**
	     * Returns an iterator to iterate over the operations of this delta.
	     *
	     * @returns {Iterator} An operation iterator with methods hasNext, next, peek, peekLength, & peekType
	     */
	    Delta.prototype.iterator = function () {
	        return new Iterator$4(this.ops);
	    };
	    /**
	     * Returns an array of operations that passes a given function.
	     *
	     * @param {Function} predicate Function to test each operation against. Return true to keep the operation, false
	     *                             otherwise
	     * @returns {Array} Filtered resulting array
	     */
	    Delta.prototype.filter = function (predicate) {
	        return this.ops.filter(predicate);
	    };
	    /**
	     * Iterates through operations, calling the provided function for each operation.
	     *
	     * @param {Function} predicate Function to call during iteration, passing in the current operation
	     */
	    Delta.prototype.forEach = function (predicate) {
	        this.ops.forEach(predicate);
	    };
	    /**
	     * Returns a new array with the results of calling provided function on each operation.
	     *
	     * @param {Function} predicate Function to call, passing in the current operation, returning an element of the new
	     *                             array to be returned
	     * @returns {Array} A new array with each element being the result of the given function
	     */
	    Delta.prototype.map = function (predicate) {
	        return this.ops.map(predicate);
	    };
	    /**
	     * Create an array of two arrays, the first with operations that pass the given function, the other that failed.
	     *
	     * @param {Function} predicate Function to call, passing in the current operation, returning whether that operation
	     *                             passed
	     * @returns {Array} A new array of two Arrays, the first with passed operations, the other with failed operations
	     */
	    Delta.prototype.partition = function (predicate) {
	        var passed = [], failed = [];
	        this.forEach(function (op) {
	            var target = predicate(op) ? passed : failed;
	            target.push(op);
	        });
	        return [passed, failed];
	    };
	    /**
	     * Applies given function against an accumulator and each operation to reduce to a single value.
	     *
	     * @param {Function} predicate Function to call per iteration, returning an accumulated value
	     * @param {*} initial Initial value to pass to first call to predicate
	     * @returns {*} The accumulated value
	     */
	    Delta.prototype.reduce = function (predicate, initial) {
	        return this.ops.reduce(predicate, initial);
	    };
	    Delta.prototype.changeLength = function () {
	        return this.reduce(function (length, entry) {
	            if (entry.insert) {
	                return length + getOpLength$4(entry);
	            }
	            else if (entry["delete"]) {
	                return length - entry["delete"];
	            }
	            return length;
	        }, 0);
	    };
	    /**
	     * Returns length of a Delta, which is the sum of the lengths of its operations.
	     *
	     * @returns {Number} The length of this delta
	     */
	    Delta.prototype.length = function () {
	        return this.reduce(function (length, entry) {
	            return length + getOpLength$4(entry);
	        }, 0);
	    };
	    /**
	     * Returns copy of delta with subset of operations.
	     *
	     * @param {Number} start Start index of subset, defaults to 0
	     * @param {Number} end End index of subset, defaults to rest of operations
	     * @returns {Array} An array slice of the operations
	     */
	    Delta.prototype.slice = function (start, end) {
	        if (start === void 0) { start = 0; }
	        if (typeof end !== 'number')
	            end = Infinity;
	        var ops = [];
	        var iter = this.iterator();
	        var index = 0;
	        while (index < end && iter.hasNext()) {
	            var nextOp;
	            if (index < start) {
	                nextOp = iter.next(start - index);
	            }
	            else {
	                nextOp = iter.next(end - index);
	                ops.push(nextOp);
	            }
	            index += getOpLength$4(nextOp);
	        }
	        return new Delta(ops);
	    };
	    /**
	     * Returns a Delta that is equivalent to applying the operations of own Delta, followed by another Delta.
	     *
	     * @param {Delta} other Delta to compose
	     */
	    Delta.prototype.compose = function (other) {
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        var delta = new Delta();
	        while (thisIter.hasNext() || otherIter.hasNext()) {
	            if (otherIter.peekType() === 'insert') {
	                delta._push(otherIter.next());
	            }
	            else if (thisIter.peekType() === 'delete') {
	                delta._push(thisIter.next());
	            }
	            else {
	                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
	                var thisOp = thisIter.next(length);
	                var otherOp = otherIter.next(length);
	                if (typeof otherOp.retain === 'number') {
	                    var newOp = {};
	                    if (typeof thisOp.retain === 'number') {
	                        newOp.retain = length;
	                    }
	                    else {
	                        newOp.insert = thisOp.insert;
	                    }
	                    // Preserve null when composing with a retain, otherwise remove it for inserts
	                    var attributes = composeAttributes$4(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');
	                    if (attributes)
	                        newOp.attributes = attributes;
	                    delta._push(newOp);
	                    // Optimization if rest of other is just retain
	                    if (!otherIter.hasNext() && deepEqual$4(delta.ops[delta.ops.length - 1], newOp)) {
	                        var rest = new Delta(thisIter.rest());
	                        return delta.concat(rest).chop();
	                    }
	                    // Other op should be delete, we could be an insert or retain
	                    // Insert + delete cancels out
	                }
	                else if (typeof otherOp["delete"] === 'number' && typeof thisOp.retain === 'number') {
	                    delta._push(otherOp);
	                }
	            }
	        }
	        return delta.chop();
	    };
	    /**
	     * Returns a new Delta representing the concatenation of this and another document Delta's operations.
	     *
	     * @param {Delta} other Document Delta to concatenate
	     * @returns {Delta} Concatenated document Delta
	     */
	    Delta.prototype.concat = function (other) {
	        var delta = new Delta(this.ops.slice());
	        if (other.ops.length > 0) {
	            delta._push(other.ops[0]);
	            delta.ops = delta.ops.concat(other.ops.slice(1));
	        }
	        return delta;
	    };
	    /**
	     * Returns a Delta representing the difference between two documents. Optionally, accepts a suggested index where
	     * change took place, often representing a cursor position before change.
	     *
	     * @param {Delta} other Document Delta to diff against
	     * @param {Number} index Suggested index where change took place
	     * @returns {Delta} Difference between the two documents
	     */
	    Delta.prototype.diff = function (other, index) {
	        if (this.ops === other.ops) {
	            return new Delta();
	        }
	        var strings = [this, other].map(function (delta) {
	            return delta.map(function (op) {
	                if (op.insert != null) {
	                    return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER$4;
	                }
	                var prep = (delta === other) ? 'on' : 'with';
	                throw new Error('diff() called ' + prep + ' non-document');
	            }).join('');
	        });
	        var delta = new Delta();
	        var diffResult = diff$4(strings[0], strings[1], index);
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        diffResult.forEach(function (component) {
	            var length = component[1].length;
	            while (length > 0) {
	                var opLength = 0;
	                switch (component[0]) {
	                    case diff$4.INSERT:
	                        opLength = Math.min(otherIter.peekLength(), length);
	                        delta._push(otherIter.next(opLength));
	                        break;
	                    case diff$4.DELETE:
	                        opLength = Math.min(length, thisIter.peekLength());
	                        thisIter.next(opLength);
	                        delta["delete"](opLength);
	                        break;
	                    case diff$4.EQUAL:
	                        opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
	                        var thisOp = thisIter.next(opLength);
	                        var otherOp = otherIter.next(opLength);
	                        if (deepEqual$4(thisOp.insert, otherOp.insert)) {
	                            delta.retain(opLength, diffAttributes$4(thisOp.attributes, otherOp.attributes));
	                        }
	                        else {
	                            delta._push(otherOp)["delete"](opLength);
	                        }
	                        break;
	                }
	                length -= opLength;
	            }
	        });
	        return delta.chop();
	    };
	    /**
	     * Iterates through document Delta, calling a given function with a Delta and attributes object, representing the line
	     * segment.
	     *
	     * @param {Function} predicate Function to call on each line group
	     * @param {String} newline Newline character, defaults to \n
	     */
	    Delta.prototype.eachLine = function (predicate, newline) {
	        if (newline === void 0) { newline = '\n'; }
	        var iter = this.iterator();
	        var ops = new Delta();
	        var index = 0;
	        var lineStart = 0;
	        var currentIndex = 0;
	        while (iter.hasNext()) {
	            if (iter.peekType() !== 'insert')
	                return;
	            var op = iter.peek();
	            var nextLength = iter.peekLength();
	            var start = getOpLength$4(op) - nextLength;
	            var newlineIndex = typeof op.insert === 'string' ? op.insert.indexOf(newline, start) - start : -1;
	            if (newlineIndex < 0) {
	                currentIndex += nextLength;
	                ops._push(iter.next());
	            }
	            else if (newlineIndex > 0) {
	                currentIndex += newlineIndex;
	                ops._push(iter.next(newlineIndex));
	            }
	            else {
	                currentIndex += 1;
	                var attributes = iter.next(1).attributes || {};
	                var line = { ops: ops, attributes: attributes, start: lineStart, end: currentIndex, index: index };
	                if (predicate(line, index) === false) {
	                    return;
	                }
	                index += 1;
	                lineStart = currentIndex;
	                ops = new Delta();
	            }
	        }
	        if (ops.length() > 0) {
	            var line_1 = { ops: ops, attributes: {}, start: lineStart, end: currentIndex, index: index };
	            predicate(line_1, index);
	        }
	    };
	    // Extends Delta, get the lines from `from` to `to`.
	    Delta.prototype.getLines = function (from, to, newline) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = Infinity; }
	        var lines = [];
	        this.eachLine(function (line) {
	            if (line.start > to || (line.start === to && from !== to))
	                return false;
	            if (line.end > from) {
	                lines.push(line);
	            }
	        }, newline);
	        return lines;
	    };
	    // Extends Delta, get the line at `at`.
	    Delta.prototype.getLine = function (at, newline) {
	        return this.getLines(at, at, newline)[0];
	    };
	    // Extends Delta, get the ops from `from` to `to`.
	    Delta.prototype.getOps = function (from, to) {
	        var start = 0;
	        var ops = [];
	        this.ops.some(function (op) {
	            if (start >= to)
	                return true;
	            var end = start + getOpLength$4(op);
	            if (end > from || (from === to && end === to)) {
	                ops.push({ op: op, start: start, end: end });
	            }
	            start = end;
	        });
	        return ops;
	    };
	    // Extends Delta, get the op at `at`.
	    Delta.prototype.getOp = function (at) {
	        return this.getOps(at, at)[0];
	    };
	    /**
	     * Transform given Delta against own operations. Used as an alias for transformPosition when called with a number.
	     *
	     * @param {Delta} other Delta to transform
	     * @param {Boolean} priority Boolean used to break ties. If true, then this takes priority over other, that is, its
	     *                           actions are considered to happen "first."
	     * @returns {Delta} Transformed Delta
	     */
	    Delta.prototype.transform = function (other, priority) {
	        if (priority === void 0) { priority = false; }
	        if (typeof other === 'number') {
	            return this.transformPosition(other, priority);
	        }
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        var delta = new Delta();
	        while (thisIter.hasNext() || otherIter.hasNext()) {
	            if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {
	                delta.retain(getOpLength$4(thisIter.next()));
	            }
	            else if (otherIter.peekType() === 'insert') {
	                delta._push(otherIter.next());
	            }
	            else {
	                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
	                var thisOp = thisIter.next(length);
	                var otherOp = otherIter.next(length);
	                if (thisOp["delete"]) {
	                    // Our delete either makes their delete redundant or removes their retain
	                    continue;
	                }
	                else if (otherOp["delete"]) {
	                    delta._push(otherOp);
	                }
	                else {
	                    // We retain either their retain or insert
	                    delta.retain(length, transformAttributes$4(thisOp.attributes, otherOp.attributes, priority));
	                }
	            }
	        }
	        return delta.chop();
	    };
	    /**
	     * Transform an index against the delta. Useful for representing cursor/selection positions.
	     *
	     * @param {Number} index Index to transform
	     * @param {Boolean} priority Boolean used to break ties. If true, then this takes priority over other, that is, its
	     *                           actions are considered to happen "first."
	     * @returns {Number} Transformed index
	     */
	    Delta.prototype.transformPosition = function (index, priority) {
	        if (priority === void 0) { priority = false; }
	        var thisIter = this.iterator();
	        var offset = 0;
	        while (thisIter.hasNext() && offset <= index) {
	            var length = thisIter.peekLength();
	            var nextType = thisIter.peekType();
	            thisIter.next();
	            if (nextType === 'delete') {
	                index -= Math.min(length, index - offset);
	                continue;
	            }
	            else if (nextType === 'insert' && (offset < index || !priority)) {
	                index += length;
	            }
	            offset += length;
	        }
	        return index;
	    };
	    return Delta;
	}());
	/**
	 * Create an attributes object that is equivalent to applying the attributes of the target followed by the source.
	 *
	 * @param {Object} target Target attributes object which will have the source applied to
	 * @param {Object} source Source attributes object being applied to the target
	 * @param {Boolean} keepNull Whether to keep null values from source
	 * @returns {Object} A new attributes object (or undefined if empty) with both
	 */
	function composeAttributes$4(target, source, keepNull) {
	    if (target === void 0) { target = {}; }
	    if (source === void 0) { source = {}; }
	    var attributes = __assign$4({}, target, source);
	    if (!keepNull)
	        Object.keys(attributes).forEach(function (key) {
	            if (attributes[key] == null)
	                delete attributes[key];
	        });
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Finds the difference between two attributes objects. Returns the source attributes that are different from the
	 * target attributes.
	 *
	 * @param {Object} target An attributes object
	 * @param {Object} source An attributes object
	 * @returns {Object} The difference between the two attribute objects or undefined if there is none
	 */
	function diffAttributes$4(target, source) {
	    if (target === void 0) { target = {}; }
	    if (source === void 0) { source = {}; }
	    var attributes = Object.keys(target).concat(Object.keys(source)).reduce(function (attributes, key) {
	        if (!deepEqual$4(target[key], source[key])) {
	            attributes[key] = source[key] === undefined ? null : source[key];
	        }
	        return attributes;
	    }, {});
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Transforms the attributes of source over target (or the other way around if priority is set). Will return an
	 * attributes object which has all the values from source if priority if false or will have the values from source that
	 * are set on target.
	 *
	 * @param {Object} target An attributes object
	 * @param {Object} source An attributes object
	 * @param {Boolean} priority If target has priority over source
	 */
	function transformAttributes$4(target, source, priority) {
	    if (typeof target !== 'object')
	        return source;
	    if (typeof source !== 'object')
	        return undefined;
	    if (!priority)
	        return source; // b simply overwrites us without priority
	    var attributes = Object.keys(source).reduce(function (attributes, key) {
	        if (target[key] === undefined)
	            attributes[key] = source[key]; // null is a valid value
	        return attributes;
	    }, {});
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Determines the length of a Delta operation.
	 *
	 * @param {Object} op An operation entry from a Delta object
	 * @returns {Number} The length of the op
	 */
	function getOpLength$4(op) {
	    if (typeof op["delete"] === 'number') {
	        return op["delete"];
	    }
	    else if (typeof op.retain === 'number') {
	        return op.retain;
	    }
	    else {
	        return typeof op.insert === 'string' ? op.insert.length : 1;
	    }
	}
	/**
	 * An iterator to handle iterating over a list of Delta operations efficiently.
	 */
	var Iterator$4 = /** @class */ (function () {
	    function Iterator(ops) {
	        this.ops = ops;
	        this.index = 0;
	        this.offset = 0;
	    }
	    /**
	     * Determine if there will be another operation returned by `next`.
	     *
	     * @returns {Boolean} Whether there are more operations to iterate over
	     */
	    Iterator.prototype.hasNext = function () {
	        return this.peekLength() < Infinity;
	    };
	    /**
	     * Get the next operation, optionally limited/sliced by length. If an operation is sliced by length, the next call to
	     * `next` will return more of that operation until it is returned in full.
	     *
	     * @param {Number} length Optionally limit the returned operation by length, slicing it down as needed
	     */
	    Iterator.prototype.next = function (length) {
	        if (length === void 0) { length = Infinity; }
	        var nextOp = this.ops[this.index];
	        if (!nextOp)
	            return { retain: Infinity };
	        var offset = this.offset;
	        var opLength = getOpLength$4(nextOp);
	        // Update index and offset
	        if (length >= opLength - offset) {
	            length = opLength - offset;
	            this.index += 1;
	            this.offset = 0;
	        }
	        else {
	            this.offset += length;
	        }
	        if (typeof nextOp["delete"] === 'number') {
	            return { "delete": length };
	        }
	        else {
	            var retOp = {};
	            if (nextOp.attributes) {
	                retOp.attributes = nextOp.attributes;
	            }
	            if (typeof nextOp.retain === 'number') {
	                retOp.retain = length;
	            }
	            else if (typeof nextOp.insert === 'string') {
	                retOp.insert = nextOp.insert.substr(offset, length);
	            }
	            else {
	                // offset should === 0, length should === 1
	                retOp.insert = nextOp.insert;
	            }
	            return retOp;
	        }
	    };
	    /**
	     * Return the next entry.
	     *
	     * @returns {Object} The next entry in the ops array.
	     */
	    Iterator.prototype.peek = function () {
	        return this.ops[this.index];
	    };
	    /**
	     * Check the length of the next entry.
	     *
	     * @returns {Number} The length of the next entry or Infinity if there is no next entry
	     */
	    Iterator.prototype.peekLength = function () {
	        if (this.ops[this.index]) {
	            // Should never return 0 if our index is being managed correctly
	            return getOpLength$4(this.ops[this.index]) - this.offset;
	        }
	        else {
	            return Infinity;
	        }
	    };
	    /**
	     * Check the type of the next entry, delete, retain, or insert.
	     *
	     * @returns {String} The type of the next entry
	     */
	    Iterator.prototype.peekType = function () {
	        if (this.ops[this.index]) {
	            if (typeof this.ops[this.index]["delete"] === 'number') {
	                return 'delete';
	            }
	            else if (typeof this.ops[this.index].retain === 'number') {
	                return 'retain';
	            }
	            else {
	                return 'insert';
	            }
	        }
	        return 'retain';
	    };
	    Iterator.prototype.rest = function () {
	        if (!this.hasNext()) {
	            return [];
	        }
	        else if (this.offset === 0) {
	            return this.ops.slice(this.index);
	        }
	        else {
	            var offset = this.offset;
	            var index = this.index;
	            var next = this.next();
	            var rest = this.ops.slice(this.index);
	            this.offset = offset;
	            this.index = index;
	            return [next].concat(rest);
	        }
	    };
	    return Iterator;
	}());

	var SOURCE_API$4 = 'api';
	var SOURCE_USER$7 = 'user';
	var SOURCE_SILENT$4 = 'silent';
	var empty$4 = {};
	/**
	 * Event for text changes, called before the change has occurred. If a listener returns false the change will be
	 * canceled and not committed.
	 *
	 * @event Editor#text-changing
	 * @type  {Object}
	 * @property {Delta} change       The change which is being applied to the content
	 * @property {Delta} content      The new content after the change
	 * @property {Delta} oldContent   The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * Event for text changes, called after the change has occurred.
	 *
	 * @event Editor#text-change
	 * @type  {Object}
	 * @property {Delta} change       The change which is being applied to the content
	 * @property {Delta} content      The new content after the change
	 * @property {Delta} oldContent   The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * Event for selection changes. If part of a text change the `change`, `content`, and `oldContent` properties will be
	 * set. Otherwise they will not be set.
	 *
	 * @event Editor#selection-change
	 * @type  {Object}
	 * @property {Delta} change       [ Optional ] The change which is being applied to the content
	 * @property {Delta} content      [ Optional ] The new content after the change
	 * @property {Delta} oldContent   [ Optional ] The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * A Typewriter Editor handles the logic for selection and editing of contents. It has no dependency on browser APIs
	 * and can be used in Node.js as easily as the browser. It has no logic to limit formatting (i.e. it does not disallow
	 * using bold, headers, links, or FOOBAR), that will need to be limited outside of the editor itself.
	 *
	 * @fires Editor#text-changing
	 * @fires Editor#text-change
	 * @fires Editor#selection-change
	 *
	 * @readonly @property {Delta}  contents      The data model for the text editor
	 * @readonly @property {Number} length        The length of the contents
	 * @readonly @property {String} text          The text of the contents
	 * @readonly @property {Array}  selection     The current editor selection, a tuple of `[ from, to ]` or `null`
	 * @readonly @property {Object} activeFormats The currently active formats (formats that will apply on the next insert)
	 */
	var Editor$4 = /** @class */ (function (_super) {
	    __extends$4(Editor, _super);
	    /**
	     * Create a new Typewriter editor.
	     *
	     * @param {Object} options Options for this editor include initial `contents` and `modules`:
	     * @param {Delta}  options.contents The initial contents of this editor
	     */
	    function Editor(options) {
	        if (options === void 0) { options = {}; }
	        var _this = _super.call(this) || this;
	        _this.contents = null;
	        _this.length = 0;
	        _this.selection = null;
	        _this.activeFormats = empty$4;
	        setContents$4(_this, options.contents || _this.delta().insert('\n'));
	        _this._queuedEvents = []; // Event queuing ensure they are fired in order
	        return _this;
	    }
	    /**
	     * Convenience method for creating a new delta.
	     *
	     * @param {Array} ops [Optional] The initial ops for the delta
	     * @returns {Delta}   A new Delta object
	     */
	    Editor.prototype.delta = function (ops) {
	        return new Delta$4(ops);
	    };
	    /**
	     * Returns the contents or a slice of them.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {Delta}     The contents of this editor
	     */
	    Editor.prototype.getContents = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.contents.slice(from, to);
	    };
	    /**
	     * Returns the text for the editor or a slice of it.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {String}    The text in the editor
	     */
	    Editor.prototype.getText = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length - 1; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.getContents(from, to)
	            .filter(function (op) { return typeof op.insert === 'string'; })
	            .map(function (op) { return op.insert; })
	            .join('');
	    };
	    /**
	     * Returns the text for the editor with null characters in place of embeds. This can be used to determine the index of
	     * given words or lines of text within the contents.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {String}    The text in the editor with embed spaces
	     */
	    Editor.prototype.getExactText = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length - 1; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.getContents(from, to)
	            .map(function (op) { return typeof op.insert === 'string' ? op.insert : '\0'; })
	            .join('');
	    };
	    /**
	     * Set the selection to a new location (or null for no selection). Will return false if the new selection is the same
	     * as the old selection. Dispatches "selection-change" once the selection is changed. This "selection-change" event
	     * won't have { contents, oldContnts, change } in it since the selection is changing without any content updates.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Boolean}        Whether the selection changed or not
	     */
	    Editor.prototype.setSelection = function (from, to, source) {
	        var _this = this;
	        if (source === void 0) { source = SOURCE_USER$7; }
	        var _a;
	        var oldSelection = this.selection;
	        var selection;
	        if (from === null) {
	            selection = null;
	            if (typeof to === 'string')
	                source = to;
	        }
	        else {
	            _a = this._normalizeSelection(from, to, source), from = _a[0], to = _a[1], source = _a[2];
	            selection = [from, to].map(function (i) { return Math.min(i, _this.length - 1); });
	        }
	        if (shallowEqual$4(oldSelection, selection))
	            return false;
	        // Reset the active formats when selection changes (do this before setting selection)
	        this.activeFormats = selection ? this.getTextFormat(Math.min(selection[0], selection[1])) : empty$4;
	        this.selection = selection;
	        var event = { selection: selection, oldSelection: oldSelection, source: source };
	        if (source !== SOURCE_SILENT$4)
	            this.fire('selection-change', event);
	        this.fire('editor-change', event);
	        return true;
	    };
	    /**
	     * The method that all other methods use to update the contents (even setContents & setText). This method will
	     * dispatch the event "text-changing". If a listener returns `false` then the change will be canceled and null will
	     * be returned. Otherwise, the change will be successful and if the `source` is not "silent" a "text-change" event
	     * will be fired with an event object containing `{ contents, oldContents, selection, oldSelection, source }`. If the
	     * selection has changed as part of this update a "selection-change" event will also be fired with the same event
	     * object.
	     *
	     * @param {Delta} change    A delta change to the document
	     * @param {String} source   The source of the change, user, api, or silent
	     * @param {Array} selection Optional selection after the change has been applied
	     * @returns {Delta}         Returns the change when successful, or null if not
	     */
	    Editor.prototype.updateContents = function (change, source, selection) {
	        if (source === void 0) { source = SOURCE_API$4; }
	        if (!change.chop().ops.length)
	            return null;
	        if (typeof selection === 'number')
	            selection = [selection, selection];
	        var oldContents = this.contents;
	        var contents = normalizeContents$4(oldContents.compose(change));
	        var length = contents.length();
	        var oldSelection = this.selection;
	        if (!selection)
	            selection = oldSelection ? oldSelection.map(function (i) { return change.transform(i); }) : oldSelection;
	        selection = selection && this.getSelectedRange(selection, length - 1);
	        var changeEvent = { contents: contents, oldContents: oldContents, change: change, selection: selection, oldSelection: oldSelection, source: source };
	        var selectionChanged = !shallowEqual$4(oldSelection, selection);
	        if (!this.fire('text-changing', changeEvent))
	            return null;
	        setContents$4(this, contents);
	        if (selection) {
	            // Reset the active formats when selection changes (do this before setting selection)
	            this.activeFormats = selection ? this.getTextFormat(Math.min(selection[0], selection[1])) : empty$4;
	            this.selection = selection;
	        }
	        var events = [];
	        if (source !== SOURCE_SILENT$4) {
	            events.push(['text-change', changeEvent]);
	            if (selectionChanged)
	                events.push(['selection-change', changeEvent]);
	        }
	        events.push(['editor-change', changeEvent]);
	        this._queueEvents(events);
	        return change;
	    };
	    /**
	     * Sets the entire contents of the editor. This will calculate the difference between the old content and the new and
	     * only apply the difference, if any.
	     *
	     * @param {Delta} newContents The contents of the editor, as a delta object
	     * @param {String} source     The source of the change, user, api, or silent
	     * @param {Array} selection   Optional selection after the change has been applied
	     * @returns {Delta}           Returns the change when successful, or null if not
	     */
	    Editor.prototype.setContents = function (newContents, source, selection) {
	        var change = this.contents.diff(normalizeContents$4(newContents));
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Sets the text content of the editor, removing existing contents and formatting.
	     *
	     * @param {String} text     Set the contents of this editor as text
	     * @param {String} source   The source of the change, user, api, or silent
	     * @param {Array} selection Optional selection after the change has been applied
	     * @returns {Delta}         Returns the change when successful, or null if not
	     */
	    Editor.prototype.setText = function (text, source, selection) {
	        return this.setContents(this.delta().insert(text + '\n'), source, selection);
	    };
	    /**
	     * Inserts text into the content of the editor, removing text between from and to if provided. If `text` is a newline
	     * ("\n") then the formats will apply to the line, otherwise they will apply to the text only (even if there are
	     * newlines in the text).
	     *
	     * @param {Number} from      Insert the text at this index, can also be a range Array tuple, default 0
	     * @param {Number} to        If provided and not equal to `from` will delete the text between `from` and `to`
	     * @param {String} text      The text to insert into the editor's contents
	     * @param {Object} formats   The formats of the inserted text. If null the formats at `from` will be used.
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.insertText = function (from, to, text, formats, source, selection) {
	        var _a, _b, _c;
	        _a = this._normalizeRange(from, to, text, formats, source, selection), from = _a[0], to = _a[1], text = _a[2], formats = _a[3], source = _a[4], selection = _a[5];
	        // If we are not inserting a newline, make sure from and to are within the selectable range
	        if (text !== '\n')
	            _b = this.getSelectedRange([from, to]), from = _b[0], to = _b[1];
	        if (typeof formats === 'string')
	            _c = [null, formats, source], formats = _c[0], source = _c[1], selection = _c[2];
	        if (selection == null && this.selection !== null)
	            selection = from + text.length;
	        var change = this.delta().retain(from)["delete"](to - from);
	        if (text === '\n') {
	            change.insert('\n', formats || this.getLineFormat(from));
	        }
	        else {
	            var lineFormat_1 = text.indexOf('\n') === -1 ? null : this.getLineFormat(from);
	            var textFormat_1 = formats || this.getTextFormat(from);
	            text.split('\n').forEach(function (line, i) {
	                if (i)
	                    change.insert('\n', lineFormat_1);
	                line.length && change.insert(line, textFormat_1);
	            });
	        }
	        change = cleanDelete$4(this, from, to, change);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Inserts an embed into the content of the editor, removing text between from and to if provided.
	     *
	     * @param {Number} from      Insert the embed at this index, can also be a range Array tuple, default 0
	     * @param {Number} to        If provided and not equal to `from` will delete the text between `from` and `to`
	     * @param {String} embed     Insert the text into the editor's contents
	     * @param {mixed}  value     Insert the text into the editor's contents
	     * @param {String} formats   The formats of the inserted text. If null the formats at `from` will be used.
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.insertEmbed = function (from, to, embed, value, formats, source, selection) {
	        var _a, _b, _c;
	        _a = this._normalizeRange(from, to, embed, value, source, selection), from = _a[0], to = _a[1], embed = _a[2], value = _a[3], source = _a[4], selection = _a[5];
	        if (typeof formats === 'string')
	            _b = [null, formats, source], formats = _b[0], source = _b[1], selection = _b[2];
	        if (from >= this.length)
	            from = this.length - 1;
	        if (to >= this.length)
	            to = this.length - 1;
	        if (selection == null && this.selection !== null)
	            selection = from + 1;
	        var textFormat = formats || this.getTextFormat(from);
	        var change = this.delta().retain(from)["delete"](to - from).insert((_c = {}, _c[embed] = value, _c), textFormat);
	        change = cleanDelete$4(this, from, to, change);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Deletes text from `from` to `to`.
	     *
	     * @param {Number} from      Insert the text as this index, can also be a range Array tuple, default 0
	     * @param {Number} to        Will delete the text between `from` and `to`
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.deleteText = function (from, to, source, selection) {
	        var _a;
	        _a = this._normalizeRange(from, to, source, selection), from = _a[0], to = _a[1], source = _a[2], selection = _a[3];
	        if (from === to)
	            return null;
	        if (selection == null && this.selection !== null)
	            selection = from;
	        var change = this.delta().retain(from)["delete"](to - from);
	        change = cleanDelete$4(this, from, to, change);
	        // Keep the active format of the text to the right of the cursor when deleting
	        var activeFormats;
	        if (selection === from)
	            activeFormats = this.getTextFormat(from, from + 1);
	        var result = this.updateContents(change, source, selection);
	        if (result && activeFormats)
	            this.activeFormats = activeFormats;
	        return result;
	    };
	    /**
	     * Get the line formats for the line that `from` is in to the line that `to` is in. Returns only the common formats
	     * between all the lines. If `from` equals `to` (or `to` is not provided) the formats will be all of those for the
	     * line `from` is on. If two lines are touched and they have different formats, an empty object will be returned.
	     *
	     * @param {Number} from Getting line formats starting at `from`
	     * @param {Number} to   Getting line formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the lines which intersect from and to
	     */
	    Editor.prototype.getLineFormat = function (from, to) {
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        var formats;
	        this.contents.getLines(from, to).forEach(function (line) {
	            if (!line.attributes)
	                formats = {};
	            else if (!formats)
	                formats = __assign$4({}, line.attributes);
	            else
	                formats = combineFormats$4(formats, line.attributes);
	        });
	        return formats;
	    };
	    /**
	     * Get the text formats for all the text from `from` to `to`. Returns only the common formats between the two indexes.
	     * Will also return the `activeFormats`. Active formats are those which are toggled on when the selection is collapsed
	     * (from and to are equal) indicating inserted text should use (or not use) those formats.
	     *
	     * @param {Number} from Getting text formats starting at `from`
	     * @param {Number} to   Getting text formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the text
	     */
	    Editor.prototype.getTextFormat = function (from, to) {
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        var formats;
	        // optimize for current selection
	        var seleciton = this.selection;
	        if (from === to && shallowEqual$4(this.selection, [from, to])) {
	            return this.activeFormats;
	        }
	        this.contents.getOps(from, to).forEach(function (_a) {
	            var op = _a.op;
	            if (/^\n+$/.test(op.insert))
	                return;
	            if (!op.attributes)
	                formats = {};
	            else if (!formats)
	                formats = __assign$4({}, op.attributes);
	            else
	                formats = combineFormats$4(formats, op.attributes);
	        });
	        if (!formats)
	            formats = {};
	        return formats;
	    };
	    /**
	     * Get the text and line formats for all the lines and text from `from` to `to`.
	     *
	     * @param {Number} from Getting line and text formats starting at `from`
	     * @param {Number} to   Getting line and text formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the lines and text which intersect from and to
	     */
	    Editor.prototype.getFormat = function (from, to) {
	        return __assign$4({}, this.getTextFormat(from, to), this.getLineFormat(from, to));
	    };
	    /**
	     * Formats the lines intersected by `from` and `to` with the given line formats. To remove an existing format pass in
	     * `null` or `false` to turn it off (e.g. `{ blockquote: false }`).
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the line
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.formatLine = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var change = this.delta();
	        this.contents.getLines(from, to).forEach(function (line) {
	            if (!change.ops.length)
	                change.retain(line.end - 1);
	            else
	                change.retain(line.end - line.start - 1);
	            // Clear out old formats on the line
	            Object.keys(line.attributes).forEach(function (name) { return !formats[name] && (formats[name] = null); });
	            change.retain(1, formats);
	        });
	        change.chop();
	        return change.ops.length ? this.updateContents(change, source) : null;
	    };
	    /**
	     * Formats the text from `from` to `to` with the given text formats. To remove an existing format pass in `null` or
	     * `false` to turn it off (e.g. `{ bold: false }`).
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the text
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.formatText = function (from, to, formats, source) {
	        var _this = this;
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        if (from === to) {
	            if (this.activeFormats === empty$4)
	                this.activeFormats = {};
	            Object.keys(formats).forEach(function (key) {
	                var value = formats[key];
	                if (value == null || value === false)
	                    delete _this.activeFormats[key];
	                else
	                    _this.activeFormats[key] = value;
	            });
	            return;
	        }
	        Object.keys(formats).forEach(function (name) { return formats[name] === false && (formats[name] = null); });
	        var change = this.delta().retain(from);
	        this.getText(from, to).split('\n').forEach(function (line) {
	            line.length && change.retain(line.length, formats);
	            change.retain(1);
	        });
	        change.chop();
	        return this.updateContents(change, source);
	    };
	    /**
	     * Toggles the line formats from `from` to `to` with the given line formats. If the line has the exact formats already
	     * they will be removed, otherwise they will be added.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the line
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.toggleLineFormat = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var existing = this.getLineFormat(from, to);
	        if (deepEqual$4(existing, formats)) {
	            Object.keys(formats).forEach(function (key) { return formats[key] = null; });
	        }
	        return this.formatLine(from, to, formats, source);
	    };
	    /**
	     * Toggles the text formats from `from` to `to` with the given text formats. If the text has the exact formats already
	     * they will be removed, otherwise they will be added.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the text
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.toggleTextFormat = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var existing = this.getTextFormat(from, to);
	        var isSame = Object.keys(formats).every(function (key) { return formats[key] === existing[key]; });
	        if (isSame) {
	            Object.keys(formats).forEach(function (key) { return formats[key] = null; });
	        }
	        return this.formatText(from, to, formats, source);
	    };
	    /**
	     * Removes all formatting, text and line formats, for the text and lines from `from` to `to`.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.removeFormats = function (from, to, source) {
	        var _this = this;
	        var _a;
	        _a = this._normalizeRange(from, to, source), from = _a[0], to = _a[1], source = _a[2];
	        var formats = {};
	        this.contents.getOps(from, to).forEach(function (_a) {
	            var op = _a.op;
	            op.attributes && Object.keys(op.attributes).forEach(function (key) { return formats[key] = null; });
	        });
	        var change = this.delta().retain(from).retain(to - from, formats);
	        // If the last block was not captured be sure to clear that too
	        this.contents.getLines(from, to).forEach(function (line) {
	            var formats = {};
	            Object.keys(line.attributes).forEach(function (key) { return formats[key] = null; });
	            change = change.compose(_this.delta().retain(line.end - 1).retain(1, formats));
	        });
	        return this.updateContents(change, source);
	    };
	    /**
	     * Create a change delta calling one or more methods on the editor. The changes will not be applied as normal but will
	     * be collated into a single change delta and returned from this methnod. Example:
	     * ```js
	     * var change = editor.getChange(function() {
	     *   editor.deleteText(0, 5);
	     *   editor.insertText('\n', { blockquote: true });
	     *   editor.formatText(10, 20, { bold: true });
	     * });
	     *
	     * editor.updateContents(change, 'user');
	     * ```
	     *
	     * @param {Function} producer A function in which to call methods on the editor to produce a change
	     * @returns {Delta}           The sum of all the changes made within the producer
	     */
	    Editor.prototype.getChange = function (producer) {
	        var change = this.delta();
	        this.updateContents = function (singleChange) {
	            if (singleChange.ops.length) {
	                change = change.compose(singleChange);
	                return singleChange;
	            }
	            else {
	                return null;
	            }
	        };
	        producer(this);
	        delete this.updateContents;
	        return change;
	    };
	    /**
	     * Make several changes to the editor apply all at one in one commit. Changes made with the transaction will be
	     * applied all together and the "text-changing", "text-change", and "selection-change" events will be dispatched only
	     * once. Use this to combine multiple changes into one.
	     *
	     * @param {Function} producer A function which should make changes with the editor
	     * @param {String} source     The source of the change, user, api, or silent
	     * @param {Array} selection   Optional selection after the change has been applied
	     * @returns {Delta}           Returns the change when successful, or null if not
	     */
	    Editor.prototype.transaction = function (producer, source, selection) {
	        var change = this.getChange(producer);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Returns the selected range (or the provided range) in index order (lowest number first) and within the bounds of
	     * the content, between 0 and content.length() - 1 (the selection cannot be past the trailing newline).
	     *
	     * @param {Array} range Optional range, defaults to current selection
	     * @param {Number} max  The maxium number the range can be
	     */
	    Editor.prototype.getSelectedRange = function (range, max) {
	        if (range === void 0) { range = this.selection; }
	        if (max === void 0) { max = this.length - 1; }
	        var _a;
	        if (range == null)
	            return range;
	        if (typeof range === 'number')
	            range = [range, range];
	        if (range[0] > range[1])
	            _a = [range[1], range[0]], range[0] = _a[0], range[1] = _a[1];
	        return range.map(function (index) { return Math.max(0, Math.min(max, index)); });
	    };
	    Editor.prototype._queueEvents = function (events) {
	        var _a;
	        var alreadyRunning = this._queuedEvents.length;
	        (_a = this._queuedEvents).push.apply(_a, events);
	        if (alreadyRunning)
	            return;
	        while (this._queuedEvents.length) {
	            var event = this._queuedEvents.shift();
	            this.fire.apply(this, event);
	        }
	    };
	    /**
	     * Normalizes range values to a proper range if it is not already. A range is a `from` and a `to` index, e.g. 0, 4.
	     * This will ensure the lower index is first. Example usage:
	     * editor._normalizeRange(5); // [5, 5]
	     * editor._normalizeRange(-4, 100); // for a doc with length 10, [0, 10]
	     * editor._normalizeRange(25, 18); // [18, 25]
	     * editor._normalizeRange([12, 13]); // [12, 13]
	     * editor._normalizeRange(5, { bold: true }); // [5, 5, { bold: true }]
	     */
	    Editor.prototype._normalizeRange = function (from, to) {
	        var rest = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            rest[_i - 2] = arguments[_i];
	        }
	        var _a;
	        _a = this._normalizeSelection.apply(this, [from, to].concat(rest)), from = _a[0], to = _a[1], rest = _a.slice(2);
	        if (from > to) {
	            var toValue = from;
	            from = to;
	            to = toValue;
	        }
	        return [from, to].concat(rest);
	    };
	    Editor.prototype._normalizeSelection = function (from, to) {
	        var rest = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            rest[_i - 2] = arguments[_i];
	        }
	        var _a;
	        if (Array.isArray(from)) {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            _a = from, from = _a[0], to = _a[1];
	            if (to === undefined)
	                to = from;
	        }
	        else if (typeof from !== 'number') {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            if (from !== undefined || rest.length)
	                rest.unshift(from);
	            from = to = 0;
	        }
	        else if (typeof to !== 'number') {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            to = from;
	        }
	        from = Math.max(0, Math.min(this.length, Math.floor(from)));
	        to = Math.max(0, Math.min(this.length, Math.floor(to)));
	        return [from, to].concat(rest);
	    };
	    return Editor;
	}(EventDispatcher$4));
	// Ensures the format for the current line in a delete remains the same when multiple lines are deleted. This is needed
	// because the last line holds the formatting after a delete, but the first line is expected to be the retained format
	function cleanDelete$4(editor, from, to, change) {
	    if (from !== to) {
	        var line = editor.contents.getLine(from);
	        if (!line.ops.length() && to === from + 1)
	            return change;
	        var lineFormat_2 = editor.getLineFormat(from);
	        if (!deepEqual$4(lineFormat_2, editor.getLineFormat(to))) {
	            var lineChange = editor.getChange(function () { return editor.formatLine(to, lineFormat_2); });
	            change = change.compose(change.transform(lineChange));
	        }
	    }
	    return change;
	}
	// Ensures contents end with a newline
	function normalizeContents$4(contents) {
	    // Contents only have inserts. Deletes and retains belong to changes only.
	    contents.ops = contents.ops.filter(function (op) { return op.insert; });
	    var lastOp = contents.ops[contents.ops.length - 1];
	    if (!lastOp || typeof lastOp.insert !== 'string' || lastOp.insert.slice(-1) !== '\n')
	        contents.insert('\n');
	    return contents;
	}
	// Sets the contents onto the editor after ensuring they end in a newline, freezes the contents from change, and
	// updates the length and text of the editor to the latest
	function setContents$4(editor, contents) {
	    contents = normalizeContents$4(contents);
	    contents.freeze();
	    editor.contents = contents;
	    editor.length = contents.length();
	}
	// Combine formats removing ones that don't exist in both and creating an array for those with multiple values
	function combineFormats$4(formats, combined) {
	    return Object.keys(combined).reduce(function (merged, name) {
	        if (formats[name] == null)
	            return merged;
	        if (combined[name] === formats[name]) {
	            merged[name] = combined[name];
	        }
	        else if (Array.isArray(combined[name])) {
	            if (combined[name].indexOf(formats[name]) < 0) {
	                merged[name] = combined[name].concat([formats[name]]);
	            }
	        }
	        else {
	            merged[name] = [combined[name], formats[name]];
	        }
	        return merged;
	    }, {});
	}

	/**
	 * Defines the blocks, marks, and embeds that can be used in a Typewriter document.
	 */

	// Determines if a <br> in the editable area is part of the document or a doorstop at the end of a block.
	function isBRPlaceholder$2(paper, node) {
	    if (node.nodeName !== 'BR')
	        return false;
	    var blocks = paper.blocks;
	    var next = node.nextSibling;
	    while (next && next.nodeValue === '')
	        next = next.nextSibling;
	    if (next) {
	        return next.nodeType === Node.ELEMENT_NODE && blocks.matches(next);
	    }
	    return blocks.matches(node.parentNode);
	}

	var dispatcherEvents$1$2 = new WeakMap();
	var EventDispatcher$1$2 = /** @class */ (function () {
	    function EventDispatcher() {
	    }
	    EventDispatcher.prototype.on = function (type, listener) {
	        getEventListeners$1$2(this, type, true).add(listener);
	    };
	    EventDispatcher.prototype.off = function (type, listener) {
	        var events = getEventListeners$1$2(this, type);
	        events && events["delete"](listener);
	    };
	    EventDispatcher.prototype.once = function (type, listener) {
	        function once() {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            this.off(type, once);
	            listener.apply(this, args);
	        }
	        this.on(type, once);
	    };
	    EventDispatcher.prototype.fire = function (type) {
	        var _this = this;
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        var uncanceled = true;
	        var events = getEventListeners$1$2(this, type);
	        if (events)
	            events.forEach(function (listener) {
	                uncanceled && listener.apply(_this, args) !== false || (uncanceled = false);
	            });
	        return uncanceled;
	    };
	    return EventDispatcher;
	}());
	function getEventListeners$1$2(obj, type, autocreate) {
	    if (autocreate === void 0) { autocreate = false; }
	    var events = dispatcherEvents$1$2.get(obj);
	    if (!events && autocreate)
	        dispatcherEvents$1$2.set(obj, events = Object.create(null));
	    return events && events[type] || autocreate && (events[type] = new Set());
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics$1$2 = function(d, b) {
	    extendStatics$1$2 = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return extendStatics$1$2(d, b);
	};

	function __extends$1$2(d, b) {
	    extendStatics$1$2(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign$1$2 = function() {
	    __assign$1$2 = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1$2.apply(this, arguments);
	};

	/**
	 * This library modifies the diff-patch-match library by Neil Fraser
	 * by removing the patch and match functionality and certain advanced
	 * options in the diff function. The original license is as follows:
	 *
	 * ===
	 *
	 * Diff Match and Patch
	 *
	 * Copyright 2006 Google Inc.
	 * http://code.google.com/p/google-diff-match-patch/
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * The data structure representing a diff is an array of tuples:
	 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
	 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
	 */
	var DIFF_DELETE$1$2 = -1;
	var DIFF_INSERT$1$2 = 1;
	var DIFF_EQUAL$1$2 = 0;
	/**
	 * Find the differences between two texts.  Simplifies the problem by stripping
	 * any common prefix or suffix off the texts before diffing.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {Int} cursor_pos Expected edit position in text1 (optional)
	 * @return {Array} Array of diff tuples.
	 */
	function diff$1$2(text1, text2, cursor_pos) {
	    // Check for equality (speedup).
	    if (text1 == text2) {
	        if (text1) {
	            return [[DIFF_EQUAL$1$2, text1]];
	        }
	        return [];
	    }
	    // Check cursor_pos within bounds
	    if (cursor_pos < 0 || text1.length < cursor_pos) {
	        cursor_pos = null;
	    }
	    // Trim off common prefix (speedup).
	    var commonlength = diff_commonPrefix$1$2(text1, text2);
	    var commonprefix = text1.substring(0, commonlength);
	    text1 = text1.substring(commonlength);
	    text2 = text2.substring(commonlength);
	    // Trim off common suffix (speedup).
	    commonlength = diff_commonSuffix$1$2(text1, text2);
	    var commonsuffix = text1.substring(text1.length - commonlength);
	    text1 = text1.substring(0, text1.length - commonlength);
	    text2 = text2.substring(0, text2.length - commonlength);
	    // Compute the diff on the middle block.
	    var diffs = diff_compute_$1$2(text1, text2);
	    // Restore the prefix and suffix.
	    if (commonprefix) {
	        diffs.unshift([DIFF_EQUAL$1$2, commonprefix]);
	    }
	    if (commonsuffix) {
	        diffs.push([DIFF_EQUAL$1$2, commonsuffix]);
	    }
	    diff_cleanupMerge$1$2(diffs);
	    if (cursor_pos != null) {
	        diffs = fix_cursor$1$2(diffs, cursor_pos);
	    }
	    diffs = fix_emoji$1$2(diffs);
	    return diffs;
	}
	/**
	 * Find the differences between two texts.  Assumes that the texts do not
	 * have any common prefix or suffix.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @return {Array} Array of diff tuples.
	 */
	function diff_compute_$1$2(text1, text2) {
	    var diffs;
	    if (!text1) {
	        // Just add some text (speedup).
	        return [[DIFF_INSERT$1$2, text2]];
	    }
	    if (!text2) {
	        // Just delete some text (speedup).
	        return [[DIFF_DELETE$1$2, text1]];
	    }
	    var longtext = text1.length > text2.length ? text1 : text2;
	    var shorttext = text1.length > text2.length ? text2 : text1;
	    var i = longtext.indexOf(shorttext);
	    if (i != -1) {
	        // Shorter text is inside the longer text (speedup).
	        diffs = [[DIFF_INSERT$1$2, longtext.substring(0, i)],
	            [DIFF_EQUAL$1$2, shorttext],
	            [DIFF_INSERT$1$2, longtext.substring(i + shorttext.length)]];
	        // Swap insertions for deletions if diff is reversed.
	        if (text1.length > text2.length) {
	            diffs[0][0] = diffs[2][0] = DIFF_DELETE$1$2;
	        }
	        return diffs;
	    }
	    if (shorttext.length == 1) {
	        // Single character string.
	        // After the previous speedup, the character can't be an equality.
	        return [[DIFF_DELETE$1$2, text1], [DIFF_INSERT$1$2, text2]];
	    }
	    // Check to see if the problem can be split in two.
	    var hm = diff_halfMatch_$1$2(text1, text2);
	    if (hm) {
	        // A half-match was found, sort out the return data.
	        var text1_a = hm[0];
	        var text1_b = hm[1];
	        var text2_a = hm[2];
	        var text2_b = hm[3];
	        var mid_common = hm[4];
	        // Send both pairs off for separate processing.
	        var diffs_a = diff$1$2(text1_a, text2_a);
	        var diffs_b = diff$1$2(text1_b, text2_b);
	        // Merge the results.
	        return diffs_a.concat([[DIFF_EQUAL$1$2, mid_common]], diffs_b);
	    }
	    return diff_bisect_$1$2(text1, text2);
	}
	/**
	 * Find the 'middle snake' of a diff, split the problem in two
	 * and return the recursively constructed diff.
	 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @return {Array} Array of diff tuples.
	 * @private
	 */
	function diff_bisect_$1$2(text1, text2) {
	    // Cache the text lengths to prevent multiple calls.
	    var text1_length = text1.length;
	    var text2_length = text2.length;
	    var max_d = Math.ceil((text1_length + text2_length) / 2);
	    var v_offset = max_d;
	    var v_length = 2 * max_d;
	    var v1 = new Array(v_length);
	    var v2 = new Array(v_length);
	    // Setting all elements to -1 is faster in Chrome & Firefox than mixing
	    // integers and undefined.
	    for (var x = 0; x < v_length; x++) {
	        v1[x] = -1;
	        v2[x] = -1;
	    }
	    v1[v_offset + 1] = 0;
	    v2[v_offset + 1] = 0;
	    var delta = text1_length - text2_length;
	    // If the total number of characters is odd, then the front path will collide
	    // with the reverse path.
	    var front = (delta % 2 != 0);
	    // Offsets for start and end of k loop.
	    // Prevents mapping of space beyond the grid.
	    var k1start = 0;
	    var k1end = 0;
	    var k2start = 0;
	    var k2end = 0;
	    for (var d = 0; d < max_d; d++) {
	        // Walk the front path one step.
	        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
	            var k1_offset = v_offset + k1;
	            var x1;
	            if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
	                x1 = v1[k1_offset + 1];
	            }
	            else {
	                x1 = v1[k1_offset - 1] + 1;
	            }
	            var y1 = x1 - k1;
	            while (x1 < text1_length && y1 < text2_length &&
	                text1.charAt(x1) == text2.charAt(y1)) {
	                x1++;
	                y1++;
	            }
	            v1[k1_offset] = x1;
	            if (x1 > text1_length) {
	                // Ran off the right of the graph.
	                k1end += 2;
	            }
	            else if (y1 > text2_length) {
	                // Ran off the bottom of the graph.
	                k1start += 2;
	            }
	            else if (front) {
	                var k2_offset = v_offset + delta - k1;
	                if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
	                    // Mirror x2 onto top-left coordinate system.
	                    var x2 = text1_length - v2[k2_offset];
	                    if (x1 >= x2) {
	                        // Overlap detected.
	                        return diff_bisectSplit_$1$2(text1, text2, x1, y1);
	                    }
	                }
	            }
	        }
	        // Walk the reverse path one step.
	        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
	            var k2_offset = v_offset + k2;
	            var x2;
	            if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
	                x2 = v2[k2_offset + 1];
	            }
	            else {
	                x2 = v2[k2_offset - 1] + 1;
	            }
	            var y2 = x2 - k2;
	            while (x2 < text1_length && y2 < text2_length &&
	                text1.charAt(text1_length - x2 - 1) ==
	                    text2.charAt(text2_length - y2 - 1)) {
	                x2++;
	                y2++;
	            }
	            v2[k2_offset] = x2;
	            if (x2 > text1_length) {
	                // Ran off the left of the graph.
	                k2end += 2;
	            }
	            else if (y2 > text2_length) {
	                // Ran off the top of the graph.
	                k2start += 2;
	            }
	            else if (!front) {
	                var k1_offset = v_offset + delta - k2;
	                if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
	                    var x1 = v1[k1_offset];
	                    var y1 = v_offset + x1 - k1_offset;
	                    // Mirror x2 onto top-left coordinate system.
	                    x2 = text1_length - x2;
	                    if (x1 >= x2) {
	                        // Overlap detected.
	                        return diff_bisectSplit_$1$2(text1, text2, x1, y1);
	                    }
	                }
	            }
	        }
	    }
	    // Diff took too long and hit the deadline or
	    // number of diffs equals number of characters, no commonality at all.
	    return [[DIFF_DELETE$1$2, text1], [DIFF_INSERT$1$2, text2]];
	}
	/**
	 * Given the location of the 'middle snake', split the diff in two parts
	 * and recurse.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} x Index of split point in text1.
	 * @param {number} y Index of split point in text2.
	 * @return {Array} Array of diff tuples.
	 */
	function diff_bisectSplit_$1$2(text1, text2, x, y) {
	    var text1a = text1.substring(0, x);
	    var text2a = text2.substring(0, y);
	    var text1b = text1.substring(x);
	    var text2b = text2.substring(y);
	    // Compute both diffs serially.
	    var diffs = diff$1$2(text1a, text2a);
	    var diffsb = diff$1$2(text1b, text2b);
	    return diffs.concat(diffsb);
	}
	/**
	 * Determine the common prefix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the start of each
	 *     string.
	 */
	function diff_commonPrefix$1$2(text1, text2) {
	    // Quick check for common null cases.
	    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
	        return 0;
	    }
	    // Binary search.
	    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	    var pointermin = 0;
	    var pointermax = Math.min(text1.length, text2.length);
	    var pointermid = pointermax;
	    var pointerstart = 0;
	    while (pointermin < pointermid) {
	        if (text1.substring(pointerstart, pointermid) ==
	            text2.substring(pointerstart, pointermid)) {
	            pointermin = pointermid;
	            pointerstart = pointermin;
	        }
	        else {
	            pointermax = pointermid;
	        }
	        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }
	    return pointermid;
	}
	/**
	 * Determine the common suffix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the end of each string.
	 */
	function diff_commonSuffix$1$2(text1, text2) {
	    // Quick check for common null cases.
	    if (!text1 || !text2 ||
	        text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
	        return 0;
	    }
	    // Binary search.
	    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	    var pointermin = 0;
	    var pointermax = Math.min(text1.length, text2.length);
	    var pointermid = pointermax;
	    var pointerend = 0;
	    while (pointermin < pointermid) {
	        if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
	            text2.substring(text2.length - pointermid, text2.length - pointerend)) {
	            pointermin = pointermid;
	            pointerend = pointermin;
	        }
	        else {
	            pointermax = pointermid;
	        }
	        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }
	    return pointermid;
	}
	/**
	 * Do the two texts share a substring which is at least half the length of the
	 * longer text?
	 * This speedup can produce non-minimal diffs.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {Array.<string>} Five element Array, containing the prefix of
	 *     text1, the suffix of text1, the prefix of text2, the suffix of
	 *     text2 and the common middle.  Or null if there was no match.
	 */
	function diff_halfMatch_$1$2(text1, text2) {
	    var longtext = text1.length > text2.length ? text1 : text2;
	    var shorttext = text1.length > text2.length ? text2 : text1;
	    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
	        return null; // Pointless.
	    }
	    /**
	     * Does a substring of shorttext exist within longtext such that the substring
	     * is at least half the length of longtext?
	     * Closure, but does not reference any external variables.
	     * @param {string} longtext Longer string.
	     * @param {string} shorttext Shorter string.
	     * @param {number} i Start index of quarter length substring within longtext.
	     * @return {Array.<string>} Five element Array, containing the prefix of
	     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
	     *     of shorttext and the common middle.  Or null if there was no match.
	     * @private
	     */
	    function diff_halfMatchI_(longtext, shorttext, i) {
	        // Start with a 1/4 length substring at position i as a seed.
	        var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
	        var j = -1;
	        var best_common = '';
	        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
	        while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
	            var prefixLength = diff_commonPrefix$1$2(longtext.substring(i), shorttext.substring(j));
	            var suffixLength = diff_commonSuffix$1$2(longtext.substring(0, i), shorttext.substring(0, j));
	            if (best_common.length < suffixLength + prefixLength) {
	                best_common = shorttext.substring(j - suffixLength, j) +
	                    shorttext.substring(j, j + prefixLength);
	                best_longtext_a = longtext.substring(0, i - suffixLength);
	                best_longtext_b = longtext.substring(i + prefixLength);
	                best_shorttext_a = shorttext.substring(0, j - suffixLength);
	                best_shorttext_b = shorttext.substring(j + prefixLength);
	            }
	        }
	        if (best_common.length * 2 >= longtext.length) {
	            return [best_longtext_a, best_longtext_b,
	                best_shorttext_a, best_shorttext_b, best_common];
	        }
	        else {
	            return null;
	        }
	    }
	    // First check if the second quarter is the seed for a half-match.
	    var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
	    // Check again based on the third quarter.
	    var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
	    var hm;
	    if (!hm1 && !hm2) {
	        return null;
	    }
	    else if (!hm2) {
	        hm = hm1;
	    }
	    else if (!hm1) {
	        hm = hm2;
	    }
	    else {
	        // Both matched.  Select the longest.
	        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
	    }
	    // A half-match was found, sort out the return data.
	    var text1_a, text1_b, text2_a, text2_b;
	    if (text1.length > text2.length) {
	        text1_a = hm[0];
	        text1_b = hm[1];
	        text2_a = hm[2];
	        text2_b = hm[3];
	    }
	    else {
	        text2_a = hm[0];
	        text2_b = hm[1];
	        text1_a = hm[2];
	        text1_b = hm[3];
	    }
	    var mid_common = hm[4];
	    return [text1_a, text1_b, text2_a, text2_b, mid_common];
	}
	/**
	 * Reorder and merge like edit sections.  Merge equalities.
	 * Any edit section can move as long as it doesn't cross an equality.
	 * @param {Array} diffs Array of diff tuples.
	 */
	function diff_cleanupMerge$1$2(diffs) {
	    diffs.push([DIFF_EQUAL$1$2, '']); // Add a dummy entry at the end.
	    var pointer = 0;
	    var count_delete = 0;
	    var count_insert = 0;
	    var text_delete = '';
	    var text_insert = '';
	    var commonlength;
	    while (pointer < diffs.length) {
	        switch (diffs[pointer][0]) {
	            case DIFF_INSERT$1$2:
	                count_insert++;
	                text_insert += diffs[pointer][1];
	                pointer++;
	                break;
	            case DIFF_DELETE$1$2:
	                count_delete++;
	                text_delete += diffs[pointer][1];
	                pointer++;
	                break;
	            case DIFF_EQUAL$1$2:
	                // Upon reaching an equality, check for prior redundancies.
	                if (count_delete + count_insert > 1) {
	                    if (count_delete !== 0 && count_insert !== 0) {
	                        // Factor out any common prefixies.
	                        commonlength = diff_commonPrefix$1$2(text_insert, text_delete);
	                        if (commonlength !== 0) {
	                            if ((pointer - count_delete - count_insert) > 0 &&
	                                diffs[pointer - count_delete - count_insert - 1][0] ==
	                                    DIFF_EQUAL$1$2) {
	                                diffs[pointer - count_delete - count_insert - 1][1] +=
	                                    text_insert.substring(0, commonlength);
	                            }
	                            else {
	                                diffs.splice(0, 0, [DIFF_EQUAL$1$2,
	                                    text_insert.substring(0, commonlength)]);
	                                pointer++;
	                            }
	                            text_insert = text_insert.substring(commonlength);
	                            text_delete = text_delete.substring(commonlength);
	                        }
	                        // Factor out any common suffixies.
	                        commonlength = diff_commonSuffix$1$2(text_insert, text_delete);
	                        if (commonlength !== 0) {
	                            diffs[pointer][1] = text_insert.substring(text_insert.length -
	                                commonlength) + diffs[pointer][1];
	                            text_insert = text_insert.substring(0, text_insert.length -
	                                commonlength);
	                            text_delete = text_delete.substring(0, text_delete.length -
	                                commonlength);
	                        }
	                    }
	                    // Delete the offending records and add the merged ones.
	                    if (count_delete === 0) {
	                        diffs.splice(pointer - count_insert, count_delete + count_insert, [DIFF_INSERT$1$2, text_insert]);
	                    }
	                    else if (count_insert === 0) {
	                        diffs.splice(pointer - count_delete, count_delete + count_insert, [DIFF_DELETE$1$2, text_delete]);
	                    }
	                    else {
	                        diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [DIFF_DELETE$1$2, text_delete], [DIFF_INSERT$1$2, text_insert]);
	                    }
	                    pointer = pointer - count_delete - count_insert +
	                        (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
	                }
	                else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL$1$2) {
	                    // Merge this equality with the previous one.
	                    diffs[pointer - 1][1] += diffs[pointer][1];
	                    diffs.splice(pointer, 1);
	                }
	                else {
	                    pointer++;
	                }
	                count_insert = 0;
	                count_delete = 0;
	                text_delete = '';
	                text_insert = '';
	                break;
	        }
	    }
	    if (diffs[diffs.length - 1][1] === '') {
	        diffs.pop(); // Remove the dummy entry at the end.
	    }
	    // Second pass: look for single edits surrounded on both sides by equalities
	    // which can be shifted sideways to eliminate an equality.
	    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
	    var changes = false;
	    pointer = 1;
	    // Intentionally ignore the first and last element (don't need checking).
	    while (pointer < diffs.length - 1) {
	        if (diffs[pointer - 1][0] == DIFF_EQUAL$1$2 &&
	            diffs[pointer + 1][0] == DIFF_EQUAL$1$2) {
	            // This is a single edit surrounded by equalities.
	            if (diffs[pointer][1].substring(diffs[pointer][1].length -
	                diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
	                // Shift the edit over the previous equality.
	                diffs[pointer][1] = diffs[pointer - 1][1] +
	                    diffs[pointer][1].substring(0, diffs[pointer][1].length -
	                        diffs[pointer - 1][1].length);
	                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
	                diffs.splice(pointer - 1, 1);
	                changes = true;
	            }
	            else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
	                diffs[pointer + 1][1]) {
	                // Shift the edit over the next equality.
	                diffs[pointer - 1][1] += diffs[pointer + 1][1];
	                diffs[pointer][1] =
	                    diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
	                        diffs[pointer + 1][1];
	                diffs.splice(pointer + 1, 1);
	                changes = true;
	            }
	        }
	        pointer++;
	    }
	    // If shifts were made, the diff needs reordering and another shift sweep.
	    if (changes) {
	        diff_cleanupMerge$1$2(diffs);
	    }
	}
	diff$1$2.INSERT = DIFF_INSERT$1$2;
	diff$1$2.DELETE = DIFF_DELETE$1$2;
	diff$1$2.EQUAL = DIFF_EQUAL$1$2;
	/*
	 * Modify a diff such that the cursor position points to the start of a change:
	 * E.g.
	 *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)
	 *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]
	 *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)
	 *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
	 * @return {Array} A tuple [cursor location in the modified diff, modified diff]
	 */
	function cursor_normalize_diff$1$2(diffs, cursor_pos) {
	    if (cursor_pos === 0) {
	        return [DIFF_EQUAL$1$2, diffs];
	    }
	    for (var current_pos = 0, i = 0; i < diffs.length; i++) {
	        var d = diffs[i];
	        if (d[0] === DIFF_DELETE$1$2 || d[0] === DIFF_EQUAL$1$2) {
	            var next_pos = current_pos + d[1].length;
	            if (cursor_pos === next_pos) {
	                return [i + 1, diffs];
	            }
	            else if (cursor_pos < next_pos) {
	                // copy to prevent side effects
	                diffs = diffs.slice();
	                // split d into two diff changes
	                var split_pos = cursor_pos - current_pos;
	                var d_left = [d[0], d[1].slice(0, split_pos)];
	                var d_right = [d[0], d[1].slice(split_pos)];
	                diffs.splice(i, 1, d_left, d_right);
	                return [i + 1, diffs];
	            }
	            else {
	                current_pos = next_pos;
	            }
	        }
	    }
	    throw new Error('cursor_pos is out of bounds!');
	}
	/*
	 * Modify a diff such that the edit position is "shifted" to the proposed edit location (cursor_position).
	 *
	 * Case 1)
	 *   Check if a naive shift is possible:
	 *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)
	 *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result
	 * Case 2)
	 *   Check if the following shifts are possible:
	 *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']
	 *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']
	 *         ^            ^
	 *         d          d_next
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
	 * @return {Array} Array of diff tuples
	 */
	function fix_cursor$1$2(diffs, cursor_pos) {
	    var norm = cursor_normalize_diff$1$2(diffs, cursor_pos);
	    var ndiffs = norm[1];
	    var cursor_pointer = norm[0];
	    var d = ndiffs[cursor_pointer];
	    var d_next = ndiffs[cursor_pointer + 1];
	    if (d == null) {
	        // Text was deleted from end of original string,
	        // cursor is now out of bounds in new string
	        return diffs;
	    }
	    else if (d[0] !== DIFF_EQUAL$1$2) {
	        // A modification happened at the cursor location.
	        // This is the expected outcome, so we can return the original diff.
	        return diffs;
	    }
	    else {
	        if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
	            // Case 1)
	            // It is possible to perform a naive shift
	            ndiffs.splice(cursor_pointer, 2, d_next, d);
	            return merge_tuples$1$2(ndiffs, cursor_pointer, 2);
	        }
	        else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
	            // Case 2)
	            // d[1] is a prefix of d_next[1]
	            // We can assume that d_next[0] !== 0, since d[0] === 0
	            // Shift edit locations..
	            ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
	            var suffix = d_next[1].slice(d[1].length);
	            if (suffix.length > 0) {
	                ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
	            }
	            return merge_tuples$1$2(ndiffs, cursor_pointer, 3);
	        }
	        else {
	            // Not possible to perform any modification
	            return diffs;
	        }
	    }
	}
	/*
	 * Check diff did not split surrogate pairs.
	 * Ex. [0, '\uD83D'], [-1, '\uDC36'], [1, '\uDC2F'] -> [-1, '\uD83D\uDC36'], [1, '\uD83D\uDC2F']
	 *     '\uD83D\uDC36' === '🐶', '\uD83D\uDC2F' === '🐯'
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @return {Array} Array of diff tuples
	 */
	function fix_emoji$1$2(diffs) {
	    var compact = false;
	    var starts_with_pair_end = function (str) {
	        return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;
	    };
	    var ends_with_pair_start = function (str) {
	        return str.charCodeAt(str.length - 1) >= 0xD800 && str.charCodeAt(str.length - 1) <= 0xDBFF;
	    };
	    for (var i = 2; i < diffs.length; i += 1) {
	        if (diffs[i - 2][0] === DIFF_EQUAL$1$2 && ends_with_pair_start(diffs[i - 2][1]) &&
	            diffs[i - 1][0] === DIFF_DELETE$1$2 && starts_with_pair_end(diffs[i - 1][1]) &&
	            diffs[i][0] === DIFF_INSERT$1$2 && starts_with_pair_end(diffs[i][1])) {
	            compact = true;
	            diffs[i - 1][1] = diffs[i - 2][1].slice(-1) + diffs[i - 1][1];
	            diffs[i][1] = diffs[i - 2][1].slice(-1) + diffs[i][1];
	            diffs[i - 2][1] = diffs[i - 2][1].slice(0, -1);
	        }
	    }
	    if (!compact) {
	        return diffs;
	    }
	    var fixed_diffs = [];
	    for (var i = 0; i < diffs.length; i += 1) {
	        if (diffs[i][1].length > 0) {
	            fixed_diffs.push(diffs[i]);
	        }
	    }
	    return fixed_diffs;
	}
	/*
	 * Try to merge tuples with their neigbors in a given range.
	 * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']
	 *
	 * @param {Array} diffs Array of diff tuples.
	 * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).
	 * @param {Int} length Number of consecutive elements to check.
	 * @return {Array} Array of merged diff tuples.
	 */
	function merge_tuples$1$2(diffs, start, length) {
	    // Check from (start-1) to (start+length).
	    for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {
	        if (i + 1 < diffs.length) {
	            var left_d = diffs[i];
	            var right_d = diffs[i + 1];
	            if (left_d[0] === right_d[1]) {
	                diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
	            }
	        }
	    }
	    return diffs;
	}

	function shallowEqual$1$2(valueA, valueB) {
	    return valueEqual$1$2(valueA, valueB, strictEqual$1$2);
	}
	function deepEqual$1$2(valueA, valueB) {
	    return valueEqual$1$2(valueA, valueB, valueEqual$1$2);
	}
	function strictEqual$1$2(valueA, valueB) {
	    return valueA === valueB;
	}
	function valueEqual$1$2(valueA, valueB, propEqual) {
	    if (valueA === valueB)
	        return true;
	    if (valueA instanceof Date && valueB instanceof Date)
	        return valueA.getTime() === valueB.getTime();
	    if (!valueA || !valueB || typeof valueA !== 'object' && typeof valueB !== 'object')
	        return valueA === valueB;
	    return objectEqual$1$2(valueA, valueB, propEqual);
	}
	function objectEqual$1$2(objA, objB, propEqual) {
	    if (objA.prototype !== objB.prototype)
	        return false;
	    var keysA = Object.keys(objA);
	    var keysB = Object.keys(objB);
	    if (keysA.length !== keysB.length)
	        return false;
	    return keysA.every(function (key, i) { return key === keysB[i] && propEqual(objA[key], objB[key], propEqual); });
	}

	var NULL_CHARACTER$1$2 = String.fromCharCode(0); // Placeholder char for embed in diff()
	var Delta$1$2 = /** @class */ (function () {
	    function Delta(ops) {
	        if (ops === void 0) { ops = []; }
	        this.ops = ops;
	    }
	    /**
	     * Appends an insert operation. Returns this for chainability.
	     *
	     * @param {String|Object} text Represents text or embed to insert
	     * @param {Object} attributes Optional attributes to apply
	     */
	    Delta.prototype.insert = function (text, attributes) {
	        var newOp = {};
	        if (text.length === 0)
	            return this;
	        newOp.insert = text;
	        if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
	            newOp.attributes = attributes;
	        }
	        return this._push(newOp);
	    };
	    /**
	     * Appends a delete operation. Returns this for chainability.
	     *
	     * @param {Number} length Number of characters to delete
	     */
	    Delta.prototype["delete"] = function (length) {
	        if (length <= 0)
	            return this;
	        return this._push({ "delete": length });
	    };
	    /**
	     * Appends a retain operation. Returns this for chainability.
	     *
	     * @param {Number} length Number of characters to retain
	     * @param {Object} attributes Optional attributes to apply
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.retain = function (length, attributes) {
	        if (length <= 0)
	            return this;
	        var newOp = { retain: length };
	        if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
	            newOp.attributes = attributes;
	        }
	        return this._push(newOp);
	    };
	    /**
	     * Freezes delta from future modifications. Returns this for chainability.
	     *
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.freeze = function () {
	        var _this = this;
	        this._push = function () { return _this; };
	        return this;
	    };
	    /**
	     * Adds a new operation. Returns this for chainability.
	     *
	     * @param {Object} newOp A new operation
	     * @returns {Delta} This delta
	     */
	    Delta.prototype._push = function (newOp) {
	        var index = this.ops.length;
	        var lastOp = this.ops[index - 1];
	        if (typeof lastOp === 'object') {
	            if (typeof newOp["delete"] === 'number' && typeof lastOp["delete"] === 'number') {
	                this.ops[index - 1] = { "delete": lastOp["delete"] + newOp["delete"] };
	                return this;
	            }
	            // Since it does not matter if we insert before or after deleting at the same index,
	            // always prefer to insert first
	            if (typeof lastOp["delete"] === 'number' && newOp.insert != null) {
	                index -= 1;
	                lastOp = this.ops[index - 1];
	                if (typeof lastOp !== 'object') {
	                    this.ops.unshift(newOp);
	                    return this;
	                }
	            }
	            if (deepEqual$1$2(newOp.attributes, lastOp.attributes)) {
	                if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {
	                    this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };
	                    if (typeof newOp.attributes === 'object')
	                        this.ops[index - 1].attributes = newOp.attributes;
	                    return this;
	                }
	                else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {
	                    this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };
	                    if (typeof newOp.attributes === 'object')
	                        this.ops[index - 1].attributes = newOp.attributes;
	                    return this;
	                }
	            }
	        }
	        if (index === this.ops.length) {
	            this.ops.push(newOp);
	        }
	        else {
	            this.ops.splice(index, 0, newOp);
	        }
	        return this;
	    };
	    /**
	     * Chops off trailing retain instructions to make the delta concise.
	     *
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.chop = function () {
	        var lastOp = this.ops[this.ops.length - 1];
	        if (lastOp && lastOp.retain && !lastOp.attributes) {
	            this.ops.pop();
	        }
	        return this;
	    };
	    /**
	     * Returns an iterator to iterate over the operations of this delta.
	     *
	     * @returns {Iterator} An operation iterator with methods hasNext, next, peek, peekLength, & peekType
	     */
	    Delta.prototype.iterator = function () {
	        return new Iterator$1$2(this.ops);
	    };
	    /**
	     * Returns an array of operations that passes a given function.
	     *
	     * @param {Function} predicate Function to test each operation against. Return true to keep the operation, false
	     *                             otherwise
	     * @returns {Array} Filtered resulting array
	     */
	    Delta.prototype.filter = function (predicate) {
	        return this.ops.filter(predicate);
	    };
	    /**
	     * Iterates through operations, calling the provided function for each operation.
	     *
	     * @param {Function} predicate Function to call during iteration, passing in the current operation
	     */
	    Delta.prototype.forEach = function (predicate) {
	        this.ops.forEach(predicate);
	    };
	    /**
	     * Returns a new array with the results of calling provided function on each operation.
	     *
	     * @param {Function} predicate Function to call, passing in the current operation, returning an element of the new
	     *                             array to be returned
	     * @returns {Array} A new array with each element being the result of the given function
	     */
	    Delta.prototype.map = function (predicate) {
	        return this.ops.map(predicate);
	    };
	    /**
	     * Create an array of two arrays, the first with operations that pass the given function, the other that failed.
	     *
	     * @param {Function} predicate Function to call, passing in the current operation, returning whether that operation
	     *                             passed
	     * @returns {Array} A new array of two Arrays, the first with passed operations, the other with failed operations
	     */
	    Delta.prototype.partition = function (predicate) {
	        var passed = [], failed = [];
	        this.forEach(function (op) {
	            var target = predicate(op) ? passed : failed;
	            target.push(op);
	        });
	        return [passed, failed];
	    };
	    /**
	     * Applies given function against an accumulator and each operation to reduce to a single value.
	     *
	     * @param {Function} predicate Function to call per iteration, returning an accumulated value
	     * @param {*} initial Initial value to pass to first call to predicate
	     * @returns {*} The accumulated value
	     */
	    Delta.prototype.reduce = function (predicate, initial) {
	        return this.ops.reduce(predicate, initial);
	    };
	    Delta.prototype.changeLength = function () {
	        return this.reduce(function (length, entry) {
	            if (entry.insert) {
	                return length + getOpLength$1$2(entry);
	            }
	            else if (entry["delete"]) {
	                return length - entry["delete"];
	            }
	            return length;
	        }, 0);
	    };
	    /**
	     * Returns length of a Delta, which is the sum of the lengths of its operations.
	     *
	     * @returns {Number} The length of this delta
	     */
	    Delta.prototype.length = function () {
	        return this.reduce(function (length, entry) {
	            return length + getOpLength$1$2(entry);
	        }, 0);
	    };
	    /**
	     * Returns copy of delta with subset of operations.
	     *
	     * @param {Number} start Start index of subset, defaults to 0
	     * @param {Number} end End index of subset, defaults to rest of operations
	     * @returns {Array} An array slice of the operations
	     */
	    Delta.prototype.slice = function (start, end) {
	        if (start === void 0) { start = 0; }
	        if (typeof end !== 'number')
	            end = Infinity;
	        var ops = [];
	        var iter = this.iterator();
	        var index = 0;
	        while (index < end && iter.hasNext()) {
	            var nextOp;
	            if (index < start) {
	                nextOp = iter.next(start - index);
	            }
	            else {
	                nextOp = iter.next(end - index);
	                ops.push(nextOp);
	            }
	            index += getOpLength$1$2(nextOp);
	        }
	        return new Delta(ops);
	    };
	    /**
	     * Returns a Delta that is equivalent to applying the operations of own Delta, followed by another Delta.
	     *
	     * @param {Delta} other Delta to compose
	     */
	    Delta.prototype.compose = function (other) {
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        var delta = new Delta();
	        while (thisIter.hasNext() || otherIter.hasNext()) {
	            if (otherIter.peekType() === 'insert') {
	                delta._push(otherIter.next());
	            }
	            else if (thisIter.peekType() === 'delete') {
	                delta._push(thisIter.next());
	            }
	            else {
	                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
	                var thisOp = thisIter.next(length);
	                var otherOp = otherIter.next(length);
	                if (typeof otherOp.retain === 'number') {
	                    var newOp = {};
	                    if (typeof thisOp.retain === 'number') {
	                        newOp.retain = length;
	                    }
	                    else {
	                        newOp.insert = thisOp.insert;
	                    }
	                    // Preserve null when composing with a retain, otherwise remove it for inserts
	                    var attributes = composeAttributes$1$2(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');
	                    if (attributes)
	                        newOp.attributes = attributes;
	                    delta._push(newOp);
	                    // Optimization if rest of other is just retain
	                    if (!otherIter.hasNext() && deepEqual$1$2(delta.ops[delta.ops.length - 1], newOp)) {
	                        var rest = new Delta(thisIter.rest());
	                        return delta.concat(rest).chop();
	                    }
	                    // Other op should be delete, we could be an insert or retain
	                    // Insert + delete cancels out
	                }
	                else if (typeof otherOp["delete"] === 'number' && typeof thisOp.retain === 'number') {
	                    delta._push(otherOp);
	                }
	            }
	        }
	        return delta.chop();
	    };
	    /**
	     * Returns a new Delta representing the concatenation of this and another document Delta's operations.
	     *
	     * @param {Delta} other Document Delta to concatenate
	     * @returns {Delta} Concatenated document Delta
	     */
	    Delta.prototype.concat = function (other) {
	        var delta = new Delta(this.ops.slice());
	        if (other.ops.length > 0) {
	            delta._push(other.ops[0]);
	            delta.ops = delta.ops.concat(other.ops.slice(1));
	        }
	        return delta;
	    };
	    /**
	     * Returns a Delta representing the difference between two documents. Optionally, accepts a suggested index where
	     * change took place, often representing a cursor position before change.
	     *
	     * @param {Delta} other Document Delta to diff against
	     * @param {Number} index Suggested index where change took place
	     * @returns {Delta} Difference between the two documents
	     */
	    Delta.prototype.diff = function (other, index) {
	        if (this.ops === other.ops) {
	            return new Delta();
	        }
	        var strings = [this, other].map(function (delta) {
	            return delta.map(function (op) {
	                if (op.insert != null) {
	                    return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER$1$2;
	                }
	                var prep = (delta === other) ? 'on' : 'with';
	                throw new Error('diff() called ' + prep + ' non-document');
	            }).join('');
	        });
	        var delta = new Delta();
	        var diffResult = diff$1$2(strings[0], strings[1], index);
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        diffResult.forEach(function (component) {
	            var length = component[1].length;
	            while (length > 0) {
	                var opLength = 0;
	                switch (component[0]) {
	                    case diff$1$2.INSERT:
	                        opLength = Math.min(otherIter.peekLength(), length);
	                        delta._push(otherIter.next(opLength));
	                        break;
	                    case diff$1$2.DELETE:
	                        opLength = Math.min(length, thisIter.peekLength());
	                        thisIter.next(opLength);
	                        delta["delete"](opLength);
	                        break;
	                    case diff$1$2.EQUAL:
	                        opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
	                        var thisOp = thisIter.next(opLength);
	                        var otherOp = otherIter.next(opLength);
	                        if (deepEqual$1$2(thisOp.insert, otherOp.insert)) {
	                            delta.retain(opLength, diffAttributes$1$2(thisOp.attributes, otherOp.attributes));
	                        }
	                        else {
	                            delta._push(otherOp)["delete"](opLength);
	                        }
	                        break;
	                }
	                length -= opLength;
	            }
	        });
	        return delta.chop();
	    };
	    /**
	     * Iterates through document Delta, calling a given function with a Delta and attributes object, representing the line
	     * segment.
	     *
	     * @param {Function} predicate Function to call on each line group
	     * @param {String} newline Newline character, defaults to \n
	     */
	    Delta.prototype.eachLine = function (predicate, newline) {
	        if (newline === void 0) { newline = '\n'; }
	        var iter = this.iterator();
	        var ops = new Delta();
	        var index = 0;
	        var lineStart = 0;
	        var currentIndex = 0;
	        while (iter.hasNext()) {
	            if (iter.peekType() !== 'insert')
	                return;
	            var op = iter.peek();
	            var nextLength = iter.peekLength();
	            var start = getOpLength$1$2(op) - nextLength;
	            var newlineIndex = typeof op.insert === 'string' ? op.insert.indexOf(newline, start) - start : -1;
	            if (newlineIndex < 0) {
	                currentIndex += nextLength;
	                ops._push(iter.next());
	            }
	            else if (newlineIndex > 0) {
	                currentIndex += newlineIndex;
	                ops._push(iter.next(newlineIndex));
	            }
	            else {
	                currentIndex += 1;
	                var attributes = iter.next(1).attributes || {};
	                var line = { ops: ops, attributes: attributes, start: lineStart, end: currentIndex, index: index };
	                if (predicate(line, index) === false) {
	                    return;
	                }
	                index += 1;
	                lineStart = currentIndex;
	                ops = new Delta();
	            }
	        }
	        if (ops.length() > 0) {
	            var line_1 = { ops: ops, attributes: {}, start: lineStart, end: currentIndex, index: index };
	            predicate(line_1, index);
	        }
	    };
	    // Extends Delta, get the lines from `from` to `to`.
	    Delta.prototype.getLines = function (from, to, newline) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = Infinity; }
	        var lines = [];
	        this.eachLine(function (line) {
	            if (line.start > to || (line.start === to && from !== to))
	                return false;
	            if (line.end > from) {
	                lines.push(line);
	            }
	        }, newline);
	        return lines;
	    };
	    // Extends Delta, get the line at `at`.
	    Delta.prototype.getLine = function (at, newline) {
	        return this.getLines(at, at, newline)[0];
	    };
	    // Extends Delta, get the ops from `from` to `to`.
	    Delta.prototype.getOps = function (from, to) {
	        var start = 0;
	        var ops = [];
	        this.ops.some(function (op) {
	            if (start >= to)
	                return true;
	            var end = start + getOpLength$1$2(op);
	            if (end > from || (from === to && end === to)) {
	                ops.push({ op: op, start: start, end: end });
	            }
	            start = end;
	        });
	        return ops;
	    };
	    // Extends Delta, get the op at `at`.
	    Delta.prototype.getOp = function (at) {
	        return this.getOps(at, at)[0];
	    };
	    /**
	     * Transform given Delta against own operations. Used as an alias for transformPosition when called with a number.
	     *
	     * @param {Delta} other Delta to transform
	     * @param {Boolean} priority Boolean used to break ties. If true, then this takes priority over other, that is, its
	     *                           actions are considered to happen "first."
	     * @returns {Delta} Transformed Delta
	     */
	    Delta.prototype.transform = function (other, priority) {
	        if (priority === void 0) { priority = false; }
	        if (typeof other === 'number') {
	            return this.transformPosition(other, priority);
	        }
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        var delta = new Delta();
	        while (thisIter.hasNext() || otherIter.hasNext()) {
	            if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {
	                delta.retain(getOpLength$1$2(thisIter.next()));
	            }
	            else if (otherIter.peekType() === 'insert') {
	                delta._push(otherIter.next());
	            }
	            else {
	                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
	                var thisOp = thisIter.next(length);
	                var otherOp = otherIter.next(length);
	                if (thisOp["delete"]) {
	                    // Our delete either makes their delete redundant or removes their retain
	                    continue;
	                }
	                else if (otherOp["delete"]) {
	                    delta._push(otherOp);
	                }
	                else {
	                    // We retain either their retain or insert
	                    delta.retain(length, transformAttributes$1$2(thisOp.attributes, otherOp.attributes, priority));
	                }
	            }
	        }
	        return delta.chop();
	    };
	    /**
	     * Transform an index against the delta. Useful for representing cursor/selection positions.
	     *
	     * @param {Number} index Index to transform
	     * @param {Boolean} priority Boolean used to break ties. If true, then this takes priority over other, that is, its
	     *                           actions are considered to happen "first."
	     * @returns {Number} Transformed index
	     */
	    Delta.prototype.transformPosition = function (index, priority) {
	        if (priority === void 0) { priority = false; }
	        var thisIter = this.iterator();
	        var offset = 0;
	        while (thisIter.hasNext() && offset <= index) {
	            var length = thisIter.peekLength();
	            var nextType = thisIter.peekType();
	            thisIter.next();
	            if (nextType === 'delete') {
	                index -= Math.min(length, index - offset);
	                continue;
	            }
	            else if (nextType === 'insert' && (offset < index || !priority)) {
	                index += length;
	            }
	            offset += length;
	        }
	        return index;
	    };
	    return Delta;
	}());
	/**
	 * Create an attributes object that is equivalent to applying the attributes of the target followed by the source.
	 *
	 * @param {Object} target Target attributes object which will have the source applied to
	 * @param {Object} source Source attributes object being applied to the target
	 * @param {Boolean} keepNull Whether to keep null values from source
	 * @returns {Object} A new attributes object (or undefined if empty) with both
	 */
	function composeAttributes$1$2(target, source, keepNull) {
	    if (target === void 0) { target = {}; }
	    if (source === void 0) { source = {}; }
	    var attributes = __assign$1$2({}, target, source);
	    if (!keepNull)
	        Object.keys(attributes).forEach(function (key) {
	            if (attributes[key] == null)
	                delete attributes[key];
	        });
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Finds the difference between two attributes objects. Returns the source attributes that are different from the
	 * target attributes.
	 *
	 * @param {Object} target An attributes object
	 * @param {Object} source An attributes object
	 * @returns {Object} The difference between the two attribute objects or undefined if there is none
	 */
	function diffAttributes$1$2(target, source) {
	    if (target === void 0) { target = {}; }
	    if (source === void 0) { source = {}; }
	    var attributes = Object.keys(target).concat(Object.keys(source)).reduce(function (attributes, key) {
	        if (!deepEqual$1$2(target[key], source[key])) {
	            attributes[key] = source[key] === undefined ? null : source[key];
	        }
	        return attributes;
	    }, {});
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Transforms the attributes of source over target (or the other way around if priority is set). Will return an
	 * attributes object which has all the values from source if priority if false or will have the values from source that
	 * are set on target.
	 *
	 * @param {Object} target An attributes object
	 * @param {Object} source An attributes object
	 * @param {Boolean} priority If target has priority over source
	 */
	function transformAttributes$1$2(target, source, priority) {
	    if (typeof target !== 'object')
	        return source;
	    if (typeof source !== 'object')
	        return undefined;
	    if (!priority)
	        return source; // b simply overwrites us without priority
	    var attributes = Object.keys(source).reduce(function (attributes, key) {
	        if (target[key] === undefined)
	            attributes[key] = source[key]; // null is a valid value
	        return attributes;
	    }, {});
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Determines the length of a Delta operation.
	 *
	 * @param {Object} op An operation entry from a Delta object
	 * @returns {Number} The length of the op
	 */
	function getOpLength$1$2(op) {
	    if (typeof op["delete"] === 'number') {
	        return op["delete"];
	    }
	    else if (typeof op.retain === 'number') {
	        return op.retain;
	    }
	    else {
	        return typeof op.insert === 'string' ? op.insert.length : 1;
	    }
	}
	/**
	 * An iterator to handle iterating over a list of Delta operations efficiently.
	 */
	var Iterator$1$2 = /** @class */ (function () {
	    function Iterator(ops) {
	        this.ops = ops;
	        this.index = 0;
	        this.offset = 0;
	    }
	    /**
	     * Determine if there will be another operation returned by `next`.
	     *
	     * @returns {Boolean} Whether there are more operations to iterate over
	     */
	    Iterator.prototype.hasNext = function () {
	        return this.peekLength() < Infinity;
	    };
	    /**
	     * Get the next operation, optionally limited/sliced by length. If an operation is sliced by length, the next call to
	     * `next` will return more of that operation until it is returned in full.
	     *
	     * @param {Number} length Optionally limit the returned operation by length, slicing it down as needed
	     */
	    Iterator.prototype.next = function (length) {
	        if (length === void 0) { length = Infinity; }
	        var nextOp = this.ops[this.index];
	        if (!nextOp)
	            return { retain: Infinity };
	        var offset = this.offset;
	        var opLength = getOpLength$1$2(nextOp);
	        // Update index and offset
	        if (length >= opLength - offset) {
	            length = opLength - offset;
	            this.index += 1;
	            this.offset = 0;
	        }
	        else {
	            this.offset += length;
	        }
	        if (typeof nextOp["delete"] === 'number') {
	            return { "delete": length };
	        }
	        else {
	            var retOp = {};
	            if (nextOp.attributes) {
	                retOp.attributes = nextOp.attributes;
	            }
	            if (typeof nextOp.retain === 'number') {
	                retOp.retain = length;
	            }
	            else if (typeof nextOp.insert === 'string') {
	                retOp.insert = nextOp.insert.substr(offset, length);
	            }
	            else {
	                // offset should === 0, length should === 1
	                retOp.insert = nextOp.insert;
	            }
	            return retOp;
	        }
	    };
	    /**
	     * Return the next entry.
	     *
	     * @returns {Object} The next entry in the ops array.
	     */
	    Iterator.prototype.peek = function () {
	        return this.ops[this.index];
	    };
	    /**
	     * Check the length of the next entry.
	     *
	     * @returns {Number} The length of the next entry or Infinity if there is no next entry
	     */
	    Iterator.prototype.peekLength = function () {
	        if (this.ops[this.index]) {
	            // Should never return 0 if our index is being managed correctly
	            return getOpLength$1$2(this.ops[this.index]) - this.offset;
	        }
	        else {
	            return Infinity;
	        }
	    };
	    /**
	     * Check the type of the next entry, delete, retain, or insert.
	     *
	     * @returns {String} The type of the next entry
	     */
	    Iterator.prototype.peekType = function () {
	        if (this.ops[this.index]) {
	            if (typeof this.ops[this.index]["delete"] === 'number') {
	                return 'delete';
	            }
	            else if (typeof this.ops[this.index].retain === 'number') {
	                return 'retain';
	            }
	            else {
	                return 'insert';
	            }
	        }
	        return 'retain';
	    };
	    Iterator.prototype.rest = function () {
	        if (!this.hasNext()) {
	            return [];
	        }
	        else if (this.offset === 0) {
	            return this.ops.slice(this.index);
	        }
	        else {
	            var offset = this.offset;
	            var index = this.index;
	            var next = this.next();
	            var rest = this.ops.slice(this.index);
	            this.offset = offset;
	            this.index = index;
	            return [next].concat(rest);
	        }
	    };
	    return Iterator;
	}());

	var SOURCE_API$1$2 = 'api';
	var SOURCE_USER$1$3 = 'user';
	var SOURCE_SILENT$1$2 = 'silent';
	var empty$1$2 = {};
	/**
	 * Event for text changes, called before the change has occurred. If a listener returns false the change will be
	 * canceled and not committed.
	 *
	 * @event Editor#text-changing
	 * @type  {Object}
	 * @property {Delta} change       The change which is being applied to the content
	 * @property {Delta} content      The new content after the change
	 * @property {Delta} oldContent   The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * Event for text changes, called after the change has occurred.
	 *
	 * @event Editor#text-change
	 * @type  {Object}
	 * @property {Delta} change       The change which is being applied to the content
	 * @property {Delta} content      The new content after the change
	 * @property {Delta} oldContent   The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * Event for selection changes. If part of a text change the `change`, `content`, and `oldContent` properties will be
	 * set. Otherwise they will not be set.
	 *
	 * @event Editor#selection-change
	 * @type  {Object}
	 * @property {Delta} change       [ Optional ] The change which is being applied to the content
	 * @property {Delta} content      [ Optional ] The new content after the change
	 * @property {Delta} oldContent   [ Optional ] The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * A Typewriter Editor handles the logic for selection and editing of contents. It has no dependency on browser APIs
	 * and can be used in Node.js as easily as the browser. It has no logic to limit formatting (i.e. it does not disallow
	 * using bold, headers, links, or FOOBAR), that will need to be limited outside of the editor itself.
	 *
	 * @fires Editor#text-changing
	 * @fires Editor#text-change
	 * @fires Editor#selection-change
	 *
	 * @readonly @property {Delta}  contents      The data model for the text editor
	 * @readonly @property {Number} length        The length of the contents
	 * @readonly @property {String} text          The text of the contents
	 * @readonly @property {Array}  selection     The current editor selection, a tuple of `[ from, to ]` or `null`
	 * @readonly @property {Object} activeFormats The currently active formats (formats that will apply on the next insert)
	 */
	var Editor$1$2 = /** @class */ (function (_super) {
	    __extends$1$2(Editor, _super);
	    /**
	     * Create a new Typewriter editor.
	     *
	     * @param {Object} options Options for this editor include initial `contents` and `modules`:
	     * @param {Delta}  options.contents The initial contents of this editor
	     */
	    function Editor(options) {
	        if (options === void 0) { options = {}; }
	        var _this = _super.call(this) || this;
	        _this.contents = null;
	        _this.length = 0;
	        _this.selection = null;
	        _this.activeFormats = empty$1$2;
	        setContents$1$2(_this, options.contents || _this.delta().insert('\n'));
	        _this._queuedEvents = []; // Event queuing ensure they are fired in order
	        return _this;
	    }
	    /**
	     * Convenience method for creating a new delta.
	     *
	     * @param {Array} ops [Optional] The initial ops for the delta
	     * @returns {Delta}   A new Delta object
	     */
	    Editor.prototype.delta = function (ops) {
	        return new Delta$1$2(ops);
	    };
	    /**
	     * Returns the contents or a slice of them.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {Delta}     The contents of this editor
	     */
	    Editor.prototype.getContents = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.contents.slice(from, to);
	    };
	    /**
	     * Returns the text for the editor or a slice of it.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {String}    The text in the editor
	     */
	    Editor.prototype.getText = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length - 1; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.getContents(from, to)
	            .filter(function (op) { return typeof op.insert === 'string'; })
	            .map(function (op) { return op.insert; })
	            .join('');
	    };
	    /**
	     * Returns the text for the editor with null characters in place of embeds. This can be used to determine the index of
	     * given words or lines of text within the contents.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {String}    The text in the editor with embed spaces
	     */
	    Editor.prototype.getExactText = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length - 1; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.getContents(from, to)
	            .map(function (op) { return typeof op.insert === 'string' ? op.insert : '\0'; })
	            .join('');
	    };
	    /**
	     * Set the selection to a new location (or null for no selection). Will return false if the new selection is the same
	     * as the old selection. Dispatches "selection-change" once the selection is changed. This "selection-change" event
	     * won't have { contents, oldContnts, change } in it since the selection is changing without any content updates.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Boolean}        Whether the selection changed or not
	     */
	    Editor.prototype.setSelection = function (from, to, source) {
	        var _this = this;
	        if (source === void 0) { source = SOURCE_USER$1$3; }
	        var _a;
	        var oldSelection = this.selection;
	        var selection;
	        if (from === null) {
	            selection = null;
	            if (typeof to === 'string')
	                source = to;
	        }
	        else {
	            _a = this._normalizeSelection(from, to, source), from = _a[0], to = _a[1], source = _a[2];
	            selection = [from, to].map(function (i) { return Math.min(i, _this.length - 1); });
	        }
	        if (shallowEqual$1$2(oldSelection, selection))
	            return false;
	        // Reset the active formats when selection changes (do this before setting selection)
	        this.activeFormats = selection ? this.getTextFormat(Math.min(selection[0], selection[1])) : empty$1$2;
	        this.selection = selection;
	        var event = { selection: selection, oldSelection: oldSelection, source: source };
	        if (source !== SOURCE_SILENT$1$2)
	            this.fire('selection-change', event);
	        this.fire('editor-change', event);
	        return true;
	    };
	    /**
	     * The method that all other methods use to update the contents (even setContents & setText). This method will
	     * dispatch the event "text-changing". If a listener returns `false` then the change will be canceled and null will
	     * be returned. Otherwise, the change will be successful and if the `source` is not "silent" a "text-change" event
	     * will be fired with an event object containing `{ contents, oldContents, selection, oldSelection, source }`. If the
	     * selection has changed as part of this update a "selection-change" event will also be fired with the same event
	     * object.
	     *
	     * @param {Delta} change    A delta change to the document
	     * @param {String} source   The source of the change, user, api, or silent
	     * @param {Array} selection Optional selection after the change has been applied
	     * @returns {Delta}         Returns the change when successful, or null if not
	     */
	    Editor.prototype.updateContents = function (change, source, selection) {
	        if (source === void 0) { source = SOURCE_API$1$2; }
	        if (!change.chop().ops.length)
	            return null;
	        if (typeof selection === 'number')
	            selection = [selection, selection];
	        var oldContents = this.contents;
	        var contents = normalizeContents$1$2(oldContents.compose(change));
	        var length = contents.length();
	        var oldSelection = this.selection;
	        if (!selection)
	            selection = oldSelection ? oldSelection.map(function (i) { return change.transform(i); }) : oldSelection;
	        selection = selection && this.getSelectedRange(selection, length - 1);
	        var changeEvent = { contents: contents, oldContents: oldContents, change: change, selection: selection, oldSelection: oldSelection, source: source };
	        var selectionChanged = !shallowEqual$1$2(oldSelection, selection);
	        if (!this.fire('text-changing', changeEvent))
	            return null;
	        setContents$1$2(this, contents);
	        if (selection) {
	            // Reset the active formats when selection changes (do this before setting selection)
	            this.activeFormats = selection ? this.getTextFormat(Math.min(selection[0], selection[1])) : empty$1$2;
	            this.selection = selection;
	        }
	        var events = [];
	        if (source !== SOURCE_SILENT$1$2) {
	            events.push(['text-change', changeEvent]);
	            if (selectionChanged)
	                events.push(['selection-change', changeEvent]);
	        }
	        events.push(['editor-change', changeEvent]);
	        this._queueEvents(events);
	        return change;
	    };
	    /**
	     * Sets the entire contents of the editor. This will calculate the difference between the old content and the new and
	     * only apply the difference, if any.
	     *
	     * @param {Delta} newContents The contents of the editor, as a delta object
	     * @param {String} source     The source of the change, user, api, or silent
	     * @param {Array} selection   Optional selection after the change has been applied
	     * @returns {Delta}           Returns the change when successful, or null if not
	     */
	    Editor.prototype.setContents = function (newContents, source, selection) {
	        var change = this.contents.diff(normalizeContents$1$2(newContents));
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Sets the text content of the editor, removing existing contents and formatting.
	     *
	     * @param {String} text     Set the contents of this editor as text
	     * @param {String} source   The source of the change, user, api, or silent
	     * @param {Array} selection Optional selection after the change has been applied
	     * @returns {Delta}         Returns the change when successful, or null if not
	     */
	    Editor.prototype.setText = function (text, source, selection) {
	        return this.setContents(this.delta().insert(text + '\n'), source, selection);
	    };
	    /**
	     * Inserts text into the content of the editor, removing text between from and to if provided. If `text` is a newline
	     * ("\n") then the formats will apply to the line, otherwise they will apply to the text only (even if there are
	     * newlines in the text).
	     *
	     * @param {Number} from      Insert the text at this index, can also be a range Array tuple, default 0
	     * @param {Number} to        If provided and not equal to `from` will delete the text between `from` and `to`
	     * @param {String} text      The text to insert into the editor's contents
	     * @param {Object} formats   The formats of the inserted text. If null the formats at `from` will be used.
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.insertText = function (from, to, text, formats, source, selection) {
	        var _a, _b, _c;
	        _a = this._normalizeRange(from, to, text, formats, source, selection), from = _a[0], to = _a[1], text = _a[2], formats = _a[3], source = _a[4], selection = _a[5];
	        // If we are not inserting a newline, make sure from and to are within the selectable range
	        if (text !== '\n')
	            _b = this.getSelectedRange([from, to]), from = _b[0], to = _b[1];
	        if (typeof formats === 'string')
	            _c = [null, formats, source], formats = _c[0], source = _c[1], selection = _c[2];
	        if (selection == null && this.selection !== null)
	            selection = from + text.length;
	        var change = this.delta().retain(from)["delete"](to - from);
	        if (text === '\n') {
	            change.insert('\n', formats || this.getLineFormat(from));
	        }
	        else {
	            var lineFormat_1 = text.indexOf('\n') === -1 ? null : this.getLineFormat(from);
	            var textFormat_1 = formats || this.getTextFormat(from);
	            text.split('\n').forEach(function (line, i) {
	                if (i)
	                    change.insert('\n', lineFormat_1);
	                line.length && change.insert(line, textFormat_1);
	            });
	        }
	        change = cleanDelete$1$2(this, from, to, change);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Inserts an embed into the content of the editor, removing text between from and to if provided.
	     *
	     * @param {Number} from      Insert the embed at this index, can also be a range Array tuple, default 0
	     * @param {Number} to        If provided and not equal to `from` will delete the text between `from` and `to`
	     * @param {String} embed     Insert the text into the editor's contents
	     * @param {mixed}  value     Insert the text into the editor's contents
	     * @param {String} formats   The formats of the inserted text. If null the formats at `from` will be used.
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.insertEmbed = function (from, to, embed, value, formats, source, selection) {
	        var _a, _b, _c;
	        _a = this._normalizeRange(from, to, embed, value, source, selection), from = _a[0], to = _a[1], embed = _a[2], value = _a[3], source = _a[4], selection = _a[5];
	        if (typeof formats === 'string')
	            _b = [null, formats, source], formats = _b[0], source = _b[1], selection = _b[2];
	        if (from >= this.length)
	            from = this.length - 1;
	        if (to >= this.length)
	            to = this.length - 1;
	        if (selection == null && this.selection !== null)
	            selection = from + 1;
	        var textFormat = formats || this.getTextFormat(from);
	        var change = this.delta().retain(from)["delete"](to - from).insert((_c = {}, _c[embed] = value, _c), textFormat);
	        change = cleanDelete$1$2(this, from, to, change);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Deletes text from `from` to `to`.
	     *
	     * @param {Number} from      Insert the text as this index, can also be a range Array tuple, default 0
	     * @param {Number} to        Will delete the text between `from` and `to`
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.deleteText = function (from, to, source, selection) {
	        var _a;
	        _a = this._normalizeRange(from, to, source, selection), from = _a[0], to = _a[1], source = _a[2], selection = _a[3];
	        if (from === to)
	            return null;
	        if (selection == null && this.selection !== null)
	            selection = from;
	        var change = this.delta().retain(from)["delete"](to - from);
	        change = cleanDelete$1$2(this, from, to, change);
	        // Keep the active format of the text to the right of the cursor when deleting
	        var activeFormats;
	        if (selection === from)
	            activeFormats = this.getTextFormat(from, from + 1);
	        var result = this.updateContents(change, source, selection);
	        if (result && activeFormats)
	            this.activeFormats = activeFormats;
	        return result;
	    };
	    /**
	     * Get the line formats for the line that `from` is in to the line that `to` is in. Returns only the common formats
	     * between all the lines. If `from` equals `to` (or `to` is not provided) the formats will be all of those for the
	     * line `from` is on. If two lines are touched and they have different formats, an empty object will be returned.
	     *
	     * @param {Number} from Getting line formats starting at `from`
	     * @param {Number} to   Getting line formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the lines which intersect from and to
	     */
	    Editor.prototype.getLineFormat = function (from, to) {
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        var formats;
	        this.contents.getLines(from, to).forEach(function (line) {
	            if (!line.attributes)
	                formats = {};
	            else if (!formats)
	                formats = __assign$1$2({}, line.attributes);
	            else
	                formats = combineFormats$1$2(formats, line.attributes);
	        });
	        return formats;
	    };
	    /**
	     * Get the text formats for all the text from `from` to `to`. Returns only the common formats between the two indexes.
	     * Will also return the `activeFormats`. Active formats are those which are toggled on when the selection is collapsed
	     * (from and to are equal) indicating inserted text should use (or not use) those formats.
	     *
	     * @param {Number} from Getting text formats starting at `from`
	     * @param {Number} to   Getting text formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the text
	     */
	    Editor.prototype.getTextFormat = function (from, to) {
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        var formats;
	        // optimize for current selection
	        var seleciton = this.selection;
	        if (from === to && shallowEqual$1$2(this.selection, [from, to])) {
	            return this.activeFormats;
	        }
	        this.contents.getOps(from, to).forEach(function (_a) {
	            var op = _a.op;
	            if (/^\n+$/.test(op.insert))
	                return;
	            if (!op.attributes)
	                formats = {};
	            else if (!formats)
	                formats = __assign$1$2({}, op.attributes);
	            else
	                formats = combineFormats$1$2(formats, op.attributes);
	        });
	        if (!formats)
	            formats = {};
	        return formats;
	    };
	    /**
	     * Get the text and line formats for all the lines and text from `from` to `to`.
	     *
	     * @param {Number} from Getting line and text formats starting at `from`
	     * @param {Number} to   Getting line and text formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the lines and text which intersect from and to
	     */
	    Editor.prototype.getFormat = function (from, to) {
	        return __assign$1$2({}, this.getTextFormat(from, to), this.getLineFormat(from, to));
	    };
	    /**
	     * Formats the lines intersected by `from` and `to` with the given line formats. To remove an existing format pass in
	     * `null` or `false` to turn it off (e.g. `{ blockquote: false }`).
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the line
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.formatLine = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var change = this.delta();
	        this.contents.getLines(from, to).forEach(function (line) {
	            if (!change.ops.length)
	                change.retain(line.end - 1);
	            else
	                change.retain(line.end - line.start - 1);
	            // Clear out old formats on the line
	            Object.keys(line.attributes).forEach(function (name) { return !formats[name] && (formats[name] = null); });
	            change.retain(1, formats);
	        });
	        change.chop();
	        return change.ops.length ? this.updateContents(change, source) : null;
	    };
	    /**
	     * Formats the text from `from` to `to` with the given text formats. To remove an existing format pass in `null` or
	     * `false` to turn it off (e.g. `{ bold: false }`).
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the text
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.formatText = function (from, to, formats, source) {
	        var _this = this;
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        if (from === to) {
	            if (this.activeFormats === empty$1$2)
	                this.activeFormats = {};
	            Object.keys(formats).forEach(function (key) {
	                var value = formats[key];
	                if (value == null || value === false)
	                    delete _this.activeFormats[key];
	                else
	                    _this.activeFormats[key] = value;
	            });
	            return;
	        }
	        Object.keys(formats).forEach(function (name) { return formats[name] === false && (formats[name] = null); });
	        var change = this.delta().retain(from);
	        this.getText(from, to).split('\n').forEach(function (line) {
	            line.length && change.retain(line.length, formats);
	            change.retain(1);
	        });
	        change.chop();
	        return this.updateContents(change, source);
	    };
	    /**
	     * Toggles the line formats from `from` to `to` with the given line formats. If the line has the exact formats already
	     * they will be removed, otherwise they will be added.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the line
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.toggleLineFormat = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var existing = this.getLineFormat(from, to);
	        if (deepEqual$1$2(existing, formats)) {
	            Object.keys(formats).forEach(function (key) { return formats[key] = null; });
	        }
	        return this.formatLine(from, to, formats, source);
	    };
	    /**
	     * Toggles the text formats from `from` to `to` with the given text formats. If the text has the exact formats already
	     * they will be removed, otherwise they will be added.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the text
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.toggleTextFormat = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var existing = this.getTextFormat(from, to);
	        var isSame = Object.keys(formats).every(function (key) { return formats[key] === existing[key]; });
	        if (isSame) {
	            Object.keys(formats).forEach(function (key) { return formats[key] = null; });
	        }
	        return this.formatText(from, to, formats, source);
	    };
	    /**
	     * Removes all formatting, text and line formats, for the text and lines from `from` to `to`.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.removeFormats = function (from, to, source) {
	        var _this = this;
	        var _a;
	        _a = this._normalizeRange(from, to, source), from = _a[0], to = _a[1], source = _a[2];
	        var formats = {};
	        this.contents.getOps(from, to).forEach(function (_a) {
	            var op = _a.op;
	            op.attributes && Object.keys(op.attributes).forEach(function (key) { return formats[key] = null; });
	        });
	        var change = this.delta().retain(from).retain(to - from, formats);
	        // If the last block was not captured be sure to clear that too
	        this.contents.getLines(from, to).forEach(function (line) {
	            var formats = {};
	            Object.keys(line.attributes).forEach(function (key) { return formats[key] = null; });
	            change = change.compose(_this.delta().retain(line.end - 1).retain(1, formats));
	        });
	        return this.updateContents(change, source);
	    };
	    /**
	     * Create a change delta calling one or more methods on the editor. The changes will not be applied as normal but will
	     * be collated into a single change delta and returned from this methnod. Example:
	     * ```js
	     * var change = editor.getChange(function() {
	     *   editor.deleteText(0, 5);
	     *   editor.insertText('\n', { blockquote: true });
	     *   editor.formatText(10, 20, { bold: true });
	     * });
	     *
	     * editor.updateContents(change, 'user');
	     * ```
	     *
	     * @param {Function} producer A function in which to call methods on the editor to produce a change
	     * @returns {Delta}           The sum of all the changes made within the producer
	     */
	    Editor.prototype.getChange = function (producer) {
	        var change = this.delta();
	        this.updateContents = function (singleChange) {
	            if (singleChange.ops.length) {
	                change = change.compose(singleChange);
	                return singleChange;
	            }
	            else {
	                return null;
	            }
	        };
	        producer(this);
	        delete this.updateContents;
	        return change;
	    };
	    /**
	     * Make several changes to the editor apply all at one in one commit. Changes made with the transaction will be
	     * applied all together and the "text-changing", "text-change", and "selection-change" events will be dispatched only
	     * once. Use this to combine multiple changes into one.
	     *
	     * @param {Function} producer A function which should make changes with the editor
	     * @param {String} source     The source of the change, user, api, or silent
	     * @param {Array} selection   Optional selection after the change has been applied
	     * @returns {Delta}           Returns the change when successful, or null if not
	     */
	    Editor.prototype.transaction = function (producer, source, selection) {
	        var change = this.getChange(producer);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Returns the selected range (or the provided range) in index order (lowest number first) and within the bounds of
	     * the content, between 0 and content.length() - 1 (the selection cannot be past the trailing newline).
	     *
	     * @param {Array} range Optional range, defaults to current selection
	     * @param {Number} max  The maxium number the range can be
	     */
	    Editor.prototype.getSelectedRange = function (range, max) {
	        if (range === void 0) { range = this.selection; }
	        if (max === void 0) { max = this.length - 1; }
	        var _a;
	        if (range == null)
	            return range;
	        if (typeof range === 'number')
	            range = [range, range];
	        if (range[0] > range[1])
	            _a = [range[1], range[0]], range[0] = _a[0], range[1] = _a[1];
	        return range.map(function (index) { return Math.max(0, Math.min(max, index)); });
	    };
	    Editor.prototype._queueEvents = function (events) {
	        var _a;
	        var alreadyRunning = this._queuedEvents.length;
	        (_a = this._queuedEvents).push.apply(_a, events);
	        if (alreadyRunning)
	            return;
	        while (this._queuedEvents.length) {
	            var event = this._queuedEvents.shift();
	            this.fire.apply(this, event);
	        }
	    };
	    /**
	     * Normalizes range values to a proper range if it is not already. A range is a `from` and a `to` index, e.g. 0, 4.
	     * This will ensure the lower index is first. Example usage:
	     * editor._normalizeRange(5); // [5, 5]
	     * editor._normalizeRange(-4, 100); // for a doc with length 10, [0, 10]
	     * editor._normalizeRange(25, 18); // [18, 25]
	     * editor._normalizeRange([12, 13]); // [12, 13]
	     * editor._normalizeRange(5, { bold: true }); // [5, 5, { bold: true }]
	     */
	    Editor.prototype._normalizeRange = function (from, to) {
	        var rest = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            rest[_i - 2] = arguments[_i];
	        }
	        var _a;
	        _a = this._normalizeSelection.apply(this, [from, to].concat(rest)), from = _a[0], to = _a[1], rest = _a.slice(2);
	        if (from > to) {
	            var toValue = from;
	            from = to;
	            to = toValue;
	        }
	        return [from, to].concat(rest);
	    };
	    Editor.prototype._normalizeSelection = function (from, to) {
	        var rest = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            rest[_i - 2] = arguments[_i];
	        }
	        var _a;
	        if (Array.isArray(from)) {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            _a = from, from = _a[0], to = _a[1];
	            if (to === undefined)
	                to = from;
	        }
	        else if (typeof from !== 'number') {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            if (from !== undefined || rest.length)
	                rest.unshift(from);
	            from = to = 0;
	        }
	        else if (typeof to !== 'number') {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            to = from;
	        }
	        from = Math.max(0, Math.min(this.length, Math.floor(from)));
	        to = Math.max(0, Math.min(this.length, Math.floor(to)));
	        return [from, to].concat(rest);
	    };
	    return Editor;
	}(EventDispatcher$1$2));
	// Ensures the format for the current line in a delete remains the same when multiple lines are deleted. This is needed
	// because the last line holds the formatting after a delete, but the first line is expected to be the retained format
	function cleanDelete$1$2(editor, from, to, change) {
	    if (from !== to) {
	        var line = editor.contents.getLine(from);
	        if (!line.ops.length() && to === from + 1)
	            return change;
	        var lineFormat_2 = editor.getLineFormat(from);
	        if (!deepEqual$1$2(lineFormat_2, editor.getLineFormat(to))) {
	            var lineChange = editor.getChange(function () { return editor.formatLine(to, lineFormat_2); });
	            change = change.compose(change.transform(lineChange));
	        }
	    }
	    return change;
	}
	// Ensures contents end with a newline
	function normalizeContents$1$2(contents) {
	    // Contents only have inserts. Deletes and retains belong to changes only.
	    contents.ops = contents.ops.filter(function (op) { return op.insert; });
	    var lastOp = contents.ops[contents.ops.length - 1];
	    if (!lastOp || typeof lastOp.insert !== 'string' || lastOp.insert.slice(-1) !== '\n')
	        contents.insert('\n');
	    return contents;
	}
	// Sets the contents onto the editor after ensuring they end in a newline, freezes the contents from change, and
	// updates the length and text of the editor to the latest
	function setContents$1$2(editor, contents) {
	    contents = normalizeContents$1$2(contents);
	    contents.freeze();
	    editor.contents = contents;
	    editor.length = contents.length();
	}
	// Combine formats removing ones that don't exist in both and creating an array for those with multiple values
	function combineFormats$1$2(formats, combined) {
	    return Object.keys(combined).reduce(function (merged, name) {
	        if (formats[name] == null)
	            return merged;
	        if (combined[name] === formats[name]) {
	            merged[name] = combined[name];
	        }
	        else if (Array.isArray(combined[name])) {
	            if (combined[name].indexOf(formats[name]) < 0) {
	                merged[name] = combined[name].concat([formats[name]]);
	            }
	        }
	        else {
	            merged[name] = [combined[name], formats[name]];
	        }
	        return merged;
	    }, {});
	}
	var isMac$3 = navigator.userAgent.indexOf('Macintosh') !== -1;

	function decorate(root, contents) {
	    var decorators = new Decorators(contents);
	    root.dispatchEvent(new CustomEvent('decorate', { detail: decorators }));
	    var change = decorators.getChange();
	    if (change.ops.length) {
	        change.forEach(function (op) {
	            if (op["delete"] || (op.retain && op.attributes && !op.attributes.decorator) || (op.insert && !op.insert.decorator)) {
	                throw new Error('Decorators may not insert text or delete contents.');
	            }
	        });
	        contents = contents.compose(change);
	    }
	    return contents;
	}
	var Decorators = /** @class */ (function () {
	    function Decorators(contents) {
	        this.contents = contents;
	        this.change;
	        this.delta = new Delta$1$2();
	        this.position = 0;
	    }
	    Decorators.prototype.mark = function (from, to, attributes) {
	        var _a;
	        _a = this.updatePosition(from, to), from = _a[0], to = _a[1];
	        var length = to - from;
	        this.delta.retain(length, { decorator: attributes });
	        this.position += length;
	    };
	    Decorators.prototype.embed = function (at, attributes) {
	        at = this.updatePosition(at);
	        this.delta.insert({ decorator: attributes });
	        this.position += 1;
	    };
	    Decorators.prototype.getChange = function () {
	        return this.change ? this.change.compose(this.delta) : this.delta;
	    };
	    Decorators.prototype.updatePosition = function (from, to) {
	        if (this.change) {
	            from = this.change.transformPosition(from);
	            if (to != null)
	                to = this.change.transformPosition(to);
	        }
	        // Optimize by adding to the existing delta when possible, compose is slow
	        if (this.position < from) {
	            this.delta.retain(from - this.position);
	            this.position = from;
	        }
	        else if (this.position) {
	            this.change = this.getChange();
	            from = this.change.transformPosition(from);
	            if (to != null)
	                to = this.change.transformPosition(to);
	            this.delta = new Delta$1$2();
	            this.delta.retain(from);
	            this.position = from;
	        }
	        return to != null ? [from, to] : from;
	    };
	    return Decorators;
	}());

	var indexOf$1 = [].indexOf;
	// Get the range (a tuple of indexes) for this view from the browser selection
	function getSelection$1(root, paper, range) {
	    var selection = !range ? root.ownerDocument.getSelection() : {
	        anchorNode: range.startContainer, anchorOffset: range.startOffset,
	        focusNode: range.endContainer, focusOffset: range.endOffset,
	        isCollapsed: range.collapsed
	    };
	    if (!root.contains(selection.anchorNode)) {
	        return null;
	    }
	    else {
	        var anchorIndex = getNodeAndOffsetIndex$1(root, paper, selection.anchorNode, selection.anchorOffset);
	        var isCollapsed = selection.anchorNode === selection.focusNode && selection.anchorOffset === selection.focusOffset;
	        // selection.isCollapsed causes a layout on Chrome. ?? Manual detection does not.
	        var focusIndex = isCollapsed ?
	            anchorIndex :
	            getNodeAndOffsetIndex$1(root, paper, selection.focusNode, selection.focusOffset);
	        return [anchorIndex, focusIndex];
	    }
	}
	// Set the browser selection to the range (a tuple of indexes) of this view
	function setSelection(root, paper, range) {
	    var selection = root.ownerDocument.getSelection();
	    var hasFocus = selection.anchorNode && root.contains(selection.anchorNode);
	    if (range == null) {
	        if (hasFocus) {
	            root.blur();
	            selection.removeAllRanges();
	        }
	    }
	    else {
	        var _a = getNodesForRange$1(root, paper, range), anchorNode = _a[0], anchorOffset = _a[1], focusNode = _a[2], focusOffset = _a[3];
	        var type = range[0] === range[1] ? 'Caret' : 'Range';
	        if (anchorNode && focusNode) {
	            if (selection.anchorNode !== anchorNode || selection.anchorOffset !== anchorOffset ||
	                selection.focusNode !== focusNode || selection.focusOffset !== focusOffset || selection.type !== type) {
	                selection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);
	            }
	        }
	        if (!hasFocus)
	            root.focus();
	    }
	}
	/**
	 * Get the position and size of a range as it is displayed in the DOM relative to the top left of visible document.
	 * You can use `getBounds(editor.selection)` to find the coordinates of the current selection and display a popup at
	 * that location.
	 */
	function getBounds$1(root, paper, range) {
	    return getBoudingBrowserRange$1(root, paper, range).getBoundingClientRect();
	}
	function getBoudingBrowserRange$1(root, paper, range) {
	    var browserRange = getBrowserRange$1(root, paper, range);
	    if (browserRange.endContainer.nodeType === Node.ELEMENT_NODE) {
	        try {
	            browserRange.setEnd(browserRange.endContainer, browserRange.endOffset + 1);
	        }
	        catch (e) { }
	    }
	    return browserRange;
	}
	// Get a browser range object for the given editor range tuple
	function getBrowserRange$1(root, paper, range) {
	    if (range[0] > range[1])
	        range = [range[1], range[0]];
	    var _a = getNodesForRange$1(root, paper, range), anchorNode = _a[0], anchorOffset = _a[1], focusNode = _a[2], focusOffset = _a[3];
	    var browserRange = document.createRange();
	    if (anchorNode && focusNode) {
	        browserRange.setStart(anchorNode, anchorOffset);
	        browserRange.setEnd(focusNode, focusOffset);
	    }
	    return browserRange;
	}
	// Get the browser nodes and offsets for the range (a tuple of indexes) of this view
	function getNodesForRange$1(root, paper, range) {
	    if (range == null) {
	        return [null, 0, null, 0];
	    }
	    else {
	        var _a = getNodeAndOffset$1(root, paper, range[0]), anchorNode = _a[0], anchorOffset = _a[1];
	        var _b = range[0] === range[1] ?
	            [anchorNode, anchorOffset] : getNodeAndOffset$1(root, paper, range[1]), focusNode = _b[0], focusOffset = _b[1];
	        return [anchorNode, anchorOffset, focusNode, focusOffset];
	    }
	}
	function getNodeAndOffset$1(root, paper, index) {
	    var inDom = root.ownerDocument.contains(root);
	    var blocks = paper.blocks, embeds = paper.embeds;
	    var walker = root.ownerDocument.createTreeWalker(root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, {
	        acceptNode: inDom ? acceptNodeInDom$2 : acceptNode$2
	    });
	    var count = 0, node, firstBlockSeen = false;
	    walker.currentNode = root;
	    while ((node = walker.nextNode())) {
	        if (node.nodeType === Node.TEXT_NODE) {
	            var size = node.nodeValue.length;
	            if (index <= count + size)
	                return [node, index - count];
	            count += size;
	        }
	        else if (node.className.indexOf('decorator') !== -1) {
	            continue;
	        }
	        else if (embeds.matches(node) && !isBRPlaceholder$2(paper, node)) {
	            count += 1;
	            // If the selection lands after this embed, and the next node isn't a text node, place the selection
	            var next = nextNonEmptyTextSibling$1(node);
	            if (count === index && (!next || next.nodeType !== Node.TEXT_NODE)) {
	                return [node.parentNode, indexOf$1.call(node.parentNode.childNodes, node) + 1];
	            }
	        }
	        else if (blocks.matches(node)) {
	            if (firstBlockSeen)
	                count += 1;
	            else
	                firstBlockSeen = true;
	            // If the selection lands at the beginning of a block, and the first node isn't a text node, place the selection
	            if (count === index) {
	                var first = firstNonEmptyTextChild$1(node);
	                if (!first)
	                    return [node, 0];
	                else if (first.nodeType !== Node.TEXT_NODE)
	                    return [node, indexOf$1.call(node.childNodes, first)];
	            }
	        }
	    }
	    return [null, 0];
	}
	function getNodeAndOffsetIndex$1(root, paper, node, offset) {
	    if (node.nodeType === Node.ELEMENT_NODE && offset > 0) {
	        node = node.childNodes[offset - 1];
	        offset = node.nodeType === Node.ELEMENT_NODE ? 0 : node.nodeValue.length;
	    }
	    return getNodeIndex$1(root, paper, node) + offset;
	}
	// Get the index the node starts at in the content
	function getNodeIndex$1(root, paper, node) {
	    var inDom = root.ownerDocument.contains(root);
	    var blocks = paper.blocks, embeds = paper.embeds;
	    var walker = root.ownerDocument.createTreeWalker(root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, {
	        acceptNode: inDom ? acceptNodeInDom$2 : acceptNode$2
	    });
	    walker.currentNode = node;
	    var index = node.nodeType === Node.ELEMENT_NODE ? 0 : -1;
	    while ((node = walker.previousNode())) {
	        if (node === root)
	            continue;
	        else if (node.nodeType === Node.TEXT_NODE)
	            index += node.nodeValue.length;
	        else if (node.className.indexOf('decorator') !== -1)
	            ;
	        else if (embeds.matches(node) && !isBRPlaceholder$2(paper, node))
	            index++;
	        else if (blocks.matches(node))
	            index++;
	    }
	    return index;
	}
	function acceptNode$2(node) {
	    if (node.nodeType === Node.TEXT_NODE) {
	        return node.nodeValue.length ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
	    }
	    return NodeFilter.FILTER_REJECT;
	}
	function acceptNodeInDom$2(node) {
	    if (node.nodeType === Node.TEXT_NODE) {
	        return node.nodeValue.length ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
	    }
	    return NodeFilter.FILTER_ACCEPT;
	}
	function firstNonEmptyTextChild$1(parent) {
	    var node = parent.firstChild;
	    if (!node)
	        return null;
	    while (node && node.nodeValue === '') {
	        node = node.nextSibling;
	    }
	    return node;
	}
	function nextNonEmptyTextSibling$1(node) {
	    var nextSibling = node.nextSibling;
	    while (nextSibling && nextSibling.nodeValue === '') {
	        nextSibling = nextSibling.nextSibling;
	    }
	    return nextSibling;
	}

	function fromDelta(ops) {
	    var blocks = [];
	    var contents;
	    ops.forEach(function (op) {
	        if (typeof op.insert === 'string') {
	            if (!op.insert.replace(/\n+/, '').length) {
	                // Handle blocks
	                blocks.push.apply(blocks, getBlocks(op, contents));
	                contents = undefined;
	            }
	            else {
	                // Handle contents and paragraph blocks
	                if (op.insert.indexOf('\n') === -1) {
	                    if (!contents)
	                        contents = [op];
	                    else
	                        contents.push(op);
	                }
	                else {
	                    op.insert.split('\n').forEach(function (value, i, lines) {
	                        if (value) {
	                            var content = getContent(value, op.attributes);
	                            if (!contents)
	                                contents = [content];
	                            else
	                                contents.push(content);
	                        }
	                        if (i < lines.length - 1) {
	                            blocks.push(getBlock(undefined, contents));
	                            contents = undefined;
	                        }
	                    });
	                }
	            }
	        }
	        else {
	            // Handle embeds
	            if (!contents)
	                contents = [op];
	            else
	                contents.push(op);
	        }
	    });
	    if (contents) {
	        console.log('contents at the end, should this happen?', contents);
	        blocks.push(getBlock(undefined, contents));
	    }
	    return blocks;
	}
	function getBlocks(op, contents) {
	    var blocks = [];
	    blocks.push(getBlock(op.attributes, contents));
	    for (var i = 1; i < op.insert.length; i++) {
	        blocks.push(getBlock(op.attributes));
	    }
	    return blocks;
	}
	function getBlock(attributes, contents) {
	    if (contents === void 0) { contents = []; }
	    if (attributes)
	        return { attributes: attributes, contents: contents };
	    else
	        return { contents: contents };
	}
	function getContent(insert, attributes) {
	    if (attributes)
	        return { insert: insert, attributes: attributes };
	    else
	        return { insert: insert };
	}

	/* src/components/EditorContents.svelte generated by Svelte v3.0.0-beta.21 */

	function get_each_context$5(ctx, list, i) {
		const child_ctx = Object.create(ctx);
		child_ctx.handler = list[i];
		return child_ctx;
	}

	// (4:2) {:else}
	function create_else_block$2(ctx) {
		var switch_instance_anchor, current;

		var switch_value = ctx.handler.component;

		function switch_props(ctx) {
			return {
				props: {
				block: ctx.handler.block,
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			}
			};
		}

		if (switch_value) {
			var switch_instance = new switch_value(switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) switch_instance.$$.fragment.c();
				switch_instance_anchor = internal_17$2();
			},

			m(target, anchor) {
				if (switch_instance) {
					internal_99$2(switch_instance, target, anchor);
				}

				internal_7$2(target, switch_instance_anchor, anchor);
				current = true;
			},

			p(changed, ctx) {
				var switch_instance_changes = {};
				if (changed.handlers) switch_instance_changes.block = ctx.handler.block;
				if (changed.handlers || changed.paper) switch_instance_changes.$$scope = { changed, ctx };

				if (switch_value !== (switch_value = ctx.handler.component)) {
					if (switch_instance) {
						internal_75$2();
						const old_component = switch_instance;
						internal_77$2(() => {
							old_component.$destroy();
						});
						old_component.$$.fragment.o(1);
						internal_76$2();
					}

					if (switch_value) {
						switch_instance = new switch_value(switch_props(ctx));

						switch_instance.$$.fragment.c();
						switch_instance.$$.fragment.i(1);
						internal_99$2(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				}

				else if (switch_value) {
					switch_instance.$set(switch_instance_changes);
				}
			},

			i(local) {
				if (current) return;
				if (switch_instance) switch_instance.$$.fragment.i(local);

				current = true;
			},

			o(local) {
				if (switch_instance) switch_instance.$$.fragment.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(switch_instance_anchor);
				}

				if (switch_instance) switch_instance.$destroy(detaching);
			}
		};
	}

	// (2:2) {#if handler.blocks}
	function create_if_block$5(ctx) {
		var switch_instance_anchor, current;

		var switch_value = ctx.handler.component;

		function switch_props(ctx) {
			return {
				props: {
				blocks: ctx.handler.blocks,
				$$slots: {
				default: [create_default_slot$4, ({ block }) => ({ block })]
			},
				$$scope: { ctx }
			}
			};
		}

		if (switch_value) {
			var switch_instance = new switch_value(switch_props(ctx));
		}

		return {
			c() {
				if (switch_instance) switch_instance.$$.fragment.c();
				switch_instance_anchor = internal_17$2();
			},

			m(target, anchor) {
				if (switch_instance) {
					internal_99$2(switch_instance, target, anchor);
				}

				internal_7$2(target, switch_instance_anchor, anchor);
				current = true;
			},

			p(changed, ctx) {
				var switch_instance_changes = {};
				if (changed.handlers) switch_instance_changes.blocks = ctx.handler.blocks;
				if (changed.paper) switch_instance_changes.$$scope = { changed, ctx };

				if (switch_value !== (switch_value = ctx.handler.component)) {
					if (switch_instance) {
						internal_75$2();
						const old_component = switch_instance;
						internal_77$2(() => {
							old_component.$destroy();
						});
						old_component.$$.fragment.o(1);
						internal_76$2();
					}

					if (switch_value) {
						switch_instance = new switch_value(switch_props(ctx));

						switch_instance.$$.fragment.c();
						switch_instance.$$.fragment.i(1);
						internal_99$2(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				}

				else if (switch_value) {
					switch_instance.$set(switch_instance_changes);
				}
			},

			i(local) {
				if (current) return;
				if (switch_instance) switch_instance.$$.fragment.i(local);

				current = true;
			},

			o(local) {
				if (switch_instance) switch_instance.$$.fragment.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(switch_instance_anchor);
				}

				if (switch_instance) switch_instance.$destroy(detaching);
			}
		};
	}

	// (5:4) <svelte:component this={handler.component} block={handler.block}>
	function create_default_slot_1$2(ctx) {
		var current;

		var blockcontents = new BlockContents({
			props: {
			contents: ctx.handler.block.contents,
			paper: ctx.paper
		}
		});

		return {
			c() {
				blockcontents.$$.fragment.c();
			},

			m(target, anchor) {
				internal_99$2(blockcontents, target, anchor);
				current = true;
			},

			p(changed, ctx) {
				var blockcontents_changes = {};
				if (changed.handlers) blockcontents_changes.contents = ctx.handler.block.contents;
				if (changed.paper) blockcontents_changes.paper = ctx.paper;
				blockcontents.$set(blockcontents_changes);
			},

			i(local) {
				if (current) return;
				blockcontents.$$.fragment.i(local);

				current = true;
			},

			o(local) {
				blockcontents.$$.fragment.o(local);
				current = false;
			},

			d(detaching) {
				blockcontents.$destroy(detaching);
			}
		};
	}

	// (3:4) <svelte:component this={handler.component} blocks={handler.blocks} let:block>
	function create_default_slot$4(ctx) {
		var current;

		var blockcontents = new BlockContents({
			props: {
			contents: ctx.block.contents,
			paper: ctx.paper
		}
		});

		return {
			c() {
				blockcontents.$$.fragment.c();
			},

			m(target, anchor) {
				internal_99$2(blockcontents, target, anchor);
				current = true;
			},

			p(changed, ctx) {
				var blockcontents_changes = {};
				if (changed.block) blockcontents_changes.contents = ctx.block.contents;
				if (changed.paper) blockcontents_changes.paper = ctx.paper;
				blockcontents.$set(blockcontents_changes);
			},

			i(local) {
				if (current) return;
				blockcontents.$$.fragment.i(local);

				current = true;
			},

			o(local) {
				blockcontents.$$.fragment.o(local);
				current = false;
			},

			d(detaching) {
				blockcontents.$destroy(detaching);
			}
		};
	}

	// (1:0) {#each handlers as handler}
	function create_each_block$5(ctx) {
		var current_block_type_index, if_block, if_block_anchor, current;

		var if_block_creators = [
			create_if_block$5,
			create_else_block$2
		];

		var if_blocks = [];

		function select_block_type(ctx) {
			if (ctx.handler.blocks) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		return {
			c() {
				if_block.c();
				if_block_anchor = internal_17$2();
			},

			m(target, anchor) {
				if_blocks[current_block_type_index].m(target, anchor);
				internal_7$2(target, if_block_anchor, anchor);
				current = true;
			},

			p(changed, ctx) {
				var previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);
				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(changed, ctx);
				} else {
					internal_75$2();
					internal_77$2(() => {
						if_blocks[previous_block_index].d(1);
						if_blocks[previous_block_index] = null;
					});
					if_block.o(1);
					internal_76$2();

					if_block = if_blocks[current_block_type_index];
					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}
					if_block.i(1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			},

			i(local) {
				if (current) return;
				if (if_block) if_block.i();
				current = true;
			},

			o(local) {
				if (if_block) if_block.o();
				current = false;
			},

			d(detaching) {
				if_blocks[current_block_type_index].d(detaching);

				if (detaching) {
					internal_8$2(if_block_anchor);
				}
			}
		};
	}

	function create_fragment$g(ctx) {
		var each_1_anchor, current;

		var each_value = ctx.handlers;

		var each_blocks = [];

		for (var i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
		}

		function outro_block(i, detaching, local) {
			if (each_blocks[i]) {
				if (detaching) {
					internal_77$2(() => {
						each_blocks[i].d(detaching);
						each_blocks[i] = null;
					});
				}

				each_blocks[i].o(local);
			}
		}

		return {
			c() {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = internal_17$2();
			},

			m(target, anchor) {
				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(target, anchor);
				}

				internal_7$2(target, each_1_anchor, anchor);
				current = true;
			},

			p(changed, ctx) {
				if (changed.handlers || changed.paper) {
					each_value = ctx.handlers;

					for (var i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$5(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(changed, child_ctx);
							each_blocks[i].i(1);
						} else {
							each_blocks[i] = create_each_block$5(child_ctx);
							each_blocks[i].c();
							each_blocks[i].i(1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					internal_75$2();
					for (; i < each_blocks.length; i += 1) outro_block(i, 1, 1);
					internal_76$2();
				}
			},

			i(local) {
				if (current) return;
				for (var i = 0; i < each_value.length; i += 1) each_blocks[i].i();

				current = true;
			},

			o(local) {
				each_blocks = each_blocks.filter(Boolean);
				for (let i = 0; i < each_blocks.length; i += 1) outro_block(i, 0);

				current = false;
			},

			d(detaching) {
				internal_12$2(each_blocks, detaching);

				if (detaching) {
					internal_8$2(each_1_anchor);
				}
			}
		};
	}

	function instance$e($$self, $$props, $$invalidate) {
		

	let { api = {}, editor, paper, modules = {}, root = null } = $$props;

	function getBounds$1$1(from, to) {
	  const range = from != null && to != null ? [ from, to ] : from != null ? [ from, from ] : editor.selection;
	  if (range === null) return null;
	  return getBounds$1(root, paper, range);
	}

	let oldEditor;
	let handlers;
	let blocks = []; // derive blocks from editor
	let lastSelection;
	let doc;
	let settingEditorSelection = false;
	let settingDomSelection = false;


	async function updateHandlers(blocks) {
	  if (root) root.dispatchEvent(new Event('rendering'));

	  handlers = []; $$invalidate('handlers', handlers);
	  blocks.forEach(block => {
	    const component = getComponent(paper.blocks.findByAttributes(block.attributes, true).name);
	    if (!component) throw new Error(`No component for block: ${block.node.name}`);

	    if (component.rendersMultiple) {
	      const last = handlers[handlers.length - 1];
	      if (last && last.component === component) {
	        last.blocks.push(block);
	      } else {
	        handlers.push({ component, blocks: [ block ] });
	      }
	    } else {
	      handlers.push({ component, block });
	    }

	    return handlers;
	  });

	  await svelte_7$2();
	  if (root) root.dispatchEvent(new Event('render'));
	}


	svelte_2$2(() => {
	  cleanupEditor();
	  cleanupModules();
	});

	async function setupEditor(root, editor) {
	  if (root && editor) {
	    editor.on('editor-change', onEditorChange);
	    doc = root.ownerDocument; $$invalidate('doc', doc);
	    doc.addEventListener('selectionchange', updateEditorSelection);
	    oldEditor = editor; $$invalidate('oldEditor', oldEditor);
	    await svelte_7$2();
	    onEditorChange({ contents: editor.contents, change: editor.contents });
	  }
	}

	function cleanupEditor() {
	  if (oldEditor) {
	    oldEditor.off('editor-change', onEditorChange);
	    doc.removeEventListener('selectionchange', updateEditorSelection);
	    doc = null; $$invalidate('doc', doc);
	  }
	}

	function setupModules(root, paper, modules) {
	  if (root && paper) {
	    Object.keys(modules).map(name => { const $$result = api[name] = modules[name](editor, root, paper); $$invalidate('api', api); return $$result; });
	  }
	}

	function cleanupModules() {
	  Object.values(api).forEach(module => {
	    if (module && typeof module.onDestroy === 'function') module.onDestroy();
	  });
	  api = {}; $$invalidate('api', api);
	}

	async function onEditorChange({ contents, change }) {
	  // Update in-memory block version of document with this change
	  if (change) {
	    contents = decorate(root, contents);
	    blocks = fromDelta(contents.ops); $$invalidate('blocks', blocks);
	    await svelte_7$2();
	  }
	  updateDomSelection();
	}

	function updateEditorSelection() {
	  if (settingDomSelection) {
	    settingDomSelection = false; $$invalidate('settingDomSelection', settingDomSelection);
	    return;
	  }
	  const range = getSelection$1(root, paper);

	  // Store the last non-null selection for restoration on focus()
	  if (range) { lastSelection = range; $$invalidate('lastSelection', lastSelection); }

	  settingEditorSelection = true; $$invalidate('settingEditorSelection', settingEditorSelection);
	  editor.setSelection(range, 'user');
	  settingEditorSelection = false; $$invalidate('settingEditorSelection', settingEditorSelection);

	  // If the selection was adjusted when set then update the browser's selection
	  if (!shallowEqual$4(range, editor.selection)) {
	    updateDomSelection();
	  }
	}

	function updateDomSelection() {
	  if (settingEditorSelection) return;
	  settingDomSelection = true; $$invalidate('settingDomSelection', settingDomSelection);
	  setSelection(root, paper, editor.selection);
	  setTimeout(() => { const $$result = settingDomSelection = false; $$invalidate('settingDomSelection', settingDomSelection); return $$result; }, 20); // sad hack :(
	}

		$$self.$set = $$props => {
			if ('api' in $$props) $$invalidate('api', api = $$props.api);
			if ('editor' in $$props) $$invalidate('editor', editor = $$props.editor);
			if ('paper' in $$props) $$invalidate('paper', paper = $$props.paper);
			if ('modules' in $$props) $$invalidate('modules', modules = $$props.modules);
			if ('root' in $$props) $$invalidate('root', root = $$props.root);
		};

		$$self.$$.update = ($$dirty = { blocks: 1, root: 1, editor: 1, paper: 1, modules: 1 }) => {
			if ($$dirty.blocks) {
				updateHandlers(blocks);
			}
			if ($$dirty.root || $$dirty.editor) {
	      cleanupEditor();
	      setupEditor(root, editor);
	    }
			if ($$dirty.root || $$dirty.paper || $$dirty.modules) {
	      cleanupModules();
	      setupModules(root, paper, modules);
	    }
		};

		return {
			api,
			editor,
			paper,
			modules,
			root,
			getBounds: getBounds$1$1,
			handlers
		};
	}

	class EditorContents extends internal_101$2 {
		constructor(options) {
			super();
			internal_100$2(this, options, instance$e, create_fragment$g, internal_91$2, ["api", "editor", "paper", "modules", "root", "getBounds"]);
		}

		get api() {
			return this.$$.ctx.api;
		}

		set api(api) {
			this.$set({ api });
			internal_63$2();
		}

		get editor() {
			return this.$$.ctx.editor;
		}

		set editor(editor) {
			this.$set({ editor });
			internal_63$2();
		}

		get paper() {
			return this.$$.ctx.paper;
		}

		set paper(paper) {
			this.$set({ paper });
			internal_63$2();
		}

		get modules() {
			return this.$$.ctx.modules;
		}

		set modules(modules) {
			this.$set({ modules });
			internal_63$2();
		}

		get root() {
			return this.$$.ctx.root;
		}

		set root(root) {
			this.$set({ root });
			internal_63$2();
		}

		get getBounds() {
			return this.$$.ctx.getBounds;
		}
	}

	/* src/components/EditorView.svelte generated by Svelte v3.0.0-beta.21 */

	function create_fragment$h(ctx) {
		var div, updating_api, updating_getBounds, div_class_value, div_contenteditable_value, current;

		function editorcontents_api_binding(value) {
			if (ctx.editorcontents_api_binding.call(null, value)) {
				updating_api = true;
			}
		}

		function editorcontents_getBounds_binding(value) {
			if (ctx.editorcontents_getBounds_binding.call(null, value)) {
				updating_getBounds = true;
			}
		}

		let editorcontents_props = {
			root: ctx.root,
			editor: ctx.editor,
			paper: ctx.paper,
			modules: ctx.modules
		};
		if (ctx.api !== void 0) {
			editorcontents_props.api = ctx.api;
		}
		if (ctx.getBounds !== void 0) {
			editorcontents_props.getBounds = ctx.getBounds;
		}
		var editorcontents = new EditorContents({ props: editorcontents_props });

		internal_62$2(() => internal_98$2(editorcontents, 'api', editorcontents_api_binding));
		internal_62$2(() => internal_98$2(editorcontents, 'getBounds', editorcontents_getBounds_binding));

		return {
			c() {
				div = internal_13$2("div");
				editorcontents.$$.fragment.c();
				div.className = div_class_value = ctx.className || '';
				div.contentEditable = div_contenteditable_value = !ctx.disabled;
			},

			m(target, anchor) {
				internal_7$2(target, div, anchor);
				internal_99$2(editorcontents, div, null);
				internal_62$2(() => ctx.div_binding(div, null));
				current = true;
			},

			p(changed, ctx) {
				var editorcontents_changes = {};
				if (changed.root) editorcontents_changes.root = ctx.root;
				if (changed.editor) editorcontents_changes.editor = ctx.editor;
				if (changed.paper) editorcontents_changes.paper = ctx.paper;
				if (changed.modules) editorcontents_changes.modules = ctx.modules;
				if (!updating_api && changed.api) {
					editorcontents_changes.api = ctx.api;
				}
				if (!updating_getBounds && changed.getBounds) {
					editorcontents_changes.getBounds = ctx.getBounds;
				}
				editorcontents.$set(editorcontents_changes);
				updating_api = updating_getBounds = false;

				if (changed.items) {
					ctx.div_binding(null, div);
					ctx.div_binding(div, null);
				}

				if ((!current || changed.className) && div_class_value !== (div_class_value = ctx.className || '')) {
					div.className = div_class_value;
				}

				if ((!current || changed.disabled) && div_contenteditable_value !== (div_contenteditable_value = !ctx.disabled)) {
					div.contentEditable = div_contenteditable_value;
				}
			},

			i(local) {
				if (current) return;
				editorcontents.$$.fragment.i(local);

				current = true;
			},

			o(local) {
				editorcontents.$$.fragment.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8$2(div);
				}

				editorcontents.$destroy();

				ctx.div_binding(null, div);
			}
		};
	}

	function instance$f($$self, $$props, $$invalidate) {
		let { class: className = null, disabled = false, api = {}, editor, paper, modules = {}, root = null, getBounds = null } = $$props;

		function editorcontents_api_binding(value) {
			api = value;
			return $$invalidate('api', api)
		}

		function editorcontents_getBounds_binding(value) {
			getBounds = value;
			return $$invalidate('getBounds', getBounds)
		}

		function div_binding($$node, check) {
			root = $$node;
			$$invalidate('root', root);
		}

		$$self.$set = $$props => {
			if ('class' in $$props) $$invalidate('className', className = $$props.class);
			if ('disabled' in $$props) $$invalidate('disabled', disabled = $$props.disabled);
			if ('api' in $$props) $$invalidate('api', api = $$props.api);
			if ('editor' in $$props) $$invalidate('editor', editor = $$props.editor);
			if ('paper' in $$props) $$invalidate('paper', paper = $$props.paper);
			if ('modules' in $$props) $$invalidate('modules', modules = $$props.modules);
			if ('root' in $$props) $$invalidate('root', root = $$props.root);
			if ('getBounds' in $$props) $$invalidate('getBounds', getBounds = $$props.getBounds);
		};

		return {
			className,
			disabled,
			api,
			editor,
			paper,
			modules,
			root,
			getBounds,
			editorcontents_api_binding,
			editorcontents_getBounds_binding,
			div_binding
		};
	}

	class EditorView extends internal_101$2 {
		constructor(options) {
			super();
			internal_100$2(this, options, instance$f, create_fragment$h, internal_91$2, ["class", "disabled", "api", "editor", "paper", "modules", "root", "getBounds"]);
		}

		get class() {
			return this.$$.ctx.className;
		}

		set class(className) {
			this.$set({ class: className });
			internal_63$2();
		}

		get disabled() {
			return this.$$.ctx.disabled;
		}

		set disabled(disabled) {
			this.$set({ disabled });
			internal_63$2();
		}

		get api() {
			return this.$$.ctx.api;
		}

		set api(api) {
			this.$set({ api });
			internal_63$2();
		}

		get editor() {
			return this.$$.ctx.editor;
		}

		set editor(editor) {
			this.$set({ editor });
			internal_63$2();
		}

		get paper() {
			return this.$$.ctx.paper;
		}

		set paper(paper) {
			this.$set({ paper });
			internal_63$2();
		}

		get modules() {
			return this.$$.ctx.modules;
		}

		set modules(modules) {
			this.$set({ modules });
			internal_63$2();
		}

		get root() {
			return this.$$.ctx.root;
		}

		set root(root) {
			this.$set({ root });
			internal_63$2();
		}

		get getBounds() {
			return this.$$.ctx.getBounds;
		}

		set getBounds(getBounds) {
			this.$set({ getBounds });
			internal_63$2();
		}
	}

	/* src/Svelte.svelte generated by Svelte v3.0.0-beta.21 */

	function create_fragment$i(ctx) {
		var div, t0, p, em0, t1, t2, br, t3, em1, t4, t5_value = outputBox(ctx.selectionBox), t5, current;

		let editorview_props = {
			editor: ctx.editor,
			paper: ctx.paper,
			modules: ctx.modules,
			class: "typewriter-editor"
		};
		var editorview = new EditorView({ props: editorview_props });

		internal_62(() => ctx.editorview_binding(editorview));

		return {
			c() {
				div = internal_13("div");
				editorview.$$.fragment.c();
				t0 = internal_16();
				p = internal_13("p");
				em0 = internal_13("em");
				t1 = internal_15("Selection: ");
				t2 = internal_15(ctx.selection);
				br = internal_13("br");
				t3 = internal_16();
				em1 = internal_13("em");
				t4 = internal_15("Box: ");
				t5 = internal_15(t5_value);
				div.className = "container svelte-h0ttrk";
			},

			m(target, anchor) {
				internal_7(target, div, anchor);
				internal_99(editorview, div, null);
				internal_6(div, t0);
				internal_6(div, p);
				internal_6(p, em0);
				internal_6(em0, t1);
				internal_6(em0, t2);
				internal_6(p, br);
				internal_6(p, t3);
				internal_6(p, em1);
				internal_6(em1, t4);
				internal_6(em1, t5);
				current = true;
			},

			p(changed, ctx) {
				var editorview_changes = {};
				if (changed.editor) editorview_changes.editor = ctx.editor;
				if (changed.paper) editorview_changes.paper = ctx.paper;
				if (changed.modules) editorview_changes.modules = ctx.modules;
				editorview.$set(editorview_changes);

				if (!current || changed.selection) {
					internal_31(t2, ctx.selection);
				}

				if ((!current || changed.selectionBox) && t5_value !== (t5_value = outputBox(ctx.selectionBox))) {
					internal_31(t5, t5_value);
				}
			},

			i(local) {
				if (current) return;
				editorview.$$.fragment.i(local);

				current = true;
			},

			o(local) {
				editorview.$$.fragment.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8(div);
				}

				ctx.editorview_binding(null);

				editorview.$destroy();
			}
		};
	}

	function outputBox(box) {
	if (!box) return null;
	return `left: ${box.left}, top: ${box.top}, width: ${box.width}, height: ${box.height}`;
	}

	function instance$g($$self, $$props, $$invalidate) {
		

	let { editor, paper, modules } = $$props;

	let view;
	let selection = editor.selection;
	let selectionBox = null;

	editor.on('selection-change', () => { const $$result = selection = editor.selection; $$invalidate('selection', selection); return $$result; });

	async function updateBox(selection) {
	  await svelte_7$1();
	  selectionBox = selection ? view.getBounds() : null; $$invalidate('selectionBox', selectionBox);
	}

		function editorview_binding($$component) {
			view = $$component;
			$$invalidate('view', view);
		}

		$$self.$set = $$props => {
			if ('editor' in $$props) $$invalidate('editor', editor = $$props.editor);
			if ('paper' in $$props) $$invalidate('paper', paper = $$props.paper);
			if ('modules' in $$props) $$invalidate('modules', modules = $$props.modules);
		};

		$$self.$$.update = ($$dirty = { selection: 1 }) => {
			if ($$dirty.selection) {
				updateBox(selection);
			}
		};

		return {
			editor,
			paper,
			modules,
			view,
			selection,
			selectionBox,
			editorview_binding
		};
	}

	class Svelte extends internal_101 {
		constructor(options) {
			super();
			internal_100(this, options, instance$g, create_fragment$i, internal_90, ["editor", "paper", "modules"]);
		}

		get editor() {
			return this.$$.ctx.editor;
		}

		set editor(editor) {
			this.$set({ editor });
			internal_63();
		}

		get paper() {
			return this.$$.ctx.paper;
		}

		set paper(paper) {
			this.$set({ paper });
			internal_63();
		}

		get modules() {
			return this.$$.ctx.modules;
		}

		set modules(modules) {
			this.$set({ modules });
			internal_63();
		}
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics$5 = function(d, b) {
	    extendStatics$5 = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return extendStatics$5(d, b);
	};

	function __extends$5(d, b) {
	    extendStatics$5(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign$5 = function() {
	    __assign$5 = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$5.apply(this, arguments);
	};

	var dispatcherEvents$5 = new WeakMap();
	var EventDispatcher$5 = /** @class */ (function () {
	    function EventDispatcher() {
	    }
	    EventDispatcher.prototype.on = function (type, listener) {
	        getEventListeners$5(this, type, true).add(listener);
	    };
	    EventDispatcher.prototype.off = function (type, listener) {
	        var events = getEventListeners$5(this, type);
	        events && events["delete"](listener);
	    };
	    EventDispatcher.prototype.once = function (type, listener) {
	        function once() {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            this.off(type, once);
	            listener.apply(this, args);
	        }
	        this.on(type, once);
	    };
	    EventDispatcher.prototype.fire = function (type) {
	        var _this = this;
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        var uncanceled = true;
	        var events = getEventListeners$5(this, type);
	        if (events)
	            events.forEach(function (listener) {
	                uncanceled && listener.apply(_this, args) !== false || (uncanceled = false);
	            });
	        return uncanceled;
	    };
	    return EventDispatcher;
	}());
	function getEventListeners$5(obj, type, autocreate) {
	    if (autocreate === void 0) { autocreate = false; }
	    var events = dispatcherEvents$5.get(obj);
	    if (!events && autocreate)
	        dispatcherEvents$5.set(obj, events = Object.create(null));
	    return events && events[type] || autocreate && (events[type] = new Set());
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics$1$3 = function(d, b) {
	    extendStatics$1$3 = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return extendStatics$1$3(d, b);
	};

	function __extends$1$3(d, b) {
	    extendStatics$1$3(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign$1$3 = function() {
	    __assign$1$3 = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1$3.apply(this, arguments);
	};

	/**
	 * This library modifies the diff-patch-match library by Neil Fraser
	 * by removing the patch and match functionality and certain advanced
	 * options in the diff function. The original license is as follows:
	 *
	 * ===
	 *
	 * Diff Match and Patch
	 *
	 * Copyright 2006 Google Inc.
	 * http://code.google.com/p/google-diff-match-patch/
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * The data structure representing a diff is an array of tuples:
	 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
	 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
	 */
	var DIFF_DELETE$5 = -1;
	var DIFF_INSERT$5 = 1;
	var DIFF_EQUAL$5 = 0;
	/**
	 * Find the differences between two texts.  Simplifies the problem by stripping
	 * any common prefix or suffix off the texts before diffing.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {Int} cursor_pos Expected edit position in text1 (optional)
	 * @return {Array} Array of diff tuples.
	 */
	function diff$5(text1, text2, cursor_pos) {
	    // Check for equality (speedup).
	    if (text1 == text2) {
	        if (text1) {
	            return [[DIFF_EQUAL$5, text1]];
	        }
	        return [];
	    }
	    // Check cursor_pos within bounds
	    if (cursor_pos < 0 || text1.length < cursor_pos) {
	        cursor_pos = null;
	    }
	    // Trim off common prefix (speedup).
	    var commonlength = diff_commonPrefix$5(text1, text2);
	    var commonprefix = text1.substring(0, commonlength);
	    text1 = text1.substring(commonlength);
	    text2 = text2.substring(commonlength);
	    // Trim off common suffix (speedup).
	    commonlength = diff_commonSuffix$5(text1, text2);
	    var commonsuffix = text1.substring(text1.length - commonlength);
	    text1 = text1.substring(0, text1.length - commonlength);
	    text2 = text2.substring(0, text2.length - commonlength);
	    // Compute the diff on the middle block.
	    var diffs = diff_compute_$5(text1, text2);
	    // Restore the prefix and suffix.
	    if (commonprefix) {
	        diffs.unshift([DIFF_EQUAL$5, commonprefix]);
	    }
	    if (commonsuffix) {
	        diffs.push([DIFF_EQUAL$5, commonsuffix]);
	    }
	    diff_cleanupMerge$5(diffs);
	    if (cursor_pos != null) {
	        diffs = fix_cursor$5(diffs, cursor_pos);
	    }
	    diffs = fix_emoji$5(diffs);
	    return diffs;
	}
	/**
	 * Find the differences between two texts.  Assumes that the texts do not
	 * have any common prefix or suffix.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @return {Array} Array of diff tuples.
	 */
	function diff_compute_$5(text1, text2) {
	    var diffs;
	    if (!text1) {
	        // Just add some text (speedup).
	        return [[DIFF_INSERT$5, text2]];
	    }
	    if (!text2) {
	        // Just delete some text (speedup).
	        return [[DIFF_DELETE$5, text1]];
	    }
	    var longtext = text1.length > text2.length ? text1 : text2;
	    var shorttext = text1.length > text2.length ? text2 : text1;
	    var i = longtext.indexOf(shorttext);
	    if (i != -1) {
	        // Shorter text is inside the longer text (speedup).
	        diffs = [[DIFF_INSERT$5, longtext.substring(0, i)],
	            [DIFF_EQUAL$5, shorttext],
	            [DIFF_INSERT$5, longtext.substring(i + shorttext.length)]];
	        // Swap insertions for deletions if diff is reversed.
	        if (text1.length > text2.length) {
	            diffs[0][0] = diffs[2][0] = DIFF_DELETE$5;
	        }
	        return diffs;
	    }
	    if (shorttext.length == 1) {
	        // Single character string.
	        // After the previous speedup, the character can't be an equality.
	        return [[DIFF_DELETE$5, text1], [DIFF_INSERT$5, text2]];
	    }
	    // Check to see if the problem can be split in two.
	    var hm = diff_halfMatch_$5(text1, text2);
	    if (hm) {
	        // A half-match was found, sort out the return data.
	        var text1_a = hm[0];
	        var text1_b = hm[1];
	        var text2_a = hm[2];
	        var text2_b = hm[3];
	        var mid_common = hm[4];
	        // Send both pairs off for separate processing.
	        var diffs_a = diff$5(text1_a, text2_a);
	        var diffs_b = diff$5(text1_b, text2_b);
	        // Merge the results.
	        return diffs_a.concat([[DIFF_EQUAL$5, mid_common]], diffs_b);
	    }
	    return diff_bisect_$5(text1, text2);
	}
	/**
	 * Find the 'middle snake' of a diff, split the problem in two
	 * and return the recursively constructed diff.
	 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @return {Array} Array of diff tuples.
	 * @private
	 */
	function diff_bisect_$5(text1, text2) {
	    // Cache the text lengths to prevent multiple calls.
	    var text1_length = text1.length;
	    var text2_length = text2.length;
	    var max_d = Math.ceil((text1_length + text2_length) / 2);
	    var v_offset = max_d;
	    var v_length = 2 * max_d;
	    var v1 = new Array(v_length);
	    var v2 = new Array(v_length);
	    // Setting all elements to -1 is faster in Chrome & Firefox than mixing
	    // integers and undefined.
	    for (var x = 0; x < v_length; x++) {
	        v1[x] = -1;
	        v2[x] = -1;
	    }
	    v1[v_offset + 1] = 0;
	    v2[v_offset + 1] = 0;
	    var delta = text1_length - text2_length;
	    // If the total number of characters is odd, then the front path will collide
	    // with the reverse path.
	    var front = (delta % 2 != 0);
	    // Offsets for start and end of k loop.
	    // Prevents mapping of space beyond the grid.
	    var k1start = 0;
	    var k1end = 0;
	    var k2start = 0;
	    var k2end = 0;
	    for (var d = 0; d < max_d; d++) {
	        // Walk the front path one step.
	        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
	            var k1_offset = v_offset + k1;
	            var x1;
	            if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
	                x1 = v1[k1_offset + 1];
	            }
	            else {
	                x1 = v1[k1_offset - 1] + 1;
	            }
	            var y1 = x1 - k1;
	            while (x1 < text1_length && y1 < text2_length &&
	                text1.charAt(x1) == text2.charAt(y1)) {
	                x1++;
	                y1++;
	            }
	            v1[k1_offset] = x1;
	            if (x1 > text1_length) {
	                // Ran off the right of the graph.
	                k1end += 2;
	            }
	            else if (y1 > text2_length) {
	                // Ran off the bottom of the graph.
	                k1start += 2;
	            }
	            else if (front) {
	                var k2_offset = v_offset + delta - k1;
	                if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
	                    // Mirror x2 onto top-left coordinate system.
	                    var x2 = text1_length - v2[k2_offset];
	                    if (x1 >= x2) {
	                        // Overlap detected.
	                        return diff_bisectSplit_$5(text1, text2, x1, y1);
	                    }
	                }
	            }
	        }
	        // Walk the reverse path one step.
	        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
	            var k2_offset = v_offset + k2;
	            var x2;
	            if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
	                x2 = v2[k2_offset + 1];
	            }
	            else {
	                x2 = v2[k2_offset - 1] + 1;
	            }
	            var y2 = x2 - k2;
	            while (x2 < text1_length && y2 < text2_length &&
	                text1.charAt(text1_length - x2 - 1) ==
	                    text2.charAt(text2_length - y2 - 1)) {
	                x2++;
	                y2++;
	            }
	            v2[k2_offset] = x2;
	            if (x2 > text1_length) {
	                // Ran off the left of the graph.
	                k2end += 2;
	            }
	            else if (y2 > text2_length) {
	                // Ran off the top of the graph.
	                k2start += 2;
	            }
	            else if (!front) {
	                var k1_offset = v_offset + delta - k2;
	                if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
	                    var x1 = v1[k1_offset];
	                    var y1 = v_offset + x1 - k1_offset;
	                    // Mirror x2 onto top-left coordinate system.
	                    x2 = text1_length - x2;
	                    if (x1 >= x2) {
	                        // Overlap detected.
	                        return diff_bisectSplit_$5(text1, text2, x1, y1);
	                    }
	                }
	            }
	        }
	    }
	    // Diff took too long and hit the deadline or
	    // number of diffs equals number of characters, no commonality at all.
	    return [[DIFF_DELETE$5, text1], [DIFF_INSERT$5, text2]];
	}
	/**
	 * Given the location of the 'middle snake', split the diff in two parts
	 * and recurse.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} x Index of split point in text1.
	 * @param {number} y Index of split point in text2.
	 * @return {Array} Array of diff tuples.
	 */
	function diff_bisectSplit_$5(text1, text2, x, y) {
	    var text1a = text1.substring(0, x);
	    var text2a = text2.substring(0, y);
	    var text1b = text1.substring(x);
	    var text2b = text2.substring(y);
	    // Compute both diffs serially.
	    var diffs = diff$5(text1a, text2a);
	    var diffsb = diff$5(text1b, text2b);
	    return diffs.concat(diffsb);
	}
	/**
	 * Determine the common prefix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the start of each
	 *     string.
	 */
	function diff_commonPrefix$5(text1, text2) {
	    // Quick check for common null cases.
	    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
	        return 0;
	    }
	    // Binary search.
	    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	    var pointermin = 0;
	    var pointermax = Math.min(text1.length, text2.length);
	    var pointermid = pointermax;
	    var pointerstart = 0;
	    while (pointermin < pointermid) {
	        if (text1.substring(pointerstart, pointermid) ==
	            text2.substring(pointerstart, pointermid)) {
	            pointermin = pointermid;
	            pointerstart = pointermin;
	        }
	        else {
	            pointermax = pointermid;
	        }
	        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }
	    return pointermid;
	}
	/**
	 * Determine the common suffix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the end of each string.
	 */
	function diff_commonSuffix$5(text1, text2) {
	    // Quick check for common null cases.
	    if (!text1 || !text2 ||
	        text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
	        return 0;
	    }
	    // Binary search.
	    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	    var pointermin = 0;
	    var pointermax = Math.min(text1.length, text2.length);
	    var pointermid = pointermax;
	    var pointerend = 0;
	    while (pointermin < pointermid) {
	        if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
	            text2.substring(text2.length - pointermid, text2.length - pointerend)) {
	            pointermin = pointermid;
	            pointerend = pointermin;
	        }
	        else {
	            pointermax = pointermid;
	        }
	        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }
	    return pointermid;
	}
	/**
	 * Do the two texts share a substring which is at least half the length of the
	 * longer text?
	 * This speedup can produce non-minimal diffs.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {Array.<string>} Five element Array, containing the prefix of
	 *     text1, the suffix of text1, the prefix of text2, the suffix of
	 *     text2 and the common middle.  Or null if there was no match.
	 */
	function diff_halfMatch_$5(text1, text2) {
	    var longtext = text1.length > text2.length ? text1 : text2;
	    var shorttext = text1.length > text2.length ? text2 : text1;
	    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
	        return null; // Pointless.
	    }
	    /**
	     * Does a substring of shorttext exist within longtext such that the substring
	     * is at least half the length of longtext?
	     * Closure, but does not reference any external variables.
	     * @param {string} longtext Longer string.
	     * @param {string} shorttext Shorter string.
	     * @param {number} i Start index of quarter length substring within longtext.
	     * @return {Array.<string>} Five element Array, containing the prefix of
	     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
	     *     of shorttext and the common middle.  Or null if there was no match.
	     * @private
	     */
	    function diff_halfMatchI_(longtext, shorttext, i) {
	        // Start with a 1/4 length substring at position i as a seed.
	        var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
	        var j = -1;
	        var best_common = '';
	        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
	        while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
	            var prefixLength = diff_commonPrefix$5(longtext.substring(i), shorttext.substring(j));
	            var suffixLength = diff_commonSuffix$5(longtext.substring(0, i), shorttext.substring(0, j));
	            if (best_common.length < suffixLength + prefixLength) {
	                best_common = shorttext.substring(j - suffixLength, j) +
	                    shorttext.substring(j, j + prefixLength);
	                best_longtext_a = longtext.substring(0, i - suffixLength);
	                best_longtext_b = longtext.substring(i + prefixLength);
	                best_shorttext_a = shorttext.substring(0, j - suffixLength);
	                best_shorttext_b = shorttext.substring(j + prefixLength);
	            }
	        }
	        if (best_common.length * 2 >= longtext.length) {
	            return [best_longtext_a, best_longtext_b,
	                best_shorttext_a, best_shorttext_b, best_common];
	        }
	        else {
	            return null;
	        }
	    }
	    // First check if the second quarter is the seed for a half-match.
	    var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
	    // Check again based on the third quarter.
	    var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
	    var hm;
	    if (!hm1 && !hm2) {
	        return null;
	    }
	    else if (!hm2) {
	        hm = hm1;
	    }
	    else if (!hm1) {
	        hm = hm2;
	    }
	    else {
	        // Both matched.  Select the longest.
	        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
	    }
	    // A half-match was found, sort out the return data.
	    var text1_a, text1_b, text2_a, text2_b;
	    if (text1.length > text2.length) {
	        text1_a = hm[0];
	        text1_b = hm[1];
	        text2_a = hm[2];
	        text2_b = hm[3];
	    }
	    else {
	        text2_a = hm[0];
	        text2_b = hm[1];
	        text1_a = hm[2];
	        text1_b = hm[3];
	    }
	    var mid_common = hm[4];
	    return [text1_a, text1_b, text2_a, text2_b, mid_common];
	}
	/**
	 * Reorder and merge like edit sections.  Merge equalities.
	 * Any edit section can move as long as it doesn't cross an equality.
	 * @param {Array} diffs Array of diff tuples.
	 */
	function diff_cleanupMerge$5(diffs) {
	    diffs.push([DIFF_EQUAL$5, '']); // Add a dummy entry at the end.
	    var pointer = 0;
	    var count_delete = 0;
	    var count_insert = 0;
	    var text_delete = '';
	    var text_insert = '';
	    var commonlength;
	    while (pointer < diffs.length) {
	        switch (diffs[pointer][0]) {
	            case DIFF_INSERT$5:
	                count_insert++;
	                text_insert += diffs[pointer][1];
	                pointer++;
	                break;
	            case DIFF_DELETE$5:
	                count_delete++;
	                text_delete += diffs[pointer][1];
	                pointer++;
	                break;
	            case DIFF_EQUAL$5:
	                // Upon reaching an equality, check for prior redundancies.
	                if (count_delete + count_insert > 1) {
	                    if (count_delete !== 0 && count_insert !== 0) {
	                        // Factor out any common prefixies.
	                        commonlength = diff_commonPrefix$5(text_insert, text_delete);
	                        if (commonlength !== 0) {
	                            if ((pointer - count_delete - count_insert) > 0 &&
	                                diffs[pointer - count_delete - count_insert - 1][0] ==
	                                    DIFF_EQUAL$5) {
	                                diffs[pointer - count_delete - count_insert - 1][1] +=
	                                    text_insert.substring(0, commonlength);
	                            }
	                            else {
	                                diffs.splice(0, 0, [DIFF_EQUAL$5,
	                                    text_insert.substring(0, commonlength)]);
	                                pointer++;
	                            }
	                            text_insert = text_insert.substring(commonlength);
	                            text_delete = text_delete.substring(commonlength);
	                        }
	                        // Factor out any common suffixies.
	                        commonlength = diff_commonSuffix$5(text_insert, text_delete);
	                        if (commonlength !== 0) {
	                            diffs[pointer][1] = text_insert.substring(text_insert.length -
	                                commonlength) + diffs[pointer][1];
	                            text_insert = text_insert.substring(0, text_insert.length -
	                                commonlength);
	                            text_delete = text_delete.substring(0, text_delete.length -
	                                commonlength);
	                        }
	                    }
	                    // Delete the offending records and add the merged ones.
	                    if (count_delete === 0) {
	                        diffs.splice(pointer - count_insert, count_delete + count_insert, [DIFF_INSERT$5, text_insert]);
	                    }
	                    else if (count_insert === 0) {
	                        diffs.splice(pointer - count_delete, count_delete + count_insert, [DIFF_DELETE$5, text_delete]);
	                    }
	                    else {
	                        diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [DIFF_DELETE$5, text_delete], [DIFF_INSERT$5, text_insert]);
	                    }
	                    pointer = pointer - count_delete - count_insert +
	                        (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
	                }
	                else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL$5) {
	                    // Merge this equality with the previous one.
	                    diffs[pointer - 1][1] += diffs[pointer][1];
	                    diffs.splice(pointer, 1);
	                }
	                else {
	                    pointer++;
	                }
	                count_insert = 0;
	                count_delete = 0;
	                text_delete = '';
	                text_insert = '';
	                break;
	        }
	    }
	    if (diffs[diffs.length - 1][1] === '') {
	        diffs.pop(); // Remove the dummy entry at the end.
	    }
	    // Second pass: look for single edits surrounded on both sides by equalities
	    // which can be shifted sideways to eliminate an equality.
	    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
	    var changes = false;
	    pointer = 1;
	    // Intentionally ignore the first and last element (don't need checking).
	    while (pointer < diffs.length - 1) {
	        if (diffs[pointer - 1][0] == DIFF_EQUAL$5 &&
	            diffs[pointer + 1][0] == DIFF_EQUAL$5) {
	            // This is a single edit surrounded by equalities.
	            if (diffs[pointer][1].substring(diffs[pointer][1].length -
	                diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
	                // Shift the edit over the previous equality.
	                diffs[pointer][1] = diffs[pointer - 1][1] +
	                    diffs[pointer][1].substring(0, diffs[pointer][1].length -
	                        diffs[pointer - 1][1].length);
	                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
	                diffs.splice(pointer - 1, 1);
	                changes = true;
	            }
	            else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
	                diffs[pointer + 1][1]) {
	                // Shift the edit over the next equality.
	                diffs[pointer - 1][1] += diffs[pointer + 1][1];
	                diffs[pointer][1] =
	                    diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
	                        diffs[pointer + 1][1];
	                diffs.splice(pointer + 1, 1);
	                changes = true;
	            }
	        }
	        pointer++;
	    }
	    // If shifts were made, the diff needs reordering and another shift sweep.
	    if (changes) {
	        diff_cleanupMerge$5(diffs);
	    }
	}
	diff$5.INSERT = DIFF_INSERT$5;
	diff$5.DELETE = DIFF_DELETE$5;
	diff$5.EQUAL = DIFF_EQUAL$5;
	/*
	 * Modify a diff such that the cursor position points to the start of a change:
	 * E.g.
	 *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)
	 *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]
	 *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)
	 *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
	 * @return {Array} A tuple [cursor location in the modified diff, modified diff]
	 */
	function cursor_normalize_diff$5(diffs, cursor_pos) {
	    if (cursor_pos === 0) {
	        return [DIFF_EQUAL$5, diffs];
	    }
	    for (var current_pos = 0, i = 0; i < diffs.length; i++) {
	        var d = diffs[i];
	        if (d[0] === DIFF_DELETE$5 || d[0] === DIFF_EQUAL$5) {
	            var next_pos = current_pos + d[1].length;
	            if (cursor_pos === next_pos) {
	                return [i + 1, diffs];
	            }
	            else if (cursor_pos < next_pos) {
	                // copy to prevent side effects
	                diffs = diffs.slice();
	                // split d into two diff changes
	                var split_pos = cursor_pos - current_pos;
	                var d_left = [d[0], d[1].slice(0, split_pos)];
	                var d_right = [d[0], d[1].slice(split_pos)];
	                diffs.splice(i, 1, d_left, d_right);
	                return [i + 1, diffs];
	            }
	            else {
	                current_pos = next_pos;
	            }
	        }
	    }
	    throw new Error('cursor_pos is out of bounds!');
	}
	/*
	 * Modify a diff such that the edit position is "shifted" to the proposed edit location (cursor_position).
	 *
	 * Case 1)
	 *   Check if a naive shift is possible:
	 *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)
	 *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result
	 * Case 2)
	 *   Check if the following shifts are possible:
	 *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']
	 *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']
	 *         ^            ^
	 *         d          d_next
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
	 * @return {Array} Array of diff tuples
	 */
	function fix_cursor$5(diffs, cursor_pos) {
	    var norm = cursor_normalize_diff$5(diffs, cursor_pos);
	    var ndiffs = norm[1];
	    var cursor_pointer = norm[0];
	    var d = ndiffs[cursor_pointer];
	    var d_next = ndiffs[cursor_pointer + 1];
	    if (d == null) {
	        // Text was deleted from end of original string,
	        // cursor is now out of bounds in new string
	        return diffs;
	    }
	    else if (d[0] !== DIFF_EQUAL$5) {
	        // A modification happened at the cursor location.
	        // This is the expected outcome, so we can return the original diff.
	        return diffs;
	    }
	    else {
	        if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
	            // Case 1)
	            // It is possible to perform a naive shift
	            ndiffs.splice(cursor_pointer, 2, d_next, d);
	            return merge_tuples$5(ndiffs, cursor_pointer, 2);
	        }
	        else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
	            // Case 2)
	            // d[1] is a prefix of d_next[1]
	            // We can assume that d_next[0] !== 0, since d[0] === 0
	            // Shift edit locations..
	            ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
	            var suffix = d_next[1].slice(d[1].length);
	            if (suffix.length > 0) {
	                ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
	            }
	            return merge_tuples$5(ndiffs, cursor_pointer, 3);
	        }
	        else {
	            // Not possible to perform any modification
	            return diffs;
	        }
	    }
	}
	/*
	 * Check diff did not split surrogate pairs.
	 * Ex. [0, '\uD83D'], [-1, '\uDC36'], [1, '\uDC2F'] -> [-1, '\uD83D\uDC36'], [1, '\uD83D\uDC2F']
	 *     '\uD83D\uDC36' === '🐶', '\uD83D\uDC2F' === '🐯'
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @return {Array} Array of diff tuples
	 */
	function fix_emoji$5(diffs) {
	    var compact = false;
	    var starts_with_pair_end = function (str) {
	        return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;
	    };
	    var ends_with_pair_start = function (str) {
	        return str.charCodeAt(str.length - 1) >= 0xD800 && str.charCodeAt(str.length - 1) <= 0xDBFF;
	    };
	    for (var i = 2; i < diffs.length; i += 1) {
	        if (diffs[i - 2][0] === DIFF_EQUAL$5 && ends_with_pair_start(diffs[i - 2][1]) &&
	            diffs[i - 1][0] === DIFF_DELETE$5 && starts_with_pair_end(diffs[i - 1][1]) &&
	            diffs[i][0] === DIFF_INSERT$5 && starts_with_pair_end(diffs[i][1])) {
	            compact = true;
	            diffs[i - 1][1] = diffs[i - 2][1].slice(-1) + diffs[i - 1][1];
	            diffs[i][1] = diffs[i - 2][1].slice(-1) + diffs[i][1];
	            diffs[i - 2][1] = diffs[i - 2][1].slice(0, -1);
	        }
	    }
	    if (!compact) {
	        return diffs;
	    }
	    var fixed_diffs = [];
	    for (var i = 0; i < diffs.length; i += 1) {
	        if (diffs[i][1].length > 0) {
	            fixed_diffs.push(diffs[i]);
	        }
	    }
	    return fixed_diffs;
	}
	/*
	 * Try to merge tuples with their neigbors in a given range.
	 * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']
	 *
	 * @param {Array} diffs Array of diff tuples.
	 * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).
	 * @param {Int} length Number of consecutive elements to check.
	 * @return {Array} Array of merged diff tuples.
	 */
	function merge_tuples$5(diffs, start, length) {
	    // Check from (start-1) to (start+length).
	    for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {
	        if (i + 1 < diffs.length) {
	            var left_d = diffs[i];
	            var right_d = diffs[i + 1];
	            if (left_d[0] === right_d[1]) {
	                diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
	            }
	        }
	    }
	    return diffs;
	}

	function shallowEqual$5(valueA, valueB) {
	    return valueEqual$5(valueA, valueB, strictEqual$5);
	}
	function deepEqual$5(valueA, valueB) {
	    return valueEqual$5(valueA, valueB, valueEqual$5);
	}
	function strictEqual$5(valueA, valueB) {
	    return valueA === valueB;
	}
	function valueEqual$5(valueA, valueB, propEqual) {
	    if (valueA === valueB)
	        return true;
	    if (valueA instanceof Date && valueB instanceof Date)
	        return valueA.getTime() === valueB.getTime();
	    if (!valueA || !valueB || typeof valueA !== 'object' && typeof valueB !== 'object')
	        return valueA === valueB;
	    return objectEqual$5(valueA, valueB, propEqual);
	}
	function objectEqual$5(objA, objB, propEqual) {
	    if (objA.prototype !== objB.prototype)
	        return false;
	    var keysA = Object.keys(objA);
	    var keysB = Object.keys(objB);
	    if (keysA.length !== keysB.length)
	        return false;
	    return keysA.every(function (key, i) { return key === keysB[i] && propEqual(objA[key], objB[key], propEqual); });
	}

	var NULL_CHARACTER$5 = String.fromCharCode(0); // Placeholder char for embed in diff()
	var Delta$5 = /** @class */ (function () {
	    function Delta(ops) {
	        if (ops === void 0) { ops = []; }
	        this.ops = ops;
	    }
	    /**
	     * Appends an insert operation. Returns this for chainability.
	     *
	     * @param {String|Object} text Represents text or embed to insert
	     * @param {Object} attributes Optional attributes to apply
	     */
	    Delta.prototype.insert = function (text, attributes) {
	        var newOp = {};
	        if (text.length === 0)
	            return this;
	        newOp.insert = text;
	        if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
	            newOp.attributes = attributes;
	        }
	        return this._push(newOp);
	    };
	    /**
	     * Appends a delete operation. Returns this for chainability.
	     *
	     * @param {Number} length Number of characters to delete
	     */
	    Delta.prototype["delete"] = function (length) {
	        if (length <= 0)
	            return this;
	        return this._push({ "delete": length });
	    };
	    /**
	     * Appends a retain operation. Returns this for chainability.
	     *
	     * @param {Number} length Number of characters to retain
	     * @param {Object} attributes Optional attributes to apply
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.retain = function (length, attributes) {
	        if (length <= 0)
	            return this;
	        var newOp = { retain: length };
	        if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
	            newOp.attributes = attributes;
	        }
	        return this._push(newOp);
	    };
	    /**
	     * Freezes delta from future modifications. Returns this for chainability.
	     *
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.freeze = function () {
	        var _this = this;
	        this._push = function () { return _this; };
	        return this;
	    };
	    /**
	     * Adds a new operation. Returns this for chainability.
	     *
	     * @param {Object} newOp A new operation
	     * @returns {Delta} This delta
	     */
	    Delta.prototype._push = function (newOp) {
	        var index = this.ops.length;
	        var lastOp = this.ops[index - 1];
	        if (typeof lastOp === 'object') {
	            if (typeof newOp["delete"] === 'number' && typeof lastOp["delete"] === 'number') {
	                this.ops[index - 1] = { "delete": lastOp["delete"] + newOp["delete"] };
	                return this;
	            }
	            // Since it does not matter if we insert before or after deleting at the same index,
	            // always prefer to insert first
	            if (typeof lastOp["delete"] === 'number' && newOp.insert != null) {
	                index -= 1;
	                lastOp = this.ops[index - 1];
	                if (typeof lastOp !== 'object') {
	                    this.ops.unshift(newOp);
	                    return this;
	                }
	            }
	            if (deepEqual$5(newOp.attributes, lastOp.attributes)) {
	                if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {
	                    this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };
	                    if (typeof newOp.attributes === 'object')
	                        this.ops[index - 1].attributes = newOp.attributes;
	                    return this;
	                }
	                else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {
	                    this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };
	                    if (typeof newOp.attributes === 'object')
	                        this.ops[index - 1].attributes = newOp.attributes;
	                    return this;
	                }
	            }
	        }
	        if (index === this.ops.length) {
	            this.ops.push(newOp);
	        }
	        else {
	            this.ops.splice(index, 0, newOp);
	        }
	        return this;
	    };
	    /**
	     * Chops off trailing retain instructions to make the delta concise.
	     *
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.chop = function () {
	        var lastOp = this.ops[this.ops.length - 1];
	        if (lastOp && lastOp.retain && !lastOp.attributes) {
	            this.ops.pop();
	        }
	        return this;
	    };
	    /**
	     * Returns an iterator to iterate over the operations of this delta.
	     *
	     * @returns {Iterator} An operation iterator with methods hasNext, next, peek, peekLength, & peekType
	     */
	    Delta.prototype.iterator = function () {
	        return new Iterator$5(this.ops);
	    };
	    /**
	     * Returns an array of operations that passes a given function.
	     *
	     * @param {Function} predicate Function to test each operation against. Return true to keep the operation, false
	     *                             otherwise
	     * @returns {Array} Filtered resulting array
	     */
	    Delta.prototype.filter = function (predicate) {
	        return this.ops.filter(predicate);
	    };
	    /**
	     * Iterates through operations, calling the provided function for each operation.
	     *
	     * @param {Function} predicate Function to call during iteration, passing in the current operation
	     */
	    Delta.prototype.forEach = function (predicate) {
	        this.ops.forEach(predicate);
	    };
	    /**
	     * Returns a new array with the results of calling provided function on each operation.
	     *
	     * @param {Function} predicate Function to call, passing in the current operation, returning an element of the new
	     *                             array to be returned
	     * @returns {Array} A new array with each element being the result of the given function
	     */
	    Delta.prototype.map = function (predicate) {
	        return this.ops.map(predicate);
	    };
	    /**
	     * Create an array of two arrays, the first with operations that pass the given function, the other that failed.
	     *
	     * @param {Function} predicate Function to call, passing in the current operation, returning whether that operation
	     *                             passed
	     * @returns {Array} A new array of two Arrays, the first with passed operations, the other with failed operations
	     */
	    Delta.prototype.partition = function (predicate) {
	        var passed = [], failed = [];
	        this.forEach(function (op) {
	            var target = predicate(op) ? passed : failed;
	            target.push(op);
	        });
	        return [passed, failed];
	    };
	    /**
	     * Applies given function against an accumulator and each operation to reduce to a single value.
	     *
	     * @param {Function} predicate Function to call per iteration, returning an accumulated value
	     * @param {*} initial Initial value to pass to first call to predicate
	     * @returns {*} The accumulated value
	     */
	    Delta.prototype.reduce = function (predicate, initial) {
	        return this.ops.reduce(predicate, initial);
	    };
	    Delta.prototype.changeLength = function () {
	        return this.reduce(function (length, entry) {
	            if (entry.insert) {
	                return length + getOpLength$5(entry);
	            }
	            else if (entry["delete"]) {
	                return length - entry["delete"];
	            }
	            return length;
	        }, 0);
	    };
	    /**
	     * Returns length of a Delta, which is the sum of the lengths of its operations.
	     *
	     * @returns {Number} The length of this delta
	     */
	    Delta.prototype.length = function () {
	        return this.reduce(function (length, entry) {
	            return length + getOpLength$5(entry);
	        }, 0);
	    };
	    /**
	     * Returns copy of delta with subset of operations.
	     *
	     * @param {Number} start Start index of subset, defaults to 0
	     * @param {Number} end End index of subset, defaults to rest of operations
	     * @returns {Array} An array slice of the operations
	     */
	    Delta.prototype.slice = function (start, end) {
	        if (start === void 0) { start = 0; }
	        if (typeof end !== 'number')
	            end = Infinity;
	        var ops = [];
	        var iter = this.iterator();
	        var index = 0;
	        while (index < end && iter.hasNext()) {
	            var nextOp;
	            if (index < start) {
	                nextOp = iter.next(start - index);
	            }
	            else {
	                nextOp = iter.next(end - index);
	                ops.push(nextOp);
	            }
	            index += getOpLength$5(nextOp);
	        }
	        return new Delta(ops);
	    };
	    /**
	     * Returns a Delta that is equivalent to applying the operations of own Delta, followed by another Delta.
	     *
	     * @param {Delta} other Delta to compose
	     */
	    Delta.prototype.compose = function (other) {
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        var delta = new Delta();
	        while (thisIter.hasNext() || otherIter.hasNext()) {
	            if (otherIter.peekType() === 'insert') {
	                delta._push(otherIter.next());
	            }
	            else if (thisIter.peekType() === 'delete') {
	                delta._push(thisIter.next());
	            }
	            else {
	                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
	                var thisOp = thisIter.next(length);
	                var otherOp = otherIter.next(length);
	                if (typeof otherOp.retain === 'number') {
	                    var newOp = {};
	                    if (typeof thisOp.retain === 'number') {
	                        newOp.retain = length;
	                    }
	                    else {
	                        newOp.insert = thisOp.insert;
	                    }
	                    // Preserve null when composing with a retain, otherwise remove it for inserts
	                    var attributes = composeAttributes$5(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');
	                    if (attributes)
	                        newOp.attributes = attributes;
	                    delta._push(newOp);
	                    // Optimization if rest of other is just retain
	                    if (!otherIter.hasNext() && deepEqual$5(delta.ops[delta.ops.length - 1], newOp)) {
	                        var rest = new Delta(thisIter.rest());
	                        return delta.concat(rest).chop();
	                    }
	                    // Other op should be delete, we could be an insert or retain
	                    // Insert + delete cancels out
	                }
	                else if (typeof otherOp["delete"] === 'number' && typeof thisOp.retain === 'number') {
	                    delta._push(otherOp);
	                }
	            }
	        }
	        return delta.chop();
	    };
	    /**
	     * Returns a new Delta representing the concatenation of this and another document Delta's operations.
	     *
	     * @param {Delta} other Document Delta to concatenate
	     * @returns {Delta} Concatenated document Delta
	     */
	    Delta.prototype.concat = function (other) {
	        var delta = new Delta(this.ops.slice());
	        if (other.ops.length > 0) {
	            delta._push(other.ops[0]);
	            delta.ops = delta.ops.concat(other.ops.slice(1));
	        }
	        return delta;
	    };
	    /**
	     * Returns a Delta representing the difference between two documents. Optionally, accepts a suggested index where
	     * change took place, often representing a cursor position before change.
	     *
	     * @param {Delta} other Document Delta to diff against
	     * @param {Number} index Suggested index where change took place
	     * @returns {Delta} Difference between the two documents
	     */
	    Delta.prototype.diff = function (other, index) {
	        if (this.ops === other.ops) {
	            return new Delta();
	        }
	        var strings = [this, other].map(function (delta) {
	            return delta.map(function (op) {
	                if (op.insert != null) {
	                    return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER$5;
	                }
	                var prep = (delta === other) ? 'on' : 'with';
	                throw new Error('diff() called ' + prep + ' non-document');
	            }).join('');
	        });
	        var delta = new Delta();
	        var diffResult = diff$5(strings[0], strings[1], index);
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        diffResult.forEach(function (component) {
	            var length = component[1].length;
	            while (length > 0) {
	                var opLength = 0;
	                switch (component[0]) {
	                    case diff$5.INSERT:
	                        opLength = Math.min(otherIter.peekLength(), length);
	                        delta._push(otherIter.next(opLength));
	                        break;
	                    case diff$5.DELETE:
	                        opLength = Math.min(length, thisIter.peekLength());
	                        thisIter.next(opLength);
	                        delta["delete"](opLength);
	                        break;
	                    case diff$5.EQUAL:
	                        opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
	                        var thisOp = thisIter.next(opLength);
	                        var otherOp = otherIter.next(opLength);
	                        if (deepEqual$5(thisOp.insert, otherOp.insert)) {
	                            delta.retain(opLength, diffAttributes$5(thisOp.attributes, otherOp.attributes));
	                        }
	                        else {
	                            delta._push(otherOp)["delete"](opLength);
	                        }
	                        break;
	                }
	                length -= opLength;
	            }
	        });
	        return delta.chop();
	    };
	    /**
	     * Iterates through document Delta, calling a given function with a Delta and attributes object, representing the line
	     * segment.
	     *
	     * @param {Function} predicate Function to call on each line group
	     * @param {String} newline Newline character, defaults to \n
	     */
	    Delta.prototype.eachLine = function (predicate, newline) {
	        if (newline === void 0) { newline = '\n'; }
	        var iter = this.iterator();
	        var ops = new Delta();
	        var index = 0;
	        var lineStart = 0;
	        var currentIndex = 0;
	        while (iter.hasNext()) {
	            if (iter.peekType() !== 'insert')
	                return;
	            var op = iter.peek();
	            var nextLength = iter.peekLength();
	            var start = getOpLength$5(op) - nextLength;
	            var newlineIndex = typeof op.insert === 'string' ? op.insert.indexOf(newline, start) - start : -1;
	            if (newlineIndex < 0) {
	                currentIndex += nextLength;
	                ops._push(iter.next());
	            }
	            else if (newlineIndex > 0) {
	                currentIndex += newlineIndex;
	                ops._push(iter.next(newlineIndex));
	            }
	            else {
	                currentIndex += 1;
	                var attributes = iter.next(1).attributes || {};
	                var line = { ops: ops, attributes: attributes, start: lineStart, end: currentIndex, index: index };
	                if (predicate(line, index) === false) {
	                    return;
	                }
	                index += 1;
	                lineStart = currentIndex;
	                ops = new Delta();
	            }
	        }
	        if (ops.length() > 0) {
	            var line_1 = { ops: ops, attributes: {}, start: lineStart, end: currentIndex, index: index };
	            predicate(line_1, index);
	        }
	    };
	    // Extends Delta, get the lines from `from` to `to`.
	    Delta.prototype.getLines = function (from, to, newline) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = Infinity; }
	        var lines = [];
	        this.eachLine(function (line) {
	            if (line.start > to || (line.start === to && from !== to))
	                return false;
	            if (line.end > from) {
	                lines.push(line);
	            }
	        }, newline);
	        return lines;
	    };
	    // Extends Delta, get the line at `at`.
	    Delta.prototype.getLine = function (at, newline) {
	        return this.getLines(at, at, newline)[0];
	    };
	    // Extends Delta, get the ops from `from` to `to`.
	    Delta.prototype.getOps = function (from, to) {
	        var start = 0;
	        var ops = [];
	        this.ops.some(function (op) {
	            if (start >= to)
	                return true;
	            var end = start + getOpLength$5(op);
	            if (end > from || (from === to && end === to)) {
	                ops.push({ op: op, start: start, end: end });
	            }
	            start = end;
	        });
	        return ops;
	    };
	    // Extends Delta, get the op at `at`.
	    Delta.prototype.getOp = function (at) {
	        return this.getOps(at, at)[0];
	    };
	    /**
	     * Transform given Delta against own operations. Used as an alias for transformPosition when called with a number.
	     *
	     * @param {Delta} other Delta to transform
	     * @param {Boolean} priority Boolean used to break ties. If true, then this takes priority over other, that is, its
	     *                           actions are considered to happen "first."
	     * @returns {Delta} Transformed Delta
	     */
	    Delta.prototype.transform = function (other, priority) {
	        if (priority === void 0) { priority = false; }
	        if (typeof other === 'number') {
	            return this.transformPosition(other, priority);
	        }
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        var delta = new Delta();
	        while (thisIter.hasNext() || otherIter.hasNext()) {
	            if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {
	                delta.retain(getOpLength$5(thisIter.next()));
	            }
	            else if (otherIter.peekType() === 'insert') {
	                delta._push(otherIter.next());
	            }
	            else {
	                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
	                var thisOp = thisIter.next(length);
	                var otherOp = otherIter.next(length);
	                if (thisOp["delete"]) {
	                    // Our delete either makes their delete redundant or removes their retain
	                    continue;
	                }
	                else if (otherOp["delete"]) {
	                    delta._push(otherOp);
	                }
	                else {
	                    // We retain either their retain or insert
	                    delta.retain(length, transformAttributes$5(thisOp.attributes, otherOp.attributes, priority));
	                }
	            }
	        }
	        return delta.chop();
	    };
	    /**
	     * Transform an index against the delta. Useful for representing cursor/selection positions.
	     *
	     * @param {Number} index Index to transform
	     * @param {Boolean} priority Boolean used to break ties. If true, then this takes priority over other, that is, its
	     *                           actions are considered to happen "first."
	     * @returns {Number} Transformed index
	     */
	    Delta.prototype.transformPosition = function (index, priority) {
	        if (priority === void 0) { priority = false; }
	        var thisIter = this.iterator();
	        var offset = 0;
	        while (thisIter.hasNext() && offset <= index) {
	            var length = thisIter.peekLength();
	            var nextType = thisIter.peekType();
	            thisIter.next();
	            if (nextType === 'delete') {
	                index -= Math.min(length, index - offset);
	                continue;
	            }
	            else if (nextType === 'insert' && (offset < index || !priority)) {
	                index += length;
	            }
	            offset += length;
	        }
	        return index;
	    };
	    return Delta;
	}());
	/**
	 * Create an attributes object that is equivalent to applying the attributes of the target followed by the source.
	 *
	 * @param {Object} target Target attributes object which will have the source applied to
	 * @param {Object} source Source attributes object being applied to the target
	 * @param {Boolean} keepNull Whether to keep null values from source
	 * @returns {Object} A new attributes object (or undefined if empty) with both
	 */
	function composeAttributes$5(target, source, keepNull) {
	    if (target === void 0) { target = {}; }
	    if (source === void 0) { source = {}; }
	    var attributes = __assign$1$3({}, target, source);
	    if (!keepNull)
	        Object.keys(attributes).forEach(function (key) {
	            if (attributes[key] == null)
	                delete attributes[key];
	        });
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Finds the difference between two attributes objects. Returns the source attributes that are different from the
	 * target attributes.
	 *
	 * @param {Object} target An attributes object
	 * @param {Object} source An attributes object
	 * @returns {Object} The difference between the two attribute objects or undefined if there is none
	 */
	function diffAttributes$5(target, source) {
	    if (target === void 0) { target = {}; }
	    if (source === void 0) { source = {}; }
	    var attributes = Object.keys(target).concat(Object.keys(source)).reduce(function (attributes, key) {
	        if (!deepEqual$5(target[key], source[key])) {
	            attributes[key] = source[key] === undefined ? null : source[key];
	        }
	        return attributes;
	    }, {});
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Transforms the attributes of source over target (or the other way around if priority is set). Will return an
	 * attributes object which has all the values from source if priority if false or will have the values from source that
	 * are set on target.
	 *
	 * @param {Object} target An attributes object
	 * @param {Object} source An attributes object
	 * @param {Boolean} priority If target has priority over source
	 */
	function transformAttributes$5(target, source, priority) {
	    if (typeof target !== 'object')
	        return source;
	    if (typeof source !== 'object')
	        return undefined;
	    if (!priority)
	        return source; // b simply overwrites us without priority
	    var attributes = Object.keys(source).reduce(function (attributes, key) {
	        if (target[key] === undefined)
	            attributes[key] = source[key]; // null is a valid value
	        return attributes;
	    }, {});
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Determines the length of a Delta operation.
	 *
	 * @param {Object} op An operation entry from a Delta object
	 * @returns {Number} The length of the op
	 */
	function getOpLength$5(op) {
	    if (typeof op["delete"] === 'number') {
	        return op["delete"];
	    }
	    else if (typeof op.retain === 'number') {
	        return op.retain;
	    }
	    else {
	        return typeof op.insert === 'string' ? op.insert.length : 1;
	    }
	}
	/**
	 * An iterator to handle iterating over a list of Delta operations efficiently.
	 */
	var Iterator$5 = /** @class */ (function () {
	    function Iterator(ops) {
	        this.ops = ops;
	        this.index = 0;
	        this.offset = 0;
	    }
	    /**
	     * Determine if there will be another operation returned by `next`.
	     *
	     * @returns {Boolean} Whether there are more operations to iterate over
	     */
	    Iterator.prototype.hasNext = function () {
	        return this.peekLength() < Infinity;
	    };
	    /**
	     * Get the next operation, optionally limited/sliced by length. If an operation is sliced by length, the next call to
	     * `next` will return more of that operation until it is returned in full.
	     *
	     * @param {Number} length Optionally limit the returned operation by length, slicing it down as needed
	     */
	    Iterator.prototype.next = function (length) {
	        if (length === void 0) { length = Infinity; }
	        var nextOp = this.ops[this.index];
	        if (!nextOp)
	            return { retain: Infinity };
	        var offset = this.offset;
	        var opLength = getOpLength$5(nextOp);
	        // Update index and offset
	        if (length >= opLength - offset) {
	            length = opLength - offset;
	            this.index += 1;
	            this.offset = 0;
	        }
	        else {
	            this.offset += length;
	        }
	        if (typeof nextOp["delete"] === 'number') {
	            return { "delete": length };
	        }
	        else {
	            var retOp = {};
	            if (nextOp.attributes) {
	                retOp.attributes = nextOp.attributes;
	            }
	            if (typeof nextOp.retain === 'number') {
	                retOp.retain = length;
	            }
	            else if (typeof nextOp.insert === 'string') {
	                retOp.insert = nextOp.insert.substr(offset, length);
	            }
	            else {
	                // offset should === 0, length should === 1
	                retOp.insert = nextOp.insert;
	            }
	            return retOp;
	        }
	    };
	    /**
	     * Return the next entry.
	     *
	     * @returns {Object} The next entry in the ops array.
	     */
	    Iterator.prototype.peek = function () {
	        return this.ops[this.index];
	    };
	    /**
	     * Check the length of the next entry.
	     *
	     * @returns {Number} The length of the next entry or Infinity if there is no next entry
	     */
	    Iterator.prototype.peekLength = function () {
	        if (this.ops[this.index]) {
	            // Should never return 0 if our index is being managed correctly
	            return getOpLength$5(this.ops[this.index]) - this.offset;
	        }
	        else {
	            return Infinity;
	        }
	    };
	    /**
	     * Check the type of the next entry, delete, retain, or insert.
	     *
	     * @returns {String} The type of the next entry
	     */
	    Iterator.prototype.peekType = function () {
	        if (this.ops[this.index]) {
	            if (typeof this.ops[this.index]["delete"] === 'number') {
	                return 'delete';
	            }
	            else if (typeof this.ops[this.index].retain === 'number') {
	                return 'retain';
	            }
	            else {
	                return 'insert';
	            }
	        }
	        return 'retain';
	    };
	    Iterator.prototype.rest = function () {
	        if (!this.hasNext()) {
	            return [];
	        }
	        else if (this.offset === 0) {
	            return this.ops.slice(this.index);
	        }
	        else {
	            var offset = this.offset;
	            var index = this.index;
	            var next = this.next();
	            var rest = this.ops.slice(this.index);
	            this.offset = offset;
	            this.index = index;
	            return [next].concat(rest);
	        }
	    };
	    return Iterator;
	}());

	var SOURCE_API$5 = 'api';
	var SOURCE_USER$8 = 'user';
	var SOURCE_SILENT$5 = 'silent';
	var empty$5 = {};
	/**
	 * Event for text changes, called before the change has occurred. If a listener returns false the change will be
	 * canceled and not committed.
	 *
	 * @event Editor#text-changing
	 * @type  {Object}
	 * @property {Delta} change       The change which is being applied to the content
	 * @property {Delta} content      The new content after the change
	 * @property {Delta} oldContent   The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * Event for text changes, called after the change has occurred.
	 *
	 * @event Editor#text-change
	 * @type  {Object}
	 * @property {Delta} change       The change which is being applied to the content
	 * @property {Delta} content      The new content after the change
	 * @property {Delta} oldContent   The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * Event for selection changes. If part of a text change the `change`, `content`, and `oldContent` properties will be
	 * set. Otherwise they will not be set.
	 *
	 * @event Editor#selection-change
	 * @type  {Object}
	 * @property {Delta} change       [ Optional ] The change which is being applied to the content
	 * @property {Delta} content      [ Optional ] The new content after the change
	 * @property {Delta} oldContent   [ Optional ] The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * A Typewriter Editor handles the logic for selection and editing of contents. It has no dependency on browser APIs
	 * and can be used in Node.js as easily as the browser. It has no logic to limit formatting (i.e. it does not disallow
	 * using bold, headers, links, or FOOBAR), that will need to be limited outside of the editor itself.
	 *
	 * @fires Editor#text-changing
	 * @fires Editor#text-change
	 * @fires Editor#selection-change
	 *
	 * @readonly @property {Delta}  contents      The data model for the text editor
	 * @readonly @property {Number} length        The length of the contents
	 * @readonly @property {String} text          The text of the contents
	 * @readonly @property {Array}  selection     The current editor selection, a tuple of `[ from, to ]` or `null`
	 * @readonly @property {Object} activeFormats The currently active formats (formats that will apply on the next insert)
	 */
	var Editor$5 = /** @class */ (function (_super) {
	    __extends$1$3(Editor, _super);
	    /**
	     * Create a new Typewriter editor.
	     *
	     * @param {Object} options Options for this editor include initial `contents` and `modules`:
	     * @param {Delta}  options.contents The initial contents of this editor
	     */
	    function Editor(options) {
	        if (options === void 0) { options = {}; }
	        var _this = _super.call(this) || this;
	        _this.contents = null;
	        _this.length = 0;
	        _this.selection = null;
	        _this.activeFormats = empty$5;
	        setContents$5(_this, options.contents || _this.delta().insert('\n'));
	        _this._queuedEvents = []; // Event queuing ensure they are fired in order
	        return _this;
	    }
	    /**
	     * Convenience method for creating a new delta.
	     *
	     * @param {Array} ops [Optional] The initial ops for the delta
	     * @returns {Delta}   A new Delta object
	     */
	    Editor.prototype.delta = function (ops) {
	        return new Delta$5(ops);
	    };
	    /**
	     * Returns the contents or a slice of them.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {Delta}     The contents of this editor
	     */
	    Editor.prototype.getContents = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.contents.slice(from, to);
	    };
	    /**
	     * Returns the text for the editor or a slice of it.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {String}    The text in the editor
	     */
	    Editor.prototype.getText = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length - 1; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.getContents(from, to)
	            .filter(function (op) { return typeof op.insert === 'string'; })
	            .map(function (op) { return op.insert; })
	            .join('');
	    };
	    /**
	     * Returns the text for the editor with null characters in place of embeds. This can be used to determine the index of
	     * given words or lines of text within the contents.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {String}    The text in the editor with embed spaces
	     */
	    Editor.prototype.getExactText = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length - 1; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.getContents(from, to)
	            .map(function (op) { return typeof op.insert === 'string' ? op.insert : '\0'; })
	            .join('');
	    };
	    /**
	     * Set the selection to a new location (or null for no selection). Will return false if the new selection is the same
	     * as the old selection. Dispatches "selection-change" once the selection is changed. This "selection-change" event
	     * won't have { contents, oldContnts, change } in it since the selection is changing without any content updates.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Boolean}        Whether the selection changed or not
	     */
	    Editor.prototype.setSelection = function (from, to, source) {
	        var _this = this;
	        if (source === void 0) { source = SOURCE_USER$8; }
	        var _a;
	        var oldSelection = this.selection;
	        var selection;
	        if (from === null) {
	            selection = null;
	            if (typeof to === 'string')
	                source = to;
	        }
	        else {
	            _a = this._normalizeSelection(from, to, source), from = _a[0], to = _a[1], source = _a[2];
	            selection = [from, to].map(function (i) { return Math.min(i, _this.length - 1); });
	        }
	        if (shallowEqual$5(oldSelection, selection))
	            return false;
	        // Reset the active formats when selection changes (do this before setting selection)
	        this.activeFormats = selection ? this.getTextFormat(Math.min(selection[0], selection[1])) : empty$5;
	        this.selection = selection;
	        var event = { selection: selection, oldSelection: oldSelection, source: source };
	        if (source !== SOURCE_SILENT$5)
	            this.fire('selection-change', event);
	        this.fire('editor-change', event);
	        return true;
	    };
	    /**
	     * The method that all other methods use to update the contents (even setContents & setText). This method will
	     * dispatch the event "text-changing". If a listener returns `false` then the change will be canceled and null will
	     * be returned. Otherwise, the change will be successful and if the `source` is not "silent" a "text-change" event
	     * will be fired with an event object containing `{ contents, oldContents, selection, oldSelection, source }`. If the
	     * selection has changed as part of this update a "selection-change" event will also be fired with the same event
	     * object.
	     *
	     * @param {Delta} change    A delta change to the document
	     * @param {String} source   The source of the change, user, api, or silent
	     * @param {Array} selection Optional selection after the change has been applied
	     * @returns {Delta}         Returns the change when successful, or null if not
	     */
	    Editor.prototype.updateContents = function (change, source, selection) {
	        if (source === void 0) { source = SOURCE_API$5; }
	        if (!change.chop().ops.length)
	            return null;
	        if (typeof selection === 'number')
	            selection = [selection, selection];
	        var oldContents = this.contents;
	        var contents = normalizeContents$5(oldContents.compose(change));
	        var length = contents.length();
	        var oldSelection = this.selection;
	        if (!selection)
	            selection = oldSelection ? oldSelection.map(function (i) { return change.transform(i); }) : oldSelection;
	        selection = selection && this.getSelectedRange(selection, length - 1);
	        var changeEvent = { contents: contents, oldContents: oldContents, change: change, selection: selection, oldSelection: oldSelection, source: source };
	        var selectionChanged = !shallowEqual$5(oldSelection, selection);
	        if (!this.fire('text-changing', changeEvent))
	            return null;
	        setContents$5(this, contents);
	        if (selection) {
	            // Reset the active formats when selection changes (do this before setting selection)
	            this.activeFormats = selection ? this.getTextFormat(Math.min(selection[0], selection[1])) : empty$5;
	            this.selection = selection;
	        }
	        var events = [];
	        if (source !== SOURCE_SILENT$5) {
	            events.push(['text-change', changeEvent]);
	            if (selectionChanged)
	                events.push(['selection-change', changeEvent]);
	        }
	        events.push(['editor-change', changeEvent]);
	        this._queueEvents(events);
	        return change;
	    };
	    /**
	     * Sets the entire contents of the editor. This will calculate the difference between the old content and the new and
	     * only apply the difference, if any.
	     *
	     * @param {Delta} newContents The contents of the editor, as a delta object
	     * @param {String} source     The source of the change, user, api, or silent
	     * @param {Array} selection   Optional selection after the change has been applied
	     * @returns {Delta}           Returns the change when successful, or null if not
	     */
	    Editor.prototype.setContents = function (newContents, source, selection) {
	        var change = this.contents.diff(normalizeContents$5(newContents));
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Sets the text content of the editor, removing existing contents and formatting.
	     *
	     * @param {String} text     Set the contents of this editor as text
	     * @param {String} source   The source of the change, user, api, or silent
	     * @param {Array} selection Optional selection after the change has been applied
	     * @returns {Delta}         Returns the change when successful, or null if not
	     */
	    Editor.prototype.setText = function (text, source, selection) {
	        return this.setContents(this.delta().insert(text + '\n'), source, selection);
	    };
	    /**
	     * Inserts text into the content of the editor, removing text between from and to if provided. If `text` is a newline
	     * ("\n") then the formats will apply to the line, otherwise they will apply to the text only (even if there are
	     * newlines in the text).
	     *
	     * @param {Number} from      Insert the text at this index, can also be a range Array tuple, default 0
	     * @param {Number} to        If provided and not equal to `from` will delete the text between `from` and `to`
	     * @param {String} text      The text to insert into the editor's contents
	     * @param {Object} formats   The formats of the inserted text. If null the formats at `from` will be used.
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.insertText = function (from, to, text, formats, source, selection) {
	        var _a, _b, _c;
	        _a = this._normalizeRange(from, to, text, formats, source, selection), from = _a[0], to = _a[1], text = _a[2], formats = _a[3], source = _a[4], selection = _a[5];
	        // If we are not inserting a newline, make sure from and to are within the selectable range
	        if (text !== '\n')
	            _b = this.getSelectedRange([from, to]), from = _b[0], to = _b[1];
	        if (typeof formats === 'string')
	            _c = [null, formats, source], formats = _c[0], source = _c[1], selection = _c[2];
	        if (selection == null && this.selection !== null)
	            selection = from + text.length;
	        var change = this.delta().retain(from)["delete"](to - from);
	        if (text === '\n') {
	            change.insert('\n', formats || this.getLineFormat(from));
	        }
	        else {
	            var lineFormat_1 = text.indexOf('\n') === -1 ? null : this.getLineFormat(from);
	            var textFormat_1 = formats || this.getTextFormat(from);
	            text.split('\n').forEach(function (line, i) {
	                if (i)
	                    change.insert('\n', lineFormat_1);
	                line.length && change.insert(line, textFormat_1);
	            });
	        }
	        change = cleanDelete$5(this, from, to, change);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Inserts an embed into the content of the editor, removing text between from and to if provided.
	     *
	     * @param {Number} from      Insert the embed at this index, can also be a range Array tuple, default 0
	     * @param {Number} to        If provided and not equal to `from` will delete the text between `from` and `to`
	     * @param {String} embed     Insert the text into the editor's contents
	     * @param {mixed}  value     Insert the text into the editor's contents
	     * @param {String} formats   The formats of the inserted text. If null the formats at `from` will be used.
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.insertEmbed = function (from, to, embed, value, formats, source, selection) {
	        var _a, _b, _c;
	        _a = this._normalizeRange(from, to, embed, value, source, selection), from = _a[0], to = _a[1], embed = _a[2], value = _a[3], source = _a[4], selection = _a[5];
	        if (typeof formats === 'string')
	            _b = [null, formats, source], formats = _b[0], source = _b[1], selection = _b[2];
	        if (from >= this.length)
	            from = this.length - 1;
	        if (to >= this.length)
	            to = this.length - 1;
	        if (selection == null && this.selection !== null)
	            selection = from + 1;
	        var textFormat = formats || this.getTextFormat(from);
	        var change = this.delta().retain(from)["delete"](to - from).insert((_c = {}, _c[embed] = value, _c), textFormat);
	        change = cleanDelete$5(this, from, to, change);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Deletes text from `from` to `to`.
	     *
	     * @param {Number} from      Insert the text as this index, can also be a range Array tuple, default 0
	     * @param {Number} to        Will delete the text between `from` and `to`
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.deleteText = function (from, to, source, selection) {
	        var _a;
	        _a = this._normalizeRange(from, to, source, selection), from = _a[0], to = _a[1], source = _a[2], selection = _a[3];
	        if (from === to)
	            return null;
	        if (selection == null && this.selection !== null)
	            selection = from;
	        var change = this.delta().retain(from)["delete"](to - from);
	        change = cleanDelete$5(this, from, to, change);
	        // Keep the active format of the text to the right of the cursor when deleting
	        var activeFormats;
	        if (selection === from)
	            activeFormats = this.getTextFormat(from, from + 1);
	        var result = this.updateContents(change, source, selection);
	        if (result && activeFormats)
	            this.activeFormats = activeFormats;
	        return result;
	    };
	    /**
	     * Get the line formats for the line that `from` is in to the line that `to` is in. Returns only the common formats
	     * between all the lines. If `from` equals `to` (or `to` is not provided) the formats will be all of those for the
	     * line `from` is on. If two lines are touched and they have different formats, an empty object will be returned.
	     *
	     * @param {Number} from Getting line formats starting at `from`
	     * @param {Number} to   Getting line formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the lines which intersect from and to
	     */
	    Editor.prototype.getLineFormat = function (from, to) {
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        var formats;
	        this.contents.getLines(from, to).forEach(function (line) {
	            if (!line.attributes)
	                formats = {};
	            else if (!formats)
	                formats = __assign$1$3({}, line.attributes);
	            else
	                formats = combineFormats$5(formats, line.attributes);
	        });
	        return formats;
	    };
	    /**
	     * Get the text formats for all the text from `from` to `to`. Returns only the common formats between the two indexes.
	     * Will also return the `activeFormats`. Active formats are those which are toggled on when the selection is collapsed
	     * (from and to are equal) indicating inserted text should use (or not use) those formats.
	     *
	     * @param {Number} from Getting text formats starting at `from`
	     * @param {Number} to   Getting text formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the text
	     */
	    Editor.prototype.getTextFormat = function (from, to) {
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        var formats;
	        // optimize for current selection
	        var seleciton = this.selection;
	        if (from === to && shallowEqual$5(this.selection, [from, to])) {
	            return this.activeFormats;
	        }
	        this.contents.getOps(from, to).forEach(function (_a) {
	            var op = _a.op;
	            if (/^\n+$/.test(op.insert))
	                return;
	            if (!op.attributes)
	                formats = {};
	            else if (!formats)
	                formats = __assign$1$3({}, op.attributes);
	            else
	                formats = combineFormats$5(formats, op.attributes);
	        });
	        if (!formats)
	            formats = {};
	        return formats;
	    };
	    /**
	     * Get the text and line formats for all the lines and text from `from` to `to`.
	     *
	     * @param {Number} from Getting line and text formats starting at `from`
	     * @param {Number} to   Getting line and text formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the lines and text which intersect from and to
	     */
	    Editor.prototype.getFormat = function (from, to) {
	        return __assign$1$3({}, this.getTextFormat(from, to), this.getLineFormat(from, to));
	    };
	    /**
	     * Formats the lines intersected by `from` and `to` with the given line formats. To remove an existing format pass in
	     * `null` or `false` to turn it off (e.g. `{ blockquote: false }`).
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the line
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.formatLine = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var change = this.delta();
	        this.contents.getLines(from, to).forEach(function (line) {
	            if (!change.ops.length)
	                change.retain(line.end - 1);
	            else
	                change.retain(line.end - line.start - 1);
	            // Clear out old formats on the line
	            Object.keys(line.attributes).forEach(function (name) { return !formats[name] && (formats[name] = null); });
	            change.retain(1, formats);
	        });
	        change.chop();
	        return change.ops.length ? this.updateContents(change, source) : null;
	    };
	    /**
	     * Formats the text from `from` to `to` with the given text formats. To remove an existing format pass in `null` or
	     * `false` to turn it off (e.g. `{ bold: false }`).
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the text
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.formatText = function (from, to, formats, source) {
	        var _this = this;
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        if (from === to) {
	            if (this.activeFormats === empty$5)
	                this.activeFormats = {};
	            Object.keys(formats).forEach(function (key) {
	                var value = formats[key];
	                if (value == null || value === false)
	                    delete _this.activeFormats[key];
	                else
	                    _this.activeFormats[key] = value;
	            });
	            return;
	        }
	        Object.keys(formats).forEach(function (name) { return formats[name] === false && (formats[name] = null); });
	        var change = this.delta().retain(from);
	        this.getText(from, to).split('\n').forEach(function (line) {
	            line.length && change.retain(line.length, formats);
	            change.retain(1);
	        });
	        change.chop();
	        return this.updateContents(change, source);
	    };
	    /**
	     * Toggles the line formats from `from` to `to` with the given line formats. If the line has the exact formats already
	     * they will be removed, otherwise they will be added.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the line
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.toggleLineFormat = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var existing = this.getLineFormat(from, to);
	        if (deepEqual$5(existing, formats)) {
	            Object.keys(formats).forEach(function (key) { return formats[key] = null; });
	        }
	        return this.formatLine(from, to, formats, source);
	    };
	    /**
	     * Toggles the text formats from `from` to `to` with the given text formats. If the text has the exact formats already
	     * they will be removed, otherwise they will be added.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the text
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.toggleTextFormat = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var existing = this.getTextFormat(from, to);
	        var isSame = Object.keys(formats).every(function (key) { return formats[key] === existing[key]; });
	        if (isSame) {
	            Object.keys(formats).forEach(function (key) { return formats[key] = null; });
	        }
	        return this.formatText(from, to, formats, source);
	    };
	    /**
	     * Removes all formatting, text and line formats, for the text and lines from `from` to `to`.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.removeFormats = function (from, to, source) {
	        var _this = this;
	        var _a;
	        _a = this._normalizeRange(from, to, source), from = _a[0], to = _a[1], source = _a[2];
	        var formats = {};
	        this.contents.getOps(from, to).forEach(function (_a) {
	            var op = _a.op;
	            op.attributes && Object.keys(op.attributes).forEach(function (key) { return formats[key] = null; });
	        });
	        var change = this.delta().retain(from).retain(to - from, formats);
	        // If the last block was not captured be sure to clear that too
	        this.contents.getLines(from, to).forEach(function (line) {
	            var formats = {};
	            Object.keys(line.attributes).forEach(function (key) { return formats[key] = null; });
	            change = change.compose(_this.delta().retain(line.end - 1).retain(1, formats));
	        });
	        return this.updateContents(change, source);
	    };
	    /**
	     * Create a change delta calling one or more methods on the editor. The changes will not be applied as normal but will
	     * be collated into a single change delta and returned from this methnod. Example:
	     * ```js
	     * var change = editor.getChange(function() {
	     *   editor.deleteText(0, 5);
	     *   editor.insertText('\n', { blockquote: true });
	     *   editor.formatText(10, 20, { bold: true });
	     * });
	     *
	     * editor.updateContents(change, 'user');
	     * ```
	     *
	     * @param {Function} producer A function in which to call methods on the editor to produce a change
	     * @returns {Delta}           The sum of all the changes made within the producer
	     */
	    Editor.prototype.getChange = function (producer) {
	        var change = this.delta();
	        this.updateContents = function (singleChange) {
	            if (singleChange.ops.length) {
	                change = change.compose(singleChange);
	                return singleChange;
	            }
	            else {
	                return null;
	            }
	        };
	        producer(this);
	        delete this.updateContents;
	        return change;
	    };
	    /**
	     * Make several changes to the editor apply all at one in one commit. Changes made with the transaction will be
	     * applied all together and the "text-changing", "text-change", and "selection-change" events will be dispatched only
	     * once. Use this to combine multiple changes into one.
	     *
	     * @param {Function} producer A function which should make changes with the editor
	     * @param {String} source     The source of the change, user, api, or silent
	     * @param {Array} selection   Optional selection after the change has been applied
	     * @returns {Delta}           Returns the change when successful, or null if not
	     */
	    Editor.prototype.transaction = function (producer, source, selection) {
	        var change = this.getChange(producer);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Returns the selected range (or the provided range) in index order (lowest number first) and within the bounds of
	     * the content, between 0 and content.length() - 1 (the selection cannot be past the trailing newline).
	     *
	     * @param {Array} range Optional range, defaults to current selection
	     * @param {Number} max  The maxium number the range can be
	     */
	    Editor.prototype.getSelectedRange = function (range, max) {
	        if (range === void 0) { range = this.selection; }
	        if (max === void 0) { max = this.length - 1; }
	        var _a;
	        if (range == null)
	            return range;
	        if (typeof range === 'number')
	            range = [range, range];
	        if (range[0] > range[1])
	            _a = [range[1], range[0]], range[0] = _a[0], range[1] = _a[1];
	        return range.map(function (index) { return Math.max(0, Math.min(max, index)); });
	    };
	    Editor.prototype._queueEvents = function (events) {
	        var _a;
	        var alreadyRunning = this._queuedEvents.length;
	        (_a = this._queuedEvents).push.apply(_a, events);
	        if (alreadyRunning)
	            return;
	        while (this._queuedEvents.length) {
	            var event = this._queuedEvents.shift();
	            this.fire.apply(this, event);
	        }
	    };
	    /**
	     * Normalizes range values to a proper range if it is not already. A range is a `from` and a `to` index, e.g. 0, 4.
	     * This will ensure the lower index is first. Example usage:
	     * editor._normalizeRange(5); // [5, 5]
	     * editor._normalizeRange(-4, 100); // for a doc with length 10, [0, 10]
	     * editor._normalizeRange(25, 18); // [18, 25]
	     * editor._normalizeRange([12, 13]); // [12, 13]
	     * editor._normalizeRange(5, { bold: true }); // [5, 5, { bold: true }]
	     */
	    Editor.prototype._normalizeRange = function (from, to) {
	        var rest = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            rest[_i - 2] = arguments[_i];
	        }
	        var _a;
	        _a = this._normalizeSelection.apply(this, [from, to].concat(rest)), from = _a[0], to = _a[1], rest = _a.slice(2);
	        if (from > to) {
	            var toValue = from;
	            from = to;
	            to = toValue;
	        }
	        return [from, to].concat(rest);
	    };
	    Editor.prototype._normalizeSelection = function (from, to) {
	        var rest = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            rest[_i - 2] = arguments[_i];
	        }
	        var _a;
	        if (Array.isArray(from)) {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            _a = from, from = _a[0], to = _a[1];
	            if (to === undefined)
	                to = from;
	        }
	        else if (typeof from !== 'number') {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            if (from !== undefined || rest.length)
	                rest.unshift(from);
	            from = to = 0;
	        }
	        else if (typeof to !== 'number') {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            to = from;
	        }
	        from = Math.max(0, Math.min(this.length, Math.floor(from)));
	        to = Math.max(0, Math.min(this.length, Math.floor(to)));
	        return [from, to].concat(rest);
	    };
	    return Editor;
	}(EventDispatcher$5));
	// Ensures the format for the current line in a delete remains the same when multiple lines are deleted. This is needed
	// because the last line holds the formatting after a delete, but the first line is expected to be the retained format
	function cleanDelete$5(editor, from, to, change) {
	    if (from !== to) {
	        var line = editor.contents.getLine(from);
	        if (!line.ops.length() && to === from + 1)
	            return change;
	        var lineFormat_2 = editor.getLineFormat(from);
	        if (!deepEqual$5(lineFormat_2, editor.getLineFormat(to))) {
	            var lineChange = editor.getChange(function () { return editor.formatLine(to, lineFormat_2); });
	            change = change.compose(change.transform(lineChange));
	        }
	    }
	    return change;
	}
	// Ensures contents end with a newline
	function normalizeContents$5(contents) {
	    // Contents only have inserts. Deletes and retains belong to changes only.
	    contents.ops = contents.ops.filter(function (op) { return op.insert; });
	    var lastOp = contents.ops[contents.ops.length - 1];
	    if (!lastOp || typeof lastOp.insert !== 'string' || lastOp.insert.slice(-1) !== '\n')
	        contents.insert('\n');
	    return contents;
	}
	// Sets the contents onto the editor after ensuring they end in a newline, freezes the contents from change, and
	// updates the length and text of the editor to the latest
	function setContents$5(editor, contents) {
	    contents = normalizeContents$5(contents);
	    contents.freeze();
	    editor.contents = contents;
	    editor.length = contents.length();
	}
	// Combine formats removing ones that don't exist in both and creating an array for those with multiple values
	function combineFormats$5(formats, combined) {
	    return Object.keys(combined).reduce(function (merged, name) {
	        if (formats[name] == null)
	            return merged;
	        if (combined[name] === formats[name]) {
	            merged[name] = combined[name];
	        }
	        else if (Array.isArray(combined[name])) {
	            if (combined[name].indexOf(formats[name]) < 0) {
	                merged[name] = combined[name].concat([formats[name]]);
	            }
	        }
	        else {
	            merged[name] = [combined[name], formats[name]];
	        }
	        return merged;
	    }, {});
	}

	/**
	 * Defines the blocks, marks, and embeds that can be used in a Typewriter document.
	 */

	// Determines if a <br> in the editable area is part of the document or a doorstop at the end of a block.
	function isBRPlaceholder$3(paper, node) {
	    if (node.nodeName !== 'BR')
	        return false;
	    var blocks = paper.blocks;
	    var next = node.nextSibling;
	    while (next && next.nodeValue === '')
	        next = next.nextSibling;
	    if (next) {
	        return next.nodeType === Node.ELEMENT_NODE && blocks.matches(next);
	    }
	    return blocks.matches(node.parentNode);
	}

	var dispatcherEvents$1$3 = new WeakMap();
	var EventDispatcher$1$3 = /** @class */ (function () {
	    function EventDispatcher() {
	    }
	    EventDispatcher.prototype.on = function (type, listener) {
	        getEventListeners$1$3(this, type, true).add(listener);
	    };
	    EventDispatcher.prototype.off = function (type, listener) {
	        var events = getEventListeners$1$3(this, type);
	        events && events["delete"](listener);
	    };
	    EventDispatcher.prototype.once = function (type, listener) {
	        function once() {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            this.off(type, once);
	            listener.apply(this, args);
	        }
	        this.on(type, once);
	    };
	    EventDispatcher.prototype.fire = function (type) {
	        var _this = this;
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        var uncanceled = true;
	        var events = getEventListeners$1$3(this, type);
	        if (events)
	            events.forEach(function (listener) {
	                uncanceled && listener.apply(_this, args) !== false || (uncanceled = false);
	            });
	        return uncanceled;
	    };
	    return EventDispatcher;
	}());
	function getEventListeners$1$3(obj, type, autocreate) {
	    if (autocreate === void 0) { autocreate = false; }
	    var events = dispatcherEvents$1$3.get(obj);
	    if (!events && autocreate)
	        dispatcherEvents$1$3.set(obj, events = Object.create(null));
	    return events && events[type] || autocreate && (events[type] = new Set());
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global Reflect, Promise */

	var extendStatics$2$1 = function(d, b) {
	    extendStatics$2$1 = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return extendStatics$2$1(d, b);
	};

	function __extends$2$1(d, b) {
	    extendStatics$2$1(d, b);
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	var __assign$2$2 = function() {
	    __assign$2$2 = Object.assign || function __assign(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2$2.apply(this, arguments);
	};

	/**
	 * This library modifies the diff-patch-match library by Neil Fraser
	 * by removing the patch and match functionality and certain advanced
	 * options in the diff function. The original license is as follows:
	 *
	 * ===
	 *
	 * Diff Match and Patch
	 *
	 * Copyright 2006 Google Inc.
	 * http://code.google.com/p/google-diff-match-patch/
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *   http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	/**
	 * The data structure representing a diff is an array of tuples:
	 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
	 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
	 */
	var DIFF_DELETE$1$3 = -1;
	var DIFF_INSERT$1$3 = 1;
	var DIFF_EQUAL$1$3 = 0;
	/**
	 * Find the differences between two texts.  Simplifies the problem by stripping
	 * any common prefix or suffix off the texts before diffing.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {Int} cursor_pos Expected edit position in text1 (optional)
	 * @return {Array} Array of diff tuples.
	 */
	function diff$1$3(text1, text2, cursor_pos) {
	    // Check for equality (speedup).
	    if (text1 == text2) {
	        if (text1) {
	            return [[DIFF_EQUAL$1$3, text1]];
	        }
	        return [];
	    }
	    // Check cursor_pos within bounds
	    if (cursor_pos < 0 || text1.length < cursor_pos) {
	        cursor_pos = null;
	    }
	    // Trim off common prefix (speedup).
	    var commonlength = diff_commonPrefix$1$3(text1, text2);
	    var commonprefix = text1.substring(0, commonlength);
	    text1 = text1.substring(commonlength);
	    text2 = text2.substring(commonlength);
	    // Trim off common suffix (speedup).
	    commonlength = diff_commonSuffix$1$3(text1, text2);
	    var commonsuffix = text1.substring(text1.length - commonlength);
	    text1 = text1.substring(0, text1.length - commonlength);
	    text2 = text2.substring(0, text2.length - commonlength);
	    // Compute the diff on the middle block.
	    var diffs = diff_compute_$1$3(text1, text2);
	    // Restore the prefix and suffix.
	    if (commonprefix) {
	        diffs.unshift([DIFF_EQUAL$1$3, commonprefix]);
	    }
	    if (commonsuffix) {
	        diffs.push([DIFF_EQUAL$1$3, commonsuffix]);
	    }
	    diff_cleanupMerge$1$3(diffs);
	    if (cursor_pos != null) {
	        diffs = fix_cursor$1$3(diffs, cursor_pos);
	    }
	    diffs = fix_emoji$1$3(diffs);
	    return diffs;
	}
	/**
	 * Find the differences between two texts.  Assumes that the texts do not
	 * have any common prefix or suffix.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @return {Array} Array of diff tuples.
	 */
	function diff_compute_$1$3(text1, text2) {
	    var diffs;
	    if (!text1) {
	        // Just add some text (speedup).
	        return [[DIFF_INSERT$1$3, text2]];
	    }
	    if (!text2) {
	        // Just delete some text (speedup).
	        return [[DIFF_DELETE$1$3, text1]];
	    }
	    var longtext = text1.length > text2.length ? text1 : text2;
	    var shorttext = text1.length > text2.length ? text2 : text1;
	    var i = longtext.indexOf(shorttext);
	    if (i != -1) {
	        // Shorter text is inside the longer text (speedup).
	        diffs = [[DIFF_INSERT$1$3, longtext.substring(0, i)],
	            [DIFF_EQUAL$1$3, shorttext],
	            [DIFF_INSERT$1$3, longtext.substring(i + shorttext.length)]];
	        // Swap insertions for deletions if diff is reversed.
	        if (text1.length > text2.length) {
	            diffs[0][0] = diffs[2][0] = DIFF_DELETE$1$3;
	        }
	        return diffs;
	    }
	    if (shorttext.length == 1) {
	        // Single character string.
	        // After the previous speedup, the character can't be an equality.
	        return [[DIFF_DELETE$1$3, text1], [DIFF_INSERT$1$3, text2]];
	    }
	    // Check to see if the problem can be split in two.
	    var hm = diff_halfMatch_$1$3(text1, text2);
	    if (hm) {
	        // A half-match was found, sort out the return data.
	        var text1_a = hm[0];
	        var text1_b = hm[1];
	        var text2_a = hm[2];
	        var text2_b = hm[3];
	        var mid_common = hm[4];
	        // Send both pairs off for separate processing.
	        var diffs_a = diff$1$3(text1_a, text2_a);
	        var diffs_b = diff$1$3(text1_b, text2_b);
	        // Merge the results.
	        return diffs_a.concat([[DIFF_EQUAL$1$3, mid_common]], diffs_b);
	    }
	    return diff_bisect_$1$3(text1, text2);
	}
	/**
	 * Find the 'middle snake' of a diff, split the problem in two
	 * and return the recursively constructed diff.
	 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @return {Array} Array of diff tuples.
	 * @private
	 */
	function diff_bisect_$1$3(text1, text2) {
	    // Cache the text lengths to prevent multiple calls.
	    var text1_length = text1.length;
	    var text2_length = text2.length;
	    var max_d = Math.ceil((text1_length + text2_length) / 2);
	    var v_offset = max_d;
	    var v_length = 2 * max_d;
	    var v1 = new Array(v_length);
	    var v2 = new Array(v_length);
	    // Setting all elements to -1 is faster in Chrome & Firefox than mixing
	    // integers and undefined.
	    for (var x = 0; x < v_length; x++) {
	        v1[x] = -1;
	        v2[x] = -1;
	    }
	    v1[v_offset + 1] = 0;
	    v2[v_offset + 1] = 0;
	    var delta = text1_length - text2_length;
	    // If the total number of characters is odd, then the front path will collide
	    // with the reverse path.
	    var front = (delta % 2 != 0);
	    // Offsets for start and end of k loop.
	    // Prevents mapping of space beyond the grid.
	    var k1start = 0;
	    var k1end = 0;
	    var k2start = 0;
	    var k2end = 0;
	    for (var d = 0; d < max_d; d++) {
	        // Walk the front path one step.
	        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
	            var k1_offset = v_offset + k1;
	            var x1;
	            if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
	                x1 = v1[k1_offset + 1];
	            }
	            else {
	                x1 = v1[k1_offset - 1] + 1;
	            }
	            var y1 = x1 - k1;
	            while (x1 < text1_length && y1 < text2_length &&
	                text1.charAt(x1) == text2.charAt(y1)) {
	                x1++;
	                y1++;
	            }
	            v1[k1_offset] = x1;
	            if (x1 > text1_length) {
	                // Ran off the right of the graph.
	                k1end += 2;
	            }
	            else if (y1 > text2_length) {
	                // Ran off the bottom of the graph.
	                k1start += 2;
	            }
	            else if (front) {
	                var k2_offset = v_offset + delta - k1;
	                if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
	                    // Mirror x2 onto top-left coordinate system.
	                    var x2 = text1_length - v2[k2_offset];
	                    if (x1 >= x2) {
	                        // Overlap detected.
	                        return diff_bisectSplit_$1$3(text1, text2, x1, y1);
	                    }
	                }
	            }
	        }
	        // Walk the reverse path one step.
	        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
	            var k2_offset = v_offset + k2;
	            var x2;
	            if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
	                x2 = v2[k2_offset + 1];
	            }
	            else {
	                x2 = v2[k2_offset - 1] + 1;
	            }
	            var y2 = x2 - k2;
	            while (x2 < text1_length && y2 < text2_length &&
	                text1.charAt(text1_length - x2 - 1) ==
	                    text2.charAt(text2_length - y2 - 1)) {
	                x2++;
	                y2++;
	            }
	            v2[k2_offset] = x2;
	            if (x2 > text1_length) {
	                // Ran off the left of the graph.
	                k2end += 2;
	            }
	            else if (y2 > text2_length) {
	                // Ran off the top of the graph.
	                k2start += 2;
	            }
	            else if (!front) {
	                var k1_offset = v_offset + delta - k2;
	                if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
	                    var x1 = v1[k1_offset];
	                    var y1 = v_offset + x1 - k1_offset;
	                    // Mirror x2 onto top-left coordinate system.
	                    x2 = text1_length - x2;
	                    if (x1 >= x2) {
	                        // Overlap detected.
	                        return diff_bisectSplit_$1$3(text1, text2, x1, y1);
	                    }
	                }
	            }
	        }
	    }
	    // Diff took too long and hit the deadline or
	    // number of diffs equals number of characters, no commonality at all.
	    return [[DIFF_DELETE$1$3, text1], [DIFF_INSERT$1$3, text2]];
	}
	/**
	 * Given the location of the 'middle snake', split the diff in two parts
	 * and recurse.
	 * @param {string} text1 Old string to be diffed.
	 * @param {string} text2 New string to be diffed.
	 * @param {number} x Index of split point in text1.
	 * @param {number} y Index of split point in text2.
	 * @return {Array} Array of diff tuples.
	 */
	function diff_bisectSplit_$1$3(text1, text2, x, y) {
	    var text1a = text1.substring(0, x);
	    var text2a = text2.substring(0, y);
	    var text1b = text1.substring(x);
	    var text2b = text2.substring(y);
	    // Compute both diffs serially.
	    var diffs = diff$1$3(text1a, text2a);
	    var diffsb = diff$1$3(text1b, text2b);
	    return diffs.concat(diffsb);
	}
	/**
	 * Determine the common prefix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the start of each
	 *     string.
	 */
	function diff_commonPrefix$1$3(text1, text2) {
	    // Quick check for common null cases.
	    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
	        return 0;
	    }
	    // Binary search.
	    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	    var pointermin = 0;
	    var pointermax = Math.min(text1.length, text2.length);
	    var pointermid = pointermax;
	    var pointerstart = 0;
	    while (pointermin < pointermid) {
	        if (text1.substring(pointerstart, pointermid) ==
	            text2.substring(pointerstart, pointermid)) {
	            pointermin = pointermid;
	            pointerstart = pointermin;
	        }
	        else {
	            pointermax = pointermid;
	        }
	        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }
	    return pointermid;
	}
	/**
	 * Determine the common suffix of two strings.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {number} The number of characters common to the end of each string.
	 */
	function diff_commonSuffix$1$3(text1, text2) {
	    // Quick check for common null cases.
	    if (!text1 || !text2 ||
	        text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
	        return 0;
	    }
	    // Binary search.
	    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
	    var pointermin = 0;
	    var pointermax = Math.min(text1.length, text2.length);
	    var pointermid = pointermax;
	    var pointerend = 0;
	    while (pointermin < pointermid) {
	        if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
	            text2.substring(text2.length - pointermid, text2.length - pointerend)) {
	            pointermin = pointermid;
	            pointerend = pointermin;
	        }
	        else {
	            pointermax = pointermid;
	        }
	        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
	    }
	    return pointermid;
	}
	/**
	 * Do the two texts share a substring which is at least half the length of the
	 * longer text?
	 * This speedup can produce non-minimal diffs.
	 * @param {string} text1 First string.
	 * @param {string} text2 Second string.
	 * @return {Array.<string>} Five element Array, containing the prefix of
	 *     text1, the suffix of text1, the prefix of text2, the suffix of
	 *     text2 and the common middle.  Or null if there was no match.
	 */
	function diff_halfMatch_$1$3(text1, text2) {
	    var longtext = text1.length > text2.length ? text1 : text2;
	    var shorttext = text1.length > text2.length ? text2 : text1;
	    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
	        return null; // Pointless.
	    }
	    /**
	     * Does a substring of shorttext exist within longtext such that the substring
	     * is at least half the length of longtext?
	     * Closure, but does not reference any external variables.
	     * @param {string} longtext Longer string.
	     * @param {string} shorttext Shorter string.
	     * @param {number} i Start index of quarter length substring within longtext.
	     * @return {Array.<string>} Five element Array, containing the prefix of
	     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
	     *     of shorttext and the common middle.  Or null if there was no match.
	     * @private
	     */
	    function diff_halfMatchI_(longtext, shorttext, i) {
	        // Start with a 1/4 length substring at position i as a seed.
	        var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
	        var j = -1;
	        var best_common = '';
	        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
	        while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
	            var prefixLength = diff_commonPrefix$1$3(longtext.substring(i), shorttext.substring(j));
	            var suffixLength = diff_commonSuffix$1$3(longtext.substring(0, i), shorttext.substring(0, j));
	            if (best_common.length < suffixLength + prefixLength) {
	                best_common = shorttext.substring(j - suffixLength, j) +
	                    shorttext.substring(j, j + prefixLength);
	                best_longtext_a = longtext.substring(0, i - suffixLength);
	                best_longtext_b = longtext.substring(i + prefixLength);
	                best_shorttext_a = shorttext.substring(0, j - suffixLength);
	                best_shorttext_b = shorttext.substring(j + prefixLength);
	            }
	        }
	        if (best_common.length * 2 >= longtext.length) {
	            return [best_longtext_a, best_longtext_b,
	                best_shorttext_a, best_shorttext_b, best_common];
	        }
	        else {
	            return null;
	        }
	    }
	    // First check if the second quarter is the seed for a half-match.
	    var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
	    // Check again based on the third quarter.
	    var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
	    var hm;
	    if (!hm1 && !hm2) {
	        return null;
	    }
	    else if (!hm2) {
	        hm = hm1;
	    }
	    else if (!hm1) {
	        hm = hm2;
	    }
	    else {
	        // Both matched.  Select the longest.
	        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
	    }
	    // A half-match was found, sort out the return data.
	    var text1_a, text1_b, text2_a, text2_b;
	    if (text1.length > text2.length) {
	        text1_a = hm[0];
	        text1_b = hm[1];
	        text2_a = hm[2];
	        text2_b = hm[3];
	    }
	    else {
	        text2_a = hm[0];
	        text2_b = hm[1];
	        text1_a = hm[2];
	        text1_b = hm[3];
	    }
	    var mid_common = hm[4];
	    return [text1_a, text1_b, text2_a, text2_b, mid_common];
	}
	/**
	 * Reorder and merge like edit sections.  Merge equalities.
	 * Any edit section can move as long as it doesn't cross an equality.
	 * @param {Array} diffs Array of diff tuples.
	 */
	function diff_cleanupMerge$1$3(diffs) {
	    diffs.push([DIFF_EQUAL$1$3, '']); // Add a dummy entry at the end.
	    var pointer = 0;
	    var count_delete = 0;
	    var count_insert = 0;
	    var text_delete = '';
	    var text_insert = '';
	    var commonlength;
	    while (pointer < diffs.length) {
	        switch (diffs[pointer][0]) {
	            case DIFF_INSERT$1$3:
	                count_insert++;
	                text_insert += diffs[pointer][1];
	                pointer++;
	                break;
	            case DIFF_DELETE$1$3:
	                count_delete++;
	                text_delete += diffs[pointer][1];
	                pointer++;
	                break;
	            case DIFF_EQUAL$1$3:
	                // Upon reaching an equality, check for prior redundancies.
	                if (count_delete + count_insert > 1) {
	                    if (count_delete !== 0 && count_insert !== 0) {
	                        // Factor out any common prefixies.
	                        commonlength = diff_commonPrefix$1$3(text_insert, text_delete);
	                        if (commonlength !== 0) {
	                            if ((pointer - count_delete - count_insert) > 0 &&
	                                diffs[pointer - count_delete - count_insert - 1][0] ==
	                                    DIFF_EQUAL$1$3) {
	                                diffs[pointer - count_delete - count_insert - 1][1] +=
	                                    text_insert.substring(0, commonlength);
	                            }
	                            else {
	                                diffs.splice(0, 0, [DIFF_EQUAL$1$3,
	                                    text_insert.substring(0, commonlength)]);
	                                pointer++;
	                            }
	                            text_insert = text_insert.substring(commonlength);
	                            text_delete = text_delete.substring(commonlength);
	                        }
	                        // Factor out any common suffixies.
	                        commonlength = diff_commonSuffix$1$3(text_insert, text_delete);
	                        if (commonlength !== 0) {
	                            diffs[pointer][1] = text_insert.substring(text_insert.length -
	                                commonlength) + diffs[pointer][1];
	                            text_insert = text_insert.substring(0, text_insert.length -
	                                commonlength);
	                            text_delete = text_delete.substring(0, text_delete.length -
	                                commonlength);
	                        }
	                    }
	                    // Delete the offending records and add the merged ones.
	                    if (count_delete === 0) {
	                        diffs.splice(pointer - count_insert, count_delete + count_insert, [DIFF_INSERT$1$3, text_insert]);
	                    }
	                    else if (count_insert === 0) {
	                        diffs.splice(pointer - count_delete, count_delete + count_insert, [DIFF_DELETE$1$3, text_delete]);
	                    }
	                    else {
	                        diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert, [DIFF_DELETE$1$3, text_delete], [DIFF_INSERT$1$3, text_insert]);
	                    }
	                    pointer = pointer - count_delete - count_insert +
	                        (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
	                }
	                else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL$1$3) {
	                    // Merge this equality with the previous one.
	                    diffs[pointer - 1][1] += diffs[pointer][1];
	                    diffs.splice(pointer, 1);
	                }
	                else {
	                    pointer++;
	                }
	                count_insert = 0;
	                count_delete = 0;
	                text_delete = '';
	                text_insert = '';
	                break;
	        }
	    }
	    if (diffs[diffs.length - 1][1] === '') {
	        diffs.pop(); // Remove the dummy entry at the end.
	    }
	    // Second pass: look for single edits surrounded on both sides by equalities
	    // which can be shifted sideways to eliminate an equality.
	    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
	    var changes = false;
	    pointer = 1;
	    // Intentionally ignore the first and last element (don't need checking).
	    while (pointer < diffs.length - 1) {
	        if (diffs[pointer - 1][0] == DIFF_EQUAL$1$3 &&
	            diffs[pointer + 1][0] == DIFF_EQUAL$1$3) {
	            // This is a single edit surrounded by equalities.
	            if (diffs[pointer][1].substring(diffs[pointer][1].length -
	                diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
	                // Shift the edit over the previous equality.
	                diffs[pointer][1] = diffs[pointer - 1][1] +
	                    diffs[pointer][1].substring(0, diffs[pointer][1].length -
	                        diffs[pointer - 1][1].length);
	                diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
	                diffs.splice(pointer - 1, 1);
	                changes = true;
	            }
	            else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
	                diffs[pointer + 1][1]) {
	                // Shift the edit over the next equality.
	                diffs[pointer - 1][1] += diffs[pointer + 1][1];
	                diffs[pointer][1] =
	                    diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
	                        diffs[pointer + 1][1];
	                diffs.splice(pointer + 1, 1);
	                changes = true;
	            }
	        }
	        pointer++;
	    }
	    // If shifts were made, the diff needs reordering and another shift sweep.
	    if (changes) {
	        diff_cleanupMerge$1$3(diffs);
	    }
	}
	diff$1$3.INSERT = DIFF_INSERT$1$3;
	diff$1$3.DELETE = DIFF_DELETE$1$3;
	diff$1$3.EQUAL = DIFF_EQUAL$1$3;
	/*
	 * Modify a diff such that the cursor position points to the start of a change:
	 * E.g.
	 *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)
	 *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]
	 *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)
	 *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
	 * @return {Array} A tuple [cursor location in the modified diff, modified diff]
	 */
	function cursor_normalize_diff$1$3(diffs, cursor_pos) {
	    if (cursor_pos === 0) {
	        return [DIFF_EQUAL$1$3, diffs];
	    }
	    for (var current_pos = 0, i = 0; i < diffs.length; i++) {
	        var d = diffs[i];
	        if (d[0] === DIFF_DELETE$1$3 || d[0] === DIFF_EQUAL$1$3) {
	            var next_pos = current_pos + d[1].length;
	            if (cursor_pos === next_pos) {
	                return [i + 1, diffs];
	            }
	            else if (cursor_pos < next_pos) {
	                // copy to prevent side effects
	                diffs = diffs.slice();
	                // split d into two diff changes
	                var split_pos = cursor_pos - current_pos;
	                var d_left = [d[0], d[1].slice(0, split_pos)];
	                var d_right = [d[0], d[1].slice(split_pos)];
	                diffs.splice(i, 1, d_left, d_right);
	                return [i + 1, diffs];
	            }
	            else {
	                current_pos = next_pos;
	            }
	        }
	    }
	    throw new Error('cursor_pos is out of bounds!');
	}
	/*
	 * Modify a diff such that the edit position is "shifted" to the proposed edit location (cursor_position).
	 *
	 * Case 1)
	 *   Check if a naive shift is possible:
	 *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)
	 *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result
	 * Case 2)
	 *   Check if the following shifts are possible:
	 *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']
	 *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']
	 *         ^            ^
	 *         d          d_next
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!
	 * @return {Array} Array of diff tuples
	 */
	function fix_cursor$1$3(diffs, cursor_pos) {
	    var norm = cursor_normalize_diff$1$3(diffs, cursor_pos);
	    var ndiffs = norm[1];
	    var cursor_pointer = norm[0];
	    var d = ndiffs[cursor_pointer];
	    var d_next = ndiffs[cursor_pointer + 1];
	    if (d == null) {
	        // Text was deleted from end of original string,
	        // cursor is now out of bounds in new string
	        return diffs;
	    }
	    else if (d[0] !== DIFF_EQUAL$1$3) {
	        // A modification happened at the cursor location.
	        // This is the expected outcome, so we can return the original diff.
	        return diffs;
	    }
	    else {
	        if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {
	            // Case 1)
	            // It is possible to perform a naive shift
	            ndiffs.splice(cursor_pointer, 2, d_next, d);
	            return merge_tuples$1$3(ndiffs, cursor_pointer, 2);
	        }
	        else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {
	            // Case 2)
	            // d[1] is a prefix of d_next[1]
	            // We can assume that d_next[0] !== 0, since d[0] === 0
	            // Shift edit locations..
	            ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);
	            var suffix = d_next[1].slice(d[1].length);
	            if (suffix.length > 0) {
	                ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);
	            }
	            return merge_tuples$1$3(ndiffs, cursor_pointer, 3);
	        }
	        else {
	            // Not possible to perform any modification
	            return diffs;
	        }
	    }
	}
	/*
	 * Check diff did not split surrogate pairs.
	 * Ex. [0, '\uD83D'], [-1, '\uDC36'], [1, '\uDC2F'] -> [-1, '\uD83D\uDC36'], [1, '\uD83D\uDC2F']
	 *     '\uD83D\uDC36' === '🐶', '\uD83D\uDC2F' === '🐯'
	 *
	 * @param {Array} diffs Array of diff tuples
	 * @return {Array} Array of diff tuples
	 */
	function fix_emoji$1$3(diffs) {
	    var compact = false;
	    var starts_with_pair_end = function (str) {
	        return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;
	    };
	    var ends_with_pair_start = function (str) {
	        return str.charCodeAt(str.length - 1) >= 0xD800 && str.charCodeAt(str.length - 1) <= 0xDBFF;
	    };
	    for (var i = 2; i < diffs.length; i += 1) {
	        if (diffs[i - 2][0] === DIFF_EQUAL$1$3 && ends_with_pair_start(diffs[i - 2][1]) &&
	            diffs[i - 1][0] === DIFF_DELETE$1$3 && starts_with_pair_end(diffs[i - 1][1]) &&
	            diffs[i][0] === DIFF_INSERT$1$3 && starts_with_pair_end(diffs[i][1])) {
	            compact = true;
	            diffs[i - 1][1] = diffs[i - 2][1].slice(-1) + diffs[i - 1][1];
	            diffs[i][1] = diffs[i - 2][1].slice(-1) + diffs[i][1];
	            diffs[i - 2][1] = diffs[i - 2][1].slice(0, -1);
	        }
	    }
	    if (!compact) {
	        return diffs;
	    }
	    var fixed_diffs = [];
	    for (var i = 0; i < diffs.length; i += 1) {
	        if (diffs[i][1].length > 0) {
	            fixed_diffs.push(diffs[i]);
	        }
	    }
	    return fixed_diffs;
	}
	/*
	 * Try to merge tuples with their neigbors in a given range.
	 * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']
	 *
	 * @param {Array} diffs Array of diff tuples.
	 * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).
	 * @param {Int} length Number of consecutive elements to check.
	 * @return {Array} Array of merged diff tuples.
	 */
	function merge_tuples$1$3(diffs, start, length) {
	    // Check from (start-1) to (start+length).
	    for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {
	        if (i + 1 < diffs.length) {
	            var left_d = diffs[i];
	            var right_d = diffs[i + 1];
	            if (left_d[0] === right_d[1]) {
	                diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);
	            }
	        }
	    }
	    return diffs;
	}

	function shallowEqual$1$3(valueA, valueB) {
	    return valueEqual$1$3(valueA, valueB, strictEqual$1$3);
	}
	function deepEqual$1$3(valueA, valueB) {
	    return valueEqual$1$3(valueA, valueB, valueEqual$1$3);
	}
	function strictEqual$1$3(valueA, valueB) {
	    return valueA === valueB;
	}
	function valueEqual$1$3(valueA, valueB, propEqual) {
	    if (valueA === valueB)
	        return true;
	    if (valueA instanceof Date && valueB instanceof Date)
	        return valueA.getTime() === valueB.getTime();
	    if (!valueA || !valueB || typeof valueA !== 'object' && typeof valueB !== 'object')
	        return valueA === valueB;
	    return objectEqual$1$3(valueA, valueB, propEqual);
	}
	function objectEqual$1$3(objA, objB, propEqual) {
	    if (objA.prototype !== objB.prototype)
	        return false;
	    var keysA = Object.keys(objA);
	    var keysB = Object.keys(objB);
	    if (keysA.length !== keysB.length)
	        return false;
	    return keysA.every(function (key, i) { return key === keysB[i] && propEqual(objA[key], objB[key], propEqual); });
	}

	var NULL_CHARACTER$1$3 = String.fromCharCode(0); // Placeholder char for embed in diff()
	var Delta$1$3 = /** @class */ (function () {
	    function Delta(ops) {
	        if (ops === void 0) { ops = []; }
	        this.ops = ops;
	    }
	    /**
	     * Appends an insert operation. Returns this for chainability.
	     *
	     * @param {String|Object} text Represents text or embed to insert
	     * @param {Object} attributes Optional attributes to apply
	     */
	    Delta.prototype.insert = function (text, attributes) {
	        var newOp = {};
	        if (text.length === 0)
	            return this;
	        newOp.insert = text;
	        if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
	            newOp.attributes = attributes;
	        }
	        return this._push(newOp);
	    };
	    /**
	     * Appends a delete operation. Returns this for chainability.
	     *
	     * @param {Number} length Number of characters to delete
	     */
	    Delta.prototype["delete"] = function (length) {
	        if (length <= 0)
	            return this;
	        return this._push({ "delete": length });
	    };
	    /**
	     * Appends a retain operation. Returns this for chainability.
	     *
	     * @param {Number} length Number of characters to retain
	     * @param {Object} attributes Optional attributes to apply
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.retain = function (length, attributes) {
	        if (length <= 0)
	            return this;
	        var newOp = { retain: length };
	        if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {
	            newOp.attributes = attributes;
	        }
	        return this._push(newOp);
	    };
	    /**
	     * Freezes delta from future modifications. Returns this for chainability.
	     *
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.freeze = function () {
	        var _this = this;
	        this._push = function () { return _this; };
	        return this;
	    };
	    /**
	     * Adds a new operation. Returns this for chainability.
	     *
	     * @param {Object} newOp A new operation
	     * @returns {Delta} This delta
	     */
	    Delta.prototype._push = function (newOp) {
	        var index = this.ops.length;
	        var lastOp = this.ops[index - 1];
	        if (typeof lastOp === 'object') {
	            if (typeof newOp["delete"] === 'number' && typeof lastOp["delete"] === 'number') {
	                this.ops[index - 1] = { "delete": lastOp["delete"] + newOp["delete"] };
	                return this;
	            }
	            // Since it does not matter if we insert before or after deleting at the same index,
	            // always prefer to insert first
	            if (typeof lastOp["delete"] === 'number' && newOp.insert != null) {
	                index -= 1;
	                lastOp = this.ops[index - 1];
	                if (typeof lastOp !== 'object') {
	                    this.ops.unshift(newOp);
	                    return this;
	                }
	            }
	            if (deepEqual$1$3(newOp.attributes, lastOp.attributes)) {
	                if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {
	                    this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };
	                    if (typeof newOp.attributes === 'object')
	                        this.ops[index - 1].attributes = newOp.attributes;
	                    return this;
	                }
	                else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {
	                    this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };
	                    if (typeof newOp.attributes === 'object')
	                        this.ops[index - 1].attributes = newOp.attributes;
	                    return this;
	                }
	            }
	        }
	        if (index === this.ops.length) {
	            this.ops.push(newOp);
	        }
	        else {
	            this.ops.splice(index, 0, newOp);
	        }
	        return this;
	    };
	    /**
	     * Chops off trailing retain instructions to make the delta concise.
	     *
	     * @returns {Delta} This delta
	     */
	    Delta.prototype.chop = function () {
	        var lastOp = this.ops[this.ops.length - 1];
	        if (lastOp && lastOp.retain && !lastOp.attributes) {
	            this.ops.pop();
	        }
	        return this;
	    };
	    /**
	     * Returns an iterator to iterate over the operations of this delta.
	     *
	     * @returns {Iterator} An operation iterator with methods hasNext, next, peek, peekLength, & peekType
	     */
	    Delta.prototype.iterator = function () {
	        return new Iterator$1$3(this.ops);
	    };
	    /**
	     * Returns an array of operations that passes a given function.
	     *
	     * @param {Function} predicate Function to test each operation against. Return true to keep the operation, false
	     *                             otherwise
	     * @returns {Array} Filtered resulting array
	     */
	    Delta.prototype.filter = function (predicate) {
	        return this.ops.filter(predicate);
	    };
	    /**
	     * Iterates through operations, calling the provided function for each operation.
	     *
	     * @param {Function} predicate Function to call during iteration, passing in the current operation
	     */
	    Delta.prototype.forEach = function (predicate) {
	        this.ops.forEach(predicate);
	    };
	    /**
	     * Returns a new array with the results of calling provided function on each operation.
	     *
	     * @param {Function} predicate Function to call, passing in the current operation, returning an element of the new
	     *                             array to be returned
	     * @returns {Array} A new array with each element being the result of the given function
	     */
	    Delta.prototype.map = function (predicate) {
	        return this.ops.map(predicate);
	    };
	    /**
	     * Create an array of two arrays, the first with operations that pass the given function, the other that failed.
	     *
	     * @param {Function} predicate Function to call, passing in the current operation, returning whether that operation
	     *                             passed
	     * @returns {Array} A new array of two Arrays, the first with passed operations, the other with failed operations
	     */
	    Delta.prototype.partition = function (predicate) {
	        var passed = [], failed = [];
	        this.forEach(function (op) {
	            var target = predicate(op) ? passed : failed;
	            target.push(op);
	        });
	        return [passed, failed];
	    };
	    /**
	     * Applies given function against an accumulator and each operation to reduce to a single value.
	     *
	     * @param {Function} predicate Function to call per iteration, returning an accumulated value
	     * @param {*} initial Initial value to pass to first call to predicate
	     * @returns {*} The accumulated value
	     */
	    Delta.prototype.reduce = function (predicate, initial) {
	        return this.ops.reduce(predicate, initial);
	    };
	    Delta.prototype.changeLength = function () {
	        return this.reduce(function (length, entry) {
	            if (entry.insert) {
	                return length + getOpLength$1$3(entry);
	            }
	            else if (entry["delete"]) {
	                return length - entry["delete"];
	            }
	            return length;
	        }, 0);
	    };
	    /**
	     * Returns length of a Delta, which is the sum of the lengths of its operations.
	     *
	     * @returns {Number} The length of this delta
	     */
	    Delta.prototype.length = function () {
	        return this.reduce(function (length, entry) {
	            return length + getOpLength$1$3(entry);
	        }, 0);
	    };
	    /**
	     * Returns copy of delta with subset of operations.
	     *
	     * @param {Number} start Start index of subset, defaults to 0
	     * @param {Number} end End index of subset, defaults to rest of operations
	     * @returns {Array} An array slice of the operations
	     */
	    Delta.prototype.slice = function (start, end) {
	        if (start === void 0) { start = 0; }
	        if (typeof end !== 'number')
	            end = Infinity;
	        var ops = [];
	        var iter = this.iterator();
	        var index = 0;
	        while (index < end && iter.hasNext()) {
	            var nextOp;
	            if (index < start) {
	                nextOp = iter.next(start - index);
	            }
	            else {
	                nextOp = iter.next(end - index);
	                ops.push(nextOp);
	            }
	            index += getOpLength$1$3(nextOp);
	        }
	        return new Delta(ops);
	    };
	    /**
	     * Returns a Delta that is equivalent to applying the operations of own Delta, followed by another Delta.
	     *
	     * @param {Delta} other Delta to compose
	     */
	    Delta.prototype.compose = function (other) {
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        var delta = new Delta();
	        while (thisIter.hasNext() || otherIter.hasNext()) {
	            if (otherIter.peekType() === 'insert') {
	                delta._push(otherIter.next());
	            }
	            else if (thisIter.peekType() === 'delete') {
	                delta._push(thisIter.next());
	            }
	            else {
	                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
	                var thisOp = thisIter.next(length);
	                var otherOp = otherIter.next(length);
	                if (typeof otherOp.retain === 'number') {
	                    var newOp = {};
	                    if (typeof thisOp.retain === 'number') {
	                        newOp.retain = length;
	                    }
	                    else {
	                        newOp.insert = thisOp.insert;
	                    }
	                    // Preserve null when composing with a retain, otherwise remove it for inserts
	                    var attributes = composeAttributes$1$3(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');
	                    if (attributes)
	                        newOp.attributes = attributes;
	                    delta._push(newOp);
	                    // Optimization if rest of other is just retain
	                    if (!otherIter.hasNext() && deepEqual$1$3(delta.ops[delta.ops.length - 1], newOp)) {
	                        var rest = new Delta(thisIter.rest());
	                        return delta.concat(rest).chop();
	                    }
	                    // Other op should be delete, we could be an insert or retain
	                    // Insert + delete cancels out
	                }
	                else if (typeof otherOp["delete"] === 'number' && typeof thisOp.retain === 'number') {
	                    delta._push(otherOp);
	                }
	            }
	        }
	        return delta.chop();
	    };
	    /**
	     * Returns a new Delta representing the concatenation of this and another document Delta's operations.
	     *
	     * @param {Delta} other Document Delta to concatenate
	     * @returns {Delta} Concatenated document Delta
	     */
	    Delta.prototype.concat = function (other) {
	        var delta = new Delta(this.ops.slice());
	        if (other.ops.length > 0) {
	            delta._push(other.ops[0]);
	            delta.ops = delta.ops.concat(other.ops.slice(1));
	        }
	        return delta;
	    };
	    /**
	     * Returns a Delta representing the difference between two documents. Optionally, accepts a suggested index where
	     * change took place, often representing a cursor position before change.
	     *
	     * @param {Delta} other Document Delta to diff against
	     * @param {Number} index Suggested index where change took place
	     * @returns {Delta} Difference between the two documents
	     */
	    Delta.prototype.diff = function (other, index) {
	        if (this.ops === other.ops) {
	            return new Delta();
	        }
	        var strings = [this, other].map(function (delta) {
	            return delta.map(function (op) {
	                if (op.insert != null) {
	                    return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER$1$3;
	                }
	                var prep = (delta === other) ? 'on' : 'with';
	                throw new Error('diff() called ' + prep + ' non-document');
	            }).join('');
	        });
	        var delta = new Delta();
	        var diffResult = diff$1$3(strings[0], strings[1], index);
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        diffResult.forEach(function (component) {
	            var length = component[1].length;
	            while (length > 0) {
	                var opLength = 0;
	                switch (component[0]) {
	                    case diff$1$3.INSERT:
	                        opLength = Math.min(otherIter.peekLength(), length);
	                        delta._push(otherIter.next(opLength));
	                        break;
	                    case diff$1$3.DELETE:
	                        opLength = Math.min(length, thisIter.peekLength());
	                        thisIter.next(opLength);
	                        delta["delete"](opLength);
	                        break;
	                    case diff$1$3.EQUAL:
	                        opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
	                        var thisOp = thisIter.next(opLength);
	                        var otherOp = otherIter.next(opLength);
	                        if (deepEqual$1$3(thisOp.insert, otherOp.insert)) {
	                            delta.retain(opLength, diffAttributes$1$3(thisOp.attributes, otherOp.attributes));
	                        }
	                        else {
	                            delta._push(otherOp)["delete"](opLength);
	                        }
	                        break;
	                }
	                length -= opLength;
	            }
	        });
	        return delta.chop();
	    };
	    /**
	     * Iterates through document Delta, calling a given function with a Delta and attributes object, representing the line
	     * segment.
	     *
	     * @param {Function} predicate Function to call on each line group
	     * @param {String} newline Newline character, defaults to \n
	     */
	    Delta.prototype.eachLine = function (predicate, newline) {
	        if (newline === void 0) { newline = '\n'; }
	        var iter = this.iterator();
	        var ops = new Delta();
	        var index = 0;
	        var lineStart = 0;
	        var currentIndex = 0;
	        while (iter.hasNext()) {
	            if (iter.peekType() !== 'insert')
	                return;
	            var op = iter.peek();
	            var nextLength = iter.peekLength();
	            var start = getOpLength$1$3(op) - nextLength;
	            var newlineIndex = typeof op.insert === 'string' ? op.insert.indexOf(newline, start) - start : -1;
	            if (newlineIndex < 0) {
	                currentIndex += nextLength;
	                ops._push(iter.next());
	            }
	            else if (newlineIndex > 0) {
	                currentIndex += newlineIndex;
	                ops._push(iter.next(newlineIndex));
	            }
	            else {
	                currentIndex += 1;
	                var attributes = iter.next(1).attributes || {};
	                var line = { ops: ops, attributes: attributes, start: lineStart, end: currentIndex, index: index };
	                if (predicate(line, index) === false) {
	                    return;
	                }
	                index += 1;
	                lineStart = currentIndex;
	                ops = new Delta();
	            }
	        }
	        if (ops.length() > 0) {
	            var line_1 = { ops: ops, attributes: {}, start: lineStart, end: currentIndex, index: index };
	            predicate(line_1, index);
	        }
	    };
	    // Extends Delta, get the lines from `from` to `to`.
	    Delta.prototype.getLines = function (from, to, newline) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = Infinity; }
	        var lines = [];
	        this.eachLine(function (line) {
	            if (line.start > to || (line.start === to && from !== to))
	                return false;
	            if (line.end > from) {
	                lines.push(line);
	            }
	        }, newline);
	        return lines;
	    };
	    // Extends Delta, get the line at `at`.
	    Delta.prototype.getLine = function (at, newline) {
	        return this.getLines(at, at, newline)[0];
	    };
	    // Extends Delta, get the ops from `from` to `to`.
	    Delta.prototype.getOps = function (from, to) {
	        var start = 0;
	        var ops = [];
	        this.ops.some(function (op) {
	            if (start >= to)
	                return true;
	            var end = start + getOpLength$1$3(op);
	            if (end > from || (from === to && end === to)) {
	                ops.push({ op: op, start: start, end: end });
	            }
	            start = end;
	        });
	        return ops;
	    };
	    // Extends Delta, get the op at `at`.
	    Delta.prototype.getOp = function (at) {
	        return this.getOps(at, at)[0];
	    };
	    /**
	     * Transform given Delta against own operations. Used as an alias for transformPosition when called with a number.
	     *
	     * @param {Delta} other Delta to transform
	     * @param {Boolean} priority Boolean used to break ties. If true, then this takes priority over other, that is, its
	     *                           actions are considered to happen "first."
	     * @returns {Delta} Transformed Delta
	     */
	    Delta.prototype.transform = function (other, priority) {
	        if (priority === void 0) { priority = false; }
	        if (typeof other === 'number') {
	            return this.transformPosition(other, priority);
	        }
	        var thisIter = this.iterator();
	        var otherIter = other.iterator();
	        var delta = new Delta();
	        while (thisIter.hasNext() || otherIter.hasNext()) {
	            if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {
	                delta.retain(getOpLength$1$3(thisIter.next()));
	            }
	            else if (otherIter.peekType() === 'insert') {
	                delta._push(otherIter.next());
	            }
	            else {
	                var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
	                var thisOp = thisIter.next(length);
	                var otherOp = otherIter.next(length);
	                if (thisOp["delete"]) {
	                    // Our delete either makes their delete redundant or removes their retain
	                    continue;
	                }
	                else if (otherOp["delete"]) {
	                    delta._push(otherOp);
	                }
	                else {
	                    // We retain either their retain or insert
	                    delta.retain(length, transformAttributes$1$3(thisOp.attributes, otherOp.attributes, priority));
	                }
	            }
	        }
	        return delta.chop();
	    };
	    /**
	     * Transform an index against the delta. Useful for representing cursor/selection positions.
	     *
	     * @param {Number} index Index to transform
	     * @param {Boolean} priority Boolean used to break ties. If true, then this takes priority over other, that is, its
	     *                           actions are considered to happen "first."
	     * @returns {Number} Transformed index
	     */
	    Delta.prototype.transformPosition = function (index, priority) {
	        if (priority === void 0) { priority = false; }
	        var thisIter = this.iterator();
	        var offset = 0;
	        while (thisIter.hasNext() && offset <= index) {
	            var length = thisIter.peekLength();
	            var nextType = thisIter.peekType();
	            thisIter.next();
	            if (nextType === 'delete') {
	                index -= Math.min(length, index - offset);
	                continue;
	            }
	            else if (nextType === 'insert' && (offset < index || !priority)) {
	                index += length;
	            }
	            offset += length;
	        }
	        return index;
	    };
	    return Delta;
	}());
	/**
	 * Create an attributes object that is equivalent to applying the attributes of the target followed by the source.
	 *
	 * @param {Object} target Target attributes object which will have the source applied to
	 * @param {Object} source Source attributes object being applied to the target
	 * @param {Boolean} keepNull Whether to keep null values from source
	 * @returns {Object} A new attributes object (or undefined if empty) with both
	 */
	function composeAttributes$1$3(target, source, keepNull) {
	    if (target === void 0) { target = {}; }
	    if (source === void 0) { source = {}; }
	    var attributes = __assign$2$2({}, target, source);
	    if (!keepNull)
	        Object.keys(attributes).forEach(function (key) {
	            if (attributes[key] == null)
	                delete attributes[key];
	        });
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Finds the difference between two attributes objects. Returns the source attributes that are different from the
	 * target attributes.
	 *
	 * @param {Object} target An attributes object
	 * @param {Object} source An attributes object
	 * @returns {Object} The difference between the two attribute objects or undefined if there is none
	 */
	function diffAttributes$1$3(target, source) {
	    if (target === void 0) { target = {}; }
	    if (source === void 0) { source = {}; }
	    var attributes = Object.keys(target).concat(Object.keys(source)).reduce(function (attributes, key) {
	        if (!deepEqual$1$3(target[key], source[key])) {
	            attributes[key] = source[key] === undefined ? null : source[key];
	        }
	        return attributes;
	    }, {});
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Transforms the attributes of source over target (or the other way around if priority is set). Will return an
	 * attributes object which has all the values from source if priority if false or will have the values from source that
	 * are set on target.
	 *
	 * @param {Object} target An attributes object
	 * @param {Object} source An attributes object
	 * @param {Boolean} priority If target has priority over source
	 */
	function transformAttributes$1$3(target, source, priority) {
	    if (typeof target !== 'object')
	        return source;
	    if (typeof source !== 'object')
	        return undefined;
	    if (!priority)
	        return source; // b simply overwrites us without priority
	    var attributes = Object.keys(source).reduce(function (attributes, key) {
	        if (target[key] === undefined)
	            attributes[key] = source[key]; // null is a valid value
	        return attributes;
	    }, {});
	    return Object.keys(attributes).length > 0 ? attributes : undefined;
	}
	/**
	 * Determines the length of a Delta operation.
	 *
	 * @param {Object} op An operation entry from a Delta object
	 * @returns {Number} The length of the op
	 */
	function getOpLength$1$3(op) {
	    if (typeof op["delete"] === 'number') {
	        return op["delete"];
	    }
	    else if (typeof op.retain === 'number') {
	        return op.retain;
	    }
	    else {
	        return typeof op.insert === 'string' ? op.insert.length : 1;
	    }
	}
	/**
	 * An iterator to handle iterating over a list of Delta operations efficiently.
	 */
	var Iterator$1$3 = /** @class */ (function () {
	    function Iterator(ops) {
	        this.ops = ops;
	        this.index = 0;
	        this.offset = 0;
	    }
	    /**
	     * Determine if there will be another operation returned by `next`.
	     *
	     * @returns {Boolean} Whether there are more operations to iterate over
	     */
	    Iterator.prototype.hasNext = function () {
	        return this.peekLength() < Infinity;
	    };
	    /**
	     * Get the next operation, optionally limited/sliced by length. If an operation is sliced by length, the next call to
	     * `next` will return more of that operation until it is returned in full.
	     *
	     * @param {Number} length Optionally limit the returned operation by length, slicing it down as needed
	     */
	    Iterator.prototype.next = function (length) {
	        if (length === void 0) { length = Infinity; }
	        var nextOp = this.ops[this.index];
	        if (!nextOp)
	            return { retain: Infinity };
	        var offset = this.offset;
	        var opLength = getOpLength$1$3(nextOp);
	        // Update index and offset
	        if (length >= opLength - offset) {
	            length = opLength - offset;
	            this.index += 1;
	            this.offset = 0;
	        }
	        else {
	            this.offset += length;
	        }
	        if (typeof nextOp["delete"] === 'number') {
	            return { "delete": length };
	        }
	        else {
	            var retOp = {};
	            if (nextOp.attributes) {
	                retOp.attributes = nextOp.attributes;
	            }
	            if (typeof nextOp.retain === 'number') {
	                retOp.retain = length;
	            }
	            else if (typeof nextOp.insert === 'string') {
	                retOp.insert = nextOp.insert.substr(offset, length);
	            }
	            else {
	                // offset should === 0, length should === 1
	                retOp.insert = nextOp.insert;
	            }
	            return retOp;
	        }
	    };
	    /**
	     * Return the next entry.
	     *
	     * @returns {Object} The next entry in the ops array.
	     */
	    Iterator.prototype.peek = function () {
	        return this.ops[this.index];
	    };
	    /**
	     * Check the length of the next entry.
	     *
	     * @returns {Number} The length of the next entry or Infinity if there is no next entry
	     */
	    Iterator.prototype.peekLength = function () {
	        if (this.ops[this.index]) {
	            // Should never return 0 if our index is being managed correctly
	            return getOpLength$1$3(this.ops[this.index]) - this.offset;
	        }
	        else {
	            return Infinity;
	        }
	    };
	    /**
	     * Check the type of the next entry, delete, retain, or insert.
	     *
	     * @returns {String} The type of the next entry
	     */
	    Iterator.prototype.peekType = function () {
	        if (this.ops[this.index]) {
	            if (typeof this.ops[this.index]["delete"] === 'number') {
	                return 'delete';
	            }
	            else if (typeof this.ops[this.index].retain === 'number') {
	                return 'retain';
	            }
	            else {
	                return 'insert';
	            }
	        }
	        return 'retain';
	    };
	    Iterator.prototype.rest = function () {
	        if (!this.hasNext()) {
	            return [];
	        }
	        else if (this.offset === 0) {
	            return this.ops.slice(this.index);
	        }
	        else {
	            var offset = this.offset;
	            var index = this.index;
	            var next = this.next();
	            var rest = this.ops.slice(this.index);
	            this.offset = offset;
	            this.index = index;
	            return [next].concat(rest);
	        }
	    };
	    return Iterator;
	}());

	var SOURCE_API$1$3 = 'api';
	var SOURCE_USER$1$4 = 'user';
	var SOURCE_SILENT$1$3 = 'silent';
	var empty$1$3 = {};
	/**
	 * Event for text changes, called before the change has occurred. If a listener returns false the change will be
	 * canceled and not committed.
	 *
	 * @event Editor#text-changing
	 * @type  {Object}
	 * @property {Delta} change       The change which is being applied to the content
	 * @property {Delta} content      The new content after the change
	 * @property {Delta} oldContent   The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * Event for text changes, called after the change has occurred.
	 *
	 * @event Editor#text-change
	 * @type  {Object}
	 * @property {Delta} change       The change which is being applied to the content
	 * @property {Delta} content      The new content after the change
	 * @property {Delta} oldContent   The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * Event for selection changes. If part of a text change the `change`, `content`, and `oldContent` properties will be
	 * set. Otherwise they will not be set.
	 *
	 * @event Editor#selection-change
	 * @type  {Object}
	 * @property {Delta} change       [ Optional ] The change which is being applied to the content
	 * @property {Delta} content      [ Optional ] The new content after the change
	 * @property {Delta} oldContent   [ Optional ] The old content before the change
	 * @property {Array} seleciton    The selection after the change
	 * @property {Array} oldSelection The selection before the change
	 * @property {String} source      The source of the change, api, user, or silent
	 */
	/**
	 * A Typewriter Editor handles the logic for selection and editing of contents. It has no dependency on browser APIs
	 * and can be used in Node.js as easily as the browser. It has no logic to limit formatting (i.e. it does not disallow
	 * using bold, headers, links, or FOOBAR), that will need to be limited outside of the editor itself.
	 *
	 * @fires Editor#text-changing
	 * @fires Editor#text-change
	 * @fires Editor#selection-change
	 *
	 * @readonly @property {Delta}  contents      The data model for the text editor
	 * @readonly @property {Number} length        The length of the contents
	 * @readonly @property {String} text          The text of the contents
	 * @readonly @property {Array}  selection     The current editor selection, a tuple of `[ from, to ]` or `null`
	 * @readonly @property {Object} activeFormats The currently active formats (formats that will apply on the next insert)
	 */
	var Editor$1$3 = /** @class */ (function (_super) {
	    __extends$2$1(Editor, _super);
	    /**
	     * Create a new Typewriter editor.
	     *
	     * @param {Object} options Options for this editor include initial `contents` and `modules`:
	     * @param {Delta}  options.contents The initial contents of this editor
	     */
	    function Editor(options) {
	        if (options === void 0) { options = {}; }
	        var _this = _super.call(this) || this;
	        _this.contents = null;
	        _this.length = 0;
	        _this.selection = null;
	        _this.activeFormats = empty$1$3;
	        setContents$1$3(_this, options.contents || _this.delta().insert('\n'));
	        _this._queuedEvents = []; // Event queuing ensure they are fired in order
	        return _this;
	    }
	    /**
	     * Convenience method for creating a new delta.
	     *
	     * @param {Array} ops [Optional] The initial ops for the delta
	     * @returns {Delta}   A new Delta object
	     */
	    Editor.prototype.delta = function (ops) {
	        return new Delta$1$3(ops);
	    };
	    /**
	     * Returns the contents or a slice of them.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {Delta}     The contents of this editor
	     */
	    Editor.prototype.getContents = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.contents.slice(from, to);
	    };
	    /**
	     * Returns the text for the editor or a slice of it.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {String}    The text in the editor
	     */
	    Editor.prototype.getText = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length - 1; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.getContents(from, to)
	            .filter(function (op) { return typeof op.insert === 'string'; })
	            .map(function (op) { return op.insert; })
	            .join('');
	    };
	    /**
	     * Returns the text for the editor with null characters in place of embeds. This can be used to determine the index of
	     * given words or lines of text within the contents.
	     *
	     * @param {Number} from The starting index
	     * @param {Number} to   The ending index
	     * @returns {String}    The text in the editor with embed spaces
	     */
	    Editor.prototype.getExactText = function (from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = this.length - 1; }
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        return this.getContents(from, to)
	            .map(function (op) { return typeof op.insert === 'string' ? op.insert : '\0'; })
	            .join('');
	    };
	    /**
	     * Set the selection to a new location (or null for no selection). Will return false if the new selection is the same
	     * as the old selection. Dispatches "selection-change" once the selection is changed. This "selection-change" event
	     * won't have { contents, oldContnts, change } in it since the selection is changing without any content updates.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Boolean}        Whether the selection changed or not
	     */
	    Editor.prototype.setSelection = function (from, to, source) {
	        var _this = this;
	        if (source === void 0) { source = SOURCE_USER$1$4; }
	        var _a;
	        var oldSelection = this.selection;
	        var selection;
	        if (from === null) {
	            selection = null;
	            if (typeof to === 'string')
	                source = to;
	        }
	        else {
	            _a = this._normalizeSelection(from, to, source), from = _a[0], to = _a[1], source = _a[2];
	            selection = [from, to].map(function (i) { return Math.min(i, _this.length - 1); });
	        }
	        if (shallowEqual$1$3(oldSelection, selection))
	            return false;
	        // Reset the active formats when selection changes (do this before setting selection)
	        this.activeFormats = selection ? this.getTextFormat(Math.min(selection[0], selection[1])) : empty$1$3;
	        this.selection = selection;
	        var event = { selection: selection, oldSelection: oldSelection, source: source };
	        if (source !== SOURCE_SILENT$1$3)
	            this.fire('selection-change', event);
	        this.fire('editor-change', event);
	        return true;
	    };
	    /**
	     * The method that all other methods use to update the contents (even setContents & setText). This method will
	     * dispatch the event "text-changing". If a listener returns `false` then the change will be canceled and null will
	     * be returned. Otherwise, the change will be successful and if the `source` is not "silent" a "text-change" event
	     * will be fired with an event object containing `{ contents, oldContents, selection, oldSelection, source }`. If the
	     * selection has changed as part of this update a "selection-change" event will also be fired with the same event
	     * object.
	     *
	     * @param {Delta} change    A delta change to the document
	     * @param {String} source   The source of the change, user, api, or silent
	     * @param {Array} selection Optional selection after the change has been applied
	     * @returns {Delta}         Returns the change when successful, or null if not
	     */
	    Editor.prototype.updateContents = function (change, source, selection) {
	        if (source === void 0) { source = SOURCE_API$1$3; }
	        if (!change.chop().ops.length)
	            return null;
	        if (typeof selection === 'number')
	            selection = [selection, selection];
	        var oldContents = this.contents;
	        var contents = normalizeContents$1$3(oldContents.compose(change));
	        var length = contents.length();
	        var oldSelection = this.selection;
	        if (!selection)
	            selection = oldSelection ? oldSelection.map(function (i) { return change.transform(i); }) : oldSelection;
	        selection = selection && this.getSelectedRange(selection, length - 1);
	        var changeEvent = { contents: contents, oldContents: oldContents, change: change, selection: selection, oldSelection: oldSelection, source: source };
	        var selectionChanged = !shallowEqual$1$3(oldSelection, selection);
	        if (!this.fire('text-changing', changeEvent))
	            return null;
	        setContents$1$3(this, contents);
	        if (selection) {
	            // Reset the active formats when selection changes (do this before setting selection)
	            this.activeFormats = selection ? this.getTextFormat(Math.min(selection[0], selection[1])) : empty$1$3;
	            this.selection = selection;
	        }
	        var events = [];
	        if (source !== SOURCE_SILENT$1$3) {
	            events.push(['text-change', changeEvent]);
	            if (selectionChanged)
	                events.push(['selection-change', changeEvent]);
	        }
	        events.push(['editor-change', changeEvent]);
	        this._queueEvents(events);
	        return change;
	    };
	    /**
	     * Sets the entire contents of the editor. This will calculate the difference between the old content and the new and
	     * only apply the difference, if any.
	     *
	     * @param {Delta} newContents The contents of the editor, as a delta object
	     * @param {String} source     The source of the change, user, api, or silent
	     * @param {Array} selection   Optional selection after the change has been applied
	     * @returns {Delta}           Returns the change when successful, or null if not
	     */
	    Editor.prototype.setContents = function (newContents, source, selection) {
	        var change = this.contents.diff(normalizeContents$1$3(newContents));
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Sets the text content of the editor, removing existing contents and formatting.
	     *
	     * @param {String} text     Set the contents of this editor as text
	     * @param {String} source   The source of the change, user, api, or silent
	     * @param {Array} selection Optional selection after the change has been applied
	     * @returns {Delta}         Returns the change when successful, or null if not
	     */
	    Editor.prototype.setText = function (text, source, selection) {
	        return this.setContents(this.delta().insert(text + '\n'), source, selection);
	    };
	    /**
	     * Inserts text into the content of the editor, removing text between from and to if provided. If `text` is a newline
	     * ("\n") then the formats will apply to the line, otherwise they will apply to the text only (even if there are
	     * newlines in the text).
	     *
	     * @param {Number} from      Insert the text at this index, can also be a range Array tuple, default 0
	     * @param {Number} to        If provided and not equal to `from` will delete the text between `from` and `to`
	     * @param {String} text      The text to insert into the editor's contents
	     * @param {Object} formats   The formats of the inserted text. If null the formats at `from` will be used.
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.insertText = function (from, to, text, formats, source, selection) {
	        var _a, _b, _c;
	        _a = this._normalizeRange(from, to, text, formats, source, selection), from = _a[0], to = _a[1], text = _a[2], formats = _a[3], source = _a[4], selection = _a[5];
	        // If we are not inserting a newline, make sure from and to are within the selectable range
	        if (text !== '\n')
	            _b = this.getSelectedRange([from, to]), from = _b[0], to = _b[1];
	        if (typeof formats === 'string')
	            _c = [null, formats, source], formats = _c[0], source = _c[1], selection = _c[2];
	        if (selection == null && this.selection !== null)
	            selection = from + text.length;
	        var change = this.delta().retain(from)["delete"](to - from);
	        if (text === '\n') {
	            change.insert('\n', formats || this.getLineFormat(from));
	        }
	        else {
	            var lineFormat_1 = text.indexOf('\n') === -1 ? null : this.getLineFormat(from);
	            var textFormat_1 = formats || this.getTextFormat(from);
	            text.split('\n').forEach(function (line, i) {
	                if (i)
	                    change.insert('\n', lineFormat_1);
	                line.length && change.insert(line, textFormat_1);
	            });
	        }
	        change = cleanDelete$1$3(this, from, to, change);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Inserts an embed into the content of the editor, removing text between from and to if provided.
	     *
	     * @param {Number} from      Insert the embed at this index, can also be a range Array tuple, default 0
	     * @param {Number} to        If provided and not equal to `from` will delete the text between `from` and `to`
	     * @param {String} embed     Insert the text into the editor's contents
	     * @param {mixed}  value     Insert the text into the editor's contents
	     * @param {String} formats   The formats of the inserted text. If null the formats at `from` will be used.
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.insertEmbed = function (from, to, embed, value, formats, source, selection) {
	        var _a, _b, _c;
	        _a = this._normalizeRange(from, to, embed, value, source, selection), from = _a[0], to = _a[1], embed = _a[2], value = _a[3], source = _a[4], selection = _a[5];
	        if (typeof formats === 'string')
	            _b = [null, formats, source], formats = _b[0], source = _b[1], selection = _b[2];
	        if (from >= this.length)
	            from = this.length - 1;
	        if (to >= this.length)
	            to = this.length - 1;
	        if (selection == null && this.selection !== null)
	            selection = from + 1;
	        var textFormat = formats || this.getTextFormat(from);
	        var change = this.delta().retain(from)["delete"](to - from).insert((_c = {}, _c[embed] = value, _c), textFormat);
	        change = cleanDelete$1$3(this, from, to, change);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Deletes text from `from` to `to`.
	     *
	     * @param {Number} from      Insert the text as this index, can also be a range Array tuple, default 0
	     * @param {Number} to        Will delete the text between `from` and `to`
	     * @param {String} source    The source of the change, user, api, or silent
	     * @param {Array}  selection Optional selection after the change has been applied
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.deleteText = function (from, to, source, selection) {
	        var _a;
	        _a = this._normalizeRange(from, to, source, selection), from = _a[0], to = _a[1], source = _a[2], selection = _a[3];
	        if (from === to)
	            return null;
	        if (selection == null && this.selection !== null)
	            selection = from;
	        var change = this.delta().retain(from)["delete"](to - from);
	        change = cleanDelete$1$3(this, from, to, change);
	        // Keep the active format of the text to the right of the cursor when deleting
	        var activeFormats;
	        if (selection === from)
	            activeFormats = this.getTextFormat(from, from + 1);
	        var result = this.updateContents(change, source, selection);
	        if (result && activeFormats)
	            this.activeFormats = activeFormats;
	        return result;
	    };
	    /**
	     * Get the line formats for the line that `from` is in to the line that `to` is in. Returns only the common formats
	     * between all the lines. If `from` equals `to` (or `to` is not provided) the formats will be all of those for the
	     * line `from` is on. If two lines are touched and they have different formats, an empty object will be returned.
	     *
	     * @param {Number} from Getting line formats starting at `from`
	     * @param {Number} to   Getting line formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the lines which intersect from and to
	     */
	    Editor.prototype.getLineFormat = function (from, to) {
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        var formats;
	        this.contents.getLines(from, to).forEach(function (line) {
	            if (!line.attributes)
	                formats = {};
	            else if (!formats)
	                formats = __assign$2$2({}, line.attributes);
	            else
	                formats = combineFormats$1$3(formats, line.attributes);
	        });
	        return formats;
	    };
	    /**
	     * Get the text formats for all the text from `from` to `to`. Returns only the common formats between the two indexes.
	     * Will also return the `activeFormats`. Active formats are those which are toggled on when the selection is collapsed
	     * (from and to are equal) indicating inserted text should use (or not use) those formats.
	     *
	     * @param {Number} from Getting text formats starting at `from`
	     * @param {Number} to   Getting text formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the text
	     */
	    Editor.prototype.getTextFormat = function (from, to) {
	        var _a;
	        _a = this._normalizeRange(from, to), from = _a[0], to = _a[1];
	        var formats;
	        // optimize for current selection
	        var seleciton = this.selection;
	        if (from === to && shallowEqual$1$3(this.selection, [from, to])) {
	            return this.activeFormats;
	        }
	        this.contents.getOps(from, to).forEach(function (_a) {
	            var op = _a.op;
	            if (/^\n+$/.test(op.insert))
	                return;
	            if (!op.attributes)
	                formats = {};
	            else if (!formats)
	                formats = __assign$2$2({}, op.attributes);
	            else
	                formats = combineFormats$1$3(formats, op.attributes);
	        });
	        if (!formats)
	            formats = {};
	        return formats;
	    };
	    /**
	     * Get the text and line formats for all the lines and text from `from` to `to`.
	     *
	     * @param {Number} from Getting line and text formats starting at `from`
	     * @param {Number} to   Getting line and text formats ending at `to`
	     * @returns {Object}    An object with all the common formats among the lines and text which intersect from and to
	     */
	    Editor.prototype.getFormat = function (from, to) {
	        return __assign$2$2({}, this.getTextFormat(from, to), this.getLineFormat(from, to));
	    };
	    /**
	     * Formats the lines intersected by `from` and `to` with the given line formats. To remove an existing format pass in
	     * `null` or `false` to turn it off (e.g. `{ blockquote: false }`).
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the line
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.formatLine = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var change = this.delta();
	        this.contents.getLines(from, to).forEach(function (line) {
	            if (!change.ops.length)
	                change.retain(line.end - 1);
	            else
	                change.retain(line.end - line.start - 1);
	            // Clear out old formats on the line
	            Object.keys(line.attributes).forEach(function (name) { return !formats[name] && (formats[name] = null); });
	            change.retain(1, formats);
	        });
	        change.chop();
	        return change.ops.length ? this.updateContents(change, source) : null;
	    };
	    /**
	     * Formats the text from `from` to `to` with the given text formats. To remove an existing format pass in `null` or
	     * `false` to turn it off (e.g. `{ bold: false }`).
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the text
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.formatText = function (from, to, formats, source) {
	        var _this = this;
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        if (from === to) {
	            if (this.activeFormats === empty$1$3)
	                this.activeFormats = {};
	            Object.keys(formats).forEach(function (key) {
	                var value = formats[key];
	                if (value == null || value === false)
	                    delete _this.activeFormats[key];
	                else
	                    _this.activeFormats[key] = value;
	            });
	            return;
	        }
	        Object.keys(formats).forEach(function (name) { return formats[name] === false && (formats[name] = null); });
	        var change = this.delta().retain(from);
	        this.getText(from, to).split('\n').forEach(function (line) {
	            line.length && change.retain(line.length, formats);
	            change.retain(1);
	        });
	        change.chop();
	        return this.updateContents(change, source);
	    };
	    /**
	     * Toggles the line formats from `from` to `to` with the given line formats. If the line has the exact formats already
	     * they will be removed, otherwise they will be added.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the line
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.toggleLineFormat = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var existing = this.getLineFormat(from, to);
	        if (deepEqual$1$3(existing, formats)) {
	            Object.keys(formats).forEach(function (key) { return formats[key] = null; });
	        }
	        return this.formatLine(from, to, formats, source);
	    };
	    /**
	     * Toggles the text formats from `from` to `to` with the given text formats. If the text has the exact formats already
	     * they will be removed, otherwise they will be added.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {Object} formats   The formats for the text
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.toggleTextFormat = function (from, to, formats, source) {
	        var _a;
	        _a = this._normalizeRange(from, to, formats, source), from = _a[0], to = _a[1], formats = _a[2], source = _a[3];
	        var existing = this.getTextFormat(from, to);
	        var isSame = Object.keys(formats).every(function (key) { return formats[key] === existing[key]; });
	        if (isSame) {
	            Object.keys(formats).forEach(function (key) { return formats[key] = null; });
	        }
	        return this.formatText(from, to, formats, source);
	    };
	    /**
	     * Removes all formatting, text and line formats, for the text and lines from `from` to `to`.
	     *
	     * @param {Number} from      The starting index
	     * @param {Number} to        The ending index
	     * @param {String} source    The source of the change, user, api, or silent
	     * @returns {Delta}          Returns the change when successful, or null if not
	     */
	    Editor.prototype.removeFormats = function (from, to, source) {
	        var _this = this;
	        var _a;
	        _a = this._normalizeRange(from, to, source), from = _a[0], to = _a[1], source = _a[2];
	        var formats = {};
	        this.contents.getOps(from, to).forEach(function (_a) {
	            var op = _a.op;
	            op.attributes && Object.keys(op.attributes).forEach(function (key) { return formats[key] = null; });
	        });
	        var change = this.delta().retain(from).retain(to - from, formats);
	        // If the last block was not captured be sure to clear that too
	        this.contents.getLines(from, to).forEach(function (line) {
	            var formats = {};
	            Object.keys(line.attributes).forEach(function (key) { return formats[key] = null; });
	            change = change.compose(_this.delta().retain(line.end - 1).retain(1, formats));
	        });
	        return this.updateContents(change, source);
	    };
	    /**
	     * Create a change delta calling one or more methods on the editor. The changes will not be applied as normal but will
	     * be collated into a single change delta and returned from this methnod. Example:
	     * ```js
	     * var change = editor.getChange(function() {
	     *   editor.deleteText(0, 5);
	     *   editor.insertText('\n', { blockquote: true });
	     *   editor.formatText(10, 20, { bold: true });
	     * });
	     *
	     * editor.updateContents(change, 'user');
	     * ```
	     *
	     * @param {Function} producer A function in which to call methods on the editor to produce a change
	     * @returns {Delta}           The sum of all the changes made within the producer
	     */
	    Editor.prototype.getChange = function (producer) {
	        var change = this.delta();
	        this.updateContents = function (singleChange) {
	            if (singleChange.ops.length) {
	                change = change.compose(singleChange);
	                return singleChange;
	            }
	            else {
	                return null;
	            }
	        };
	        producer(this);
	        delete this.updateContents;
	        return change;
	    };
	    /**
	     * Make several changes to the editor apply all at one in one commit. Changes made with the transaction will be
	     * applied all together and the "text-changing", "text-change", and "selection-change" events will be dispatched only
	     * once. Use this to combine multiple changes into one.
	     *
	     * @param {Function} producer A function which should make changes with the editor
	     * @param {String} source     The source of the change, user, api, or silent
	     * @param {Array} selection   Optional selection after the change has been applied
	     * @returns {Delta}           Returns the change when successful, or null if not
	     */
	    Editor.prototype.transaction = function (producer, source, selection) {
	        var change = this.getChange(producer);
	        return this.updateContents(change, source, selection);
	    };
	    /**
	     * Returns the selected range (or the provided range) in index order (lowest number first) and within the bounds of
	     * the content, between 0 and content.length() - 1 (the selection cannot be past the trailing newline).
	     *
	     * @param {Array} range Optional range, defaults to current selection
	     * @param {Number} max  The maxium number the range can be
	     */
	    Editor.prototype.getSelectedRange = function (range, max) {
	        if (range === void 0) { range = this.selection; }
	        if (max === void 0) { max = this.length - 1; }
	        var _a;
	        if (range == null)
	            return range;
	        if (typeof range === 'number')
	            range = [range, range];
	        if (range[0] > range[1])
	            _a = [range[1], range[0]], range[0] = _a[0], range[1] = _a[1];
	        return range.map(function (index) { return Math.max(0, Math.min(max, index)); });
	    };
	    Editor.prototype._queueEvents = function (events) {
	        var _a;
	        var alreadyRunning = this._queuedEvents.length;
	        (_a = this._queuedEvents).push.apply(_a, events);
	        if (alreadyRunning)
	            return;
	        while (this._queuedEvents.length) {
	            var event = this._queuedEvents.shift();
	            this.fire.apply(this, event);
	        }
	    };
	    /**
	     * Normalizes range values to a proper range if it is not already. A range is a `from` and a `to` index, e.g. 0, 4.
	     * This will ensure the lower index is first. Example usage:
	     * editor._normalizeRange(5); // [5, 5]
	     * editor._normalizeRange(-4, 100); // for a doc with length 10, [0, 10]
	     * editor._normalizeRange(25, 18); // [18, 25]
	     * editor._normalizeRange([12, 13]); // [12, 13]
	     * editor._normalizeRange(5, { bold: true }); // [5, 5, { bold: true }]
	     */
	    Editor.prototype._normalizeRange = function (from, to) {
	        var rest = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            rest[_i - 2] = arguments[_i];
	        }
	        var _a;
	        _a = this._normalizeSelection.apply(this, [from, to].concat(rest)), from = _a[0], to = _a[1], rest = _a.slice(2);
	        if (from > to) {
	            var toValue = from;
	            from = to;
	            to = toValue;
	        }
	        return [from, to].concat(rest);
	    };
	    Editor.prototype._normalizeSelection = function (from, to) {
	        var rest = [];
	        for (var _i = 2; _i < arguments.length; _i++) {
	            rest[_i - 2] = arguments[_i];
	        }
	        var _a;
	        if (Array.isArray(from)) {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            _a = from, from = _a[0], to = _a[1];
	            if (to === undefined)
	                to = from;
	        }
	        else if (typeof from !== 'number') {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            if (from !== undefined || rest.length)
	                rest.unshift(from);
	            from = to = 0;
	        }
	        else if (typeof to !== 'number') {
	            if (to !== undefined || rest.length)
	                rest.unshift(to);
	            to = from;
	        }
	        from = Math.max(0, Math.min(this.length, Math.floor(from)));
	        to = Math.max(0, Math.min(this.length, Math.floor(to)));
	        return [from, to].concat(rest);
	    };
	    return Editor;
	}(EventDispatcher$1$3));
	// Ensures the format for the current line in a delete remains the same when multiple lines are deleted. This is needed
	// because the last line holds the formatting after a delete, but the first line is expected to be the retained format
	function cleanDelete$1$3(editor, from, to, change) {
	    if (from !== to) {
	        var line = editor.contents.getLine(from);
	        if (!line.ops.length() && to === from + 1)
	            return change;
	        var lineFormat_2 = editor.getLineFormat(from);
	        if (!deepEqual$1$3(lineFormat_2, editor.getLineFormat(to))) {
	            var lineChange = editor.getChange(function () { return editor.formatLine(to, lineFormat_2); });
	            change = change.compose(change.transform(lineChange));
	        }
	    }
	    return change;
	}
	// Ensures contents end with a newline
	function normalizeContents$1$3(contents) {
	    // Contents only have inserts. Deletes and retains belong to changes only.
	    contents.ops = contents.ops.filter(function (op) { return op.insert; });
	    var lastOp = contents.ops[contents.ops.length - 1];
	    if (!lastOp || typeof lastOp.insert !== 'string' || lastOp.insert.slice(-1) !== '\n')
	        contents.insert('\n');
	    return contents;
	}
	// Sets the contents onto the editor after ensuring they end in a newline, freezes the contents from change, and
	// updates the length and text of the editor to the latest
	function setContents$1$3(editor, contents) {
	    contents = normalizeContents$1$3(contents);
	    contents.freeze();
	    editor.contents = contents;
	    editor.length = contents.length();
	}
	// Combine formats removing ones that don't exist in both and creating an array for those with multiple values
	function combineFormats$1$3(formats, combined) {
	    return Object.keys(combined).reduce(function (merged, name) {
	        if (formats[name] == null)
	            return merged;
	        if (combined[name] === formats[name]) {
	            merged[name] = combined[name];
	        }
	        else if (Array.isArray(combined[name])) {
	            if (combined[name].indexOf(formats[name]) < 0) {
	                merged[name] = combined[name].concat([formats[name]]);
	            }
	        }
	        else {
	            merged[name] = [combined[name], formats[name]];
	        }
	        return merged;
	    }, {});
	}

	var SKIP_ELEMENTS$1 = { STYLE: true, SCRIPT: true, LINK: true, META: true, TITLE: true };
	var BLOCK_ELEMENTS$1 = 'address, article, aside, blockquote, canvas, dd, div, dl, dt, fieldset, figcaption, figure, footer, form, header, hr, li, main, nav, noscript, ol, output, p, pre, section, table, tfoot, ul, video';
	var defaultOptions$2 = { notInDom: false };
	function deltaFromDom$1(root, paper, options) {
	    if (options === void 0) { options = {}; }
	    var _a, _b;
	    var inDom = root.ownerDocument.contains(root);
	    var blocks = paper.blocks, marks = paper.marks, embeds = paper.embeds;
	    if (!options)
	        options = defaultOptions$2;
	    var walker = root.ownerDocument.createTreeWalker(root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, {
	        acceptNode: function (node) {
	            if (SKIP_ELEMENTS$1[node.nodeName]) {
	                return NodeFilter.FILTER_REJECT;
	            }
	            else if (node.nodeType === Node.TEXT_NODE && node.nodeValue === '') {
	                node.nodeType === Node.TEXT_NODE;
	            }
	            else if (node.nodeType === Node.TEXT_NODE || options.notInDom || inDom) {
	                return NodeFilter.FILTER_ACCEPT;
	            }
	            else {
	                return NodeFilter.FILTER_REJECT;
	            }
	        }
	    });
	    var delta = new Delta$1$3();
	    var currentBlock, firstBlockSeen = false, unknownBlock = false, empty = true, node;
	    var lastNode = false;
	    if (options.startNode) {
	        walker.currentNode = options.startNode;
	        walker.previousNode();
	        if (options.offset)
	            delta.retain(options.offset, undefined);
	    }
	    else {
	        walker.currentNode = root;
	    }
	    while ((node = walker.nextNode())) {
	        if (node === options.endNode)
	            lastNode = true;
	        else if (lastNode)
	            break;
	        if (isBRPlaceholder$3(paper, node)) {
	            empty = false;
	        }
	        else if (node.nodeType === Node.TEXT_NODE) {
	            var parent = node.parentNode;
	            // If all newlines, we can ignore
	            if (node.nodeValue.replace(/\n+/g, '') === '')
	                continue;
	            // non-breaking spaces (&nbsp;) are spaces in a delta
	            var text = node.nodeValue.replace(/\xA0/g, ' ').replace(/\n+/g, ' ');
	            // Word gives us end-of-paragraph nodes with a single space. Ignore them.
	            if (!text || (text === ' ' && parent.classList.contains('EOP')))
	                continue;
	            // Gather up all the marks for this text node, walking up to the block level
	            var attributes = gatherMarks$1(parent, root, paper);
	            empty = false;
	            delta.insert(text, attributes);
	        }
	        else if (node.className.indexOf('decorator') !== -1) {
	            continue;
	        }
	        else if (embeds.matches(node)) {
	            var embed = embeds.findByNode(node);
	            if (embed) {
	                var attributes = gatherMarks$1(node.parentNode, root, paper);
	                delta.insert((_a = {}, _a[embed.name] = embed.fromDom ? embed.fromDom(node, paper) : true, _a), attributes);
	            }
	        }
	        else if (blocks.matches(node) || (node.nodeType === Node.ELEMENT_NODE && node.matches(BLOCK_ELEMENTS$1))) {
	            unknownBlock = !blocks.matches(node);
	            if (unknownBlock) {
	                var parent = node.parentNode;
	                while (parent && !blocks.matches(parent) && parent !== root) {
	                    parent = parent.parentNode;
	                }
	                // If this block element is inside a recognized block, ignore it
	                if (parent && parent !== root) {
	                    continue;
	                }
	            }
	            var block = blocks.findByNode(node, true);
	            // Skip paragraphs/divs inside blockquotes and list items etc.
	            if (block === blocks.getDefault() && blocks.matches(node.parentNode)) {
	                continue;
	            }
	            if (firstBlockSeen) {
	                if (!currentBlock.unknownBlock || !empty) {
	                    delta.insert('\n', currentBlock.unknownBlock ? {} : currentBlock);
	                    empty = true;
	                }
	            }
	            else {
	                firstBlockSeen = true;
	            }
	            if (unknownBlock) {
	                currentBlock = { unknownBlock: unknownBlock };
	            }
	            else if (block !== blocks.getDefault()) {
	                currentBlock = block.fromDom ? block.fromDom(node, paper) : (_b = {}, _b[block.name] = true, _b);
	            }
	            else {
	                currentBlock = {};
	            }
	        }
	    }
	    // Delta documents should always end with a newline, unless they are partial documents
	    if (!unknownBlock || !empty) {
	        delta.insert('\n', currentBlock);
	    }
	    return delta;
	}
	// Walk up the DOM to the closest parent, finding marks
	function gatherMarks$1(parent, root, paper) {
	    var blocks = paper.blocks, marks = paper.marks;
	    var attributes = {};
	    while (parent && !blocks.matches(parent) && parent !== root) {
	        if (marks.matches(parent)) {
	            var mark = marks.findByNode(parent);
	            if (mark.name !== 'decorator') {
	                attributes[mark.name] = mark.fromDom ? mark.fromDom(parent, paper) : true;
	            }
	        }
	        else if (parent.hasAttribute('style')) {
	            marks.list.forEach(function (mark) {
	                if (mark.styleSelector && parent.matches(mark.styleSelector)) {
	                    attributes[mark.name] = mark.fromDom ? mark.fromDom(parent, paper) : true;
	                }
	            });
	        }
	        parent = parent.parentNode;
	    }
	    return attributes;
	}

	// export function deltaToHTML(delta, paper) {
	//  // Try https://www.npmjs.com/package/quill-delta-to-html
	// }
	/**
	 * Converts an HTML string into a delta object based off of the supplied Paper definition.
	 */
	function deltaFromHTML(paper, html) {
	    var template = document.createElement('template');
	    template.innerHTML = '<div>' + html + '</div>';
	    return deltaFromDom$1(template.content.firstChild, paper, { notInDom: true });
	}
	var isMac$4 = navigator.userAgent.indexOf('Macintosh') !== -1;

	function decorate$1(root, contents) {
	    var decorators = new Decorators$1(contents);
	    root.dispatchEvent(new CustomEvent('decorate', { detail: decorators }));
	    var change = decorators.getChange();
	    if (change.ops.length) {
	        change.forEach(function (op) {
	            if (op["delete"] || (op.retain && op.attributes && !op.attributes.decorator) || (op.insert && !op.insert.decorator)) {
	                throw new Error('Decorators may not insert text or delete contents.');
	            }
	        });
	        contents = contents.compose(change);
	    }
	    return contents;
	}
	var Decorators$1 = /** @class */ (function () {
	    function Decorators(contents) {
	        this.contents = contents;
	        this.change;
	        this.delta = new Delta$1$3();
	        this.position = 0;
	    }
	    Decorators.prototype.mark = function (from, to, attributes) {
	        var _a;
	        _a = this.updatePosition(from, to), from = _a[0], to = _a[1];
	        var length = to - from;
	        this.delta.retain(length, { decorator: attributes });
	        this.position += length;
	    };
	    Decorators.prototype.embed = function (at, attributes) {
	        at = this.updatePosition(at);
	        this.delta.insert({ decorator: attributes });
	        this.position += 1;
	    };
	    Decorators.prototype.getChange = function () {
	        return this.change ? this.change.compose(this.delta) : this.delta;
	    };
	    Decorators.prototype.updatePosition = function (from, to) {
	        if (this.change) {
	            from = this.change.transformPosition(from);
	            if (to != null)
	                to = this.change.transformPosition(to);
	        }
	        // Optimize by adding to the existing delta when possible, compose is slow
	        if (this.position < from) {
	            this.delta.retain(from - this.position);
	            this.position = from;
	        }
	        else if (this.position) {
	            this.change = this.getChange();
	            from = this.change.transformPosition(from);
	            if (to != null)
	                to = this.change.transformPosition(to);
	            this.delta = new Delta$1$3();
	            this.delta.retain(from);
	            this.position = from;
	        }
	        return to != null ? [from, to] : from;
	    };
	    return Decorators;
	}());

	var indexOf$2 = [].indexOf;
	// Get the range (a tuple of indexes) for this view from the browser selection
	function getSelection$2(root, paper, range) {
	    var selection = !range ? root.ownerDocument.getSelection() : {
	        anchorNode: range.startContainer, anchorOffset: range.startOffset,
	        focusNode: range.endContainer, focusOffset: range.endOffset,
	        isCollapsed: range.collapsed
	    };
	    if (!root.contains(selection.anchorNode)) {
	        return null;
	    }
	    else {
	        var anchorIndex = getNodeAndOffsetIndex$2(root, paper, selection.anchorNode, selection.anchorOffset);
	        var isCollapsed = selection.anchorNode === selection.focusNode && selection.anchorOffset === selection.focusOffset;
	        // selection.isCollapsed causes a layout on Chrome. ?? Manual detection does not.
	        var focusIndex = isCollapsed ?
	            anchorIndex :
	            getNodeAndOffsetIndex$2(root, paper, selection.focusNode, selection.focusOffset);
	        return [anchorIndex, focusIndex];
	    }
	}
	// Set the browser selection to the range (a tuple of indexes) of this view
	function setSelection$1(root, paper, range) {
	    var selection = root.ownerDocument.getSelection();
	    var hasFocus = selection.anchorNode && root.contains(selection.anchorNode);
	    if (range == null) {
	        if (hasFocus) {
	            root.blur();
	            selection.removeAllRanges();
	        }
	    }
	    else {
	        var _a = getNodesForRange$2(root, paper, range), anchorNode = _a[0], anchorOffset = _a[1], focusNode = _a[2], focusOffset = _a[3];
	        var type = range[0] === range[1] ? 'Caret' : 'Range';
	        if (anchorNode && focusNode) {
	            if (selection.anchorNode !== anchorNode || selection.anchorOffset !== anchorOffset ||
	                selection.focusNode !== focusNode || selection.focusOffset !== focusOffset || selection.type !== type) {
	                selection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);
	            }
	        }
	        if (!hasFocus)
	            root.focus();
	    }
	}
	/**
	 * Get the position and size of a range as it is displayed in the DOM relative to the top left of visible document.
	 * You can use `getBounds(editor.selection)` to find the coordinates of the current selection and display a popup at
	 * that location.
	 */
	function getBounds$2(root, paper, range) {
	    return getBoudingBrowserRange$2(root, paper, range).getBoundingClientRect();
	}
	/**
	 * Get all positions and sizes of a range as it is displayed in the DOM relative to the top left of visible document.
	 * This is different from `getBounds` because instead of a single bounding box you may get multiple rects such as when
	 * the selection is split across lines. You can use `getAllBounds` to draw a highlight behind the text within this
	 * range.
	 *
	 * @param {Number} from The start of the range
	 * @param {Number} to   The end of the range
	 * @returns {DOMRectList}   A native DOMRect object with the bounds of the range
	 */
	function getAllBounds(root, paper, range) {
	    return getBoudingBrowserRange$2(root, paper, range).getClientRects();
	}
	function getBoudingBrowserRange$2(root, paper, range) {
	    var browserRange = getBrowserRange$2(root, paper, range);
	    if (browserRange.endContainer.nodeType === Node.ELEMENT_NODE) {
	        try {
	            browserRange.setEnd(browserRange.endContainer, browserRange.endOffset + 1);
	        }
	        catch (e) { }
	    }
	    return browserRange;
	}
	// Get a browser range object for the given editor range tuple
	function getBrowserRange$2(root, paper, range) {
	    if (range[0] > range[1])
	        range = [range[1], range[0]];
	    var _a = getNodesForRange$2(root, paper, range), anchorNode = _a[0], anchorOffset = _a[1], focusNode = _a[2], focusOffset = _a[3];
	    var browserRange = document.createRange();
	    if (anchorNode && focusNode) {
	        browserRange.setStart(anchorNode, anchorOffset);
	        browserRange.setEnd(focusNode, focusOffset);
	    }
	    return browserRange;
	}
	// Get the browser nodes and offsets for the range (a tuple of indexes) of this view
	function getNodesForRange$2(root, paper, range) {
	    if (range == null) {
	        return [null, 0, null, 0];
	    }
	    else {
	        var _a = getNodeAndOffset$2(root, paper, range[0]), anchorNode = _a[0], anchorOffset = _a[1];
	        var _b = range[0] === range[1] ?
	            [anchorNode, anchorOffset] : getNodeAndOffset$2(root, paper, range[1]), focusNode = _b[0], focusOffset = _b[1];
	        return [anchorNode, anchorOffset, focusNode, focusOffset];
	    }
	}
	function getNodeAndOffset$2(root, paper, index) {
	    var inDom = root.ownerDocument.contains(root);
	    var blocks = paper.blocks, embeds = paper.embeds;
	    var walker = root.ownerDocument.createTreeWalker(root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, {
	        acceptNode: inDom ? acceptNodeInDom$3 : acceptNode$3
	    });
	    var count = 0, node, firstBlockSeen = false;
	    walker.currentNode = root;
	    while ((node = walker.nextNode())) {
	        if (node.nodeType === Node.TEXT_NODE) {
	            var size = node.nodeValue.length;
	            if (index <= count + size)
	                return [node, index - count];
	            count += size;
	        }
	        else if (node.className.indexOf('decorator') !== -1) {
	            continue;
	        }
	        else if (embeds.matches(node) && !isBRPlaceholder$3(paper, node)) {
	            count += 1;
	            // If the selection lands after this embed, and the next node isn't a text node, place the selection
	            var next = nextNonEmptyTextSibling$2(node);
	            if (count === index && (!next || next.nodeType !== Node.TEXT_NODE)) {
	                return [node.parentNode, indexOf$2.call(node.parentNode.childNodes, node) + 1];
	            }
	        }
	        else if (blocks.matches(node)) {
	            if (firstBlockSeen)
	                count += 1;
	            else
	                firstBlockSeen = true;
	            // If the selection lands at the beginning of a block, and the first node isn't a text node, place the selection
	            if (count === index) {
	                var first = firstNonEmptyTextChild$2(node);
	                if (!first)
	                    return [node, 0];
	                else if (first.nodeType !== Node.TEXT_NODE)
	                    return [node, indexOf$2.call(node.childNodes, first)];
	            }
	        }
	    }
	    return [null, 0];
	}
	function getNodeAndOffsetIndex$2(root, paper, node, offset) {
	    if (node.nodeType === Node.ELEMENT_NODE && offset > 0) {
	        node = node.childNodes[offset - 1];
	        offset = node.nodeType === Node.ELEMENT_NODE ? 0 : node.nodeValue.length;
	    }
	    return getNodeIndex$2(root, paper, node) + offset;
	}
	// Get the index the node starts at in the content
	function getNodeIndex$2(root, paper, node) {
	    var inDom = root.ownerDocument.contains(root);
	    var blocks = paper.blocks, embeds = paper.embeds;
	    var walker = root.ownerDocument.createTreeWalker(root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, {
	        acceptNode: inDom ? acceptNodeInDom$3 : acceptNode$3
	    });
	    walker.currentNode = node;
	    var index = node.nodeType === Node.ELEMENT_NODE ? 0 : -1;
	    while ((node = walker.previousNode())) {
	        if (node === root)
	            continue;
	        else if (node.nodeType === Node.TEXT_NODE)
	            index += node.nodeValue.length;
	        else if (node.className.indexOf('decorator') !== -1)
	            ;
	        else if (embeds.matches(node) && !isBRPlaceholder$3(paper, node))
	            index++;
	        else if (blocks.matches(node))
	            index++;
	    }
	    return index;
	}
	function acceptNode$3(node) {
	    if (node.nodeType === Node.TEXT_NODE) {
	        return node.nodeValue.length ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
	    }
	    return NodeFilter.FILTER_REJECT;
	}
	function acceptNodeInDom$3(node) {
	    if (node.nodeType === Node.TEXT_NODE) {
	        return node.nodeValue.length ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
	    }
	    return NodeFilter.FILTER_ACCEPT;
	}
	function firstNonEmptyTextChild$2(parent) {
	    var node = parent.firstChild;
	    if (!node)
	        return null;
	    while (node && node.nodeValue === '') {
	        node = node.nextSibling;
	    }
	    return node;
	}
	function nextNonEmptyTextSibling$2(node) {
	    var nextSibling = node.nextSibling;
	    while (nextSibling && nextSibling.nodeValue === '') {
	        nextSibling = nextSibling.nextSibling;
	    }
	    return nextSibling;
	}

	// Based off of https://github.com/jorgebucaran/ultradom/ MIT licensed

	function h(name, attributes) {
	  var rest = [];
	  var children = [];
	  var length = arguments.length;

	  while (length-- > 2) rest.push(arguments[length]);

	  while (rest.length) {
	    var node = rest.pop();
	    if (node && node.pop) {
	      for (length = node.length; length--; ) {
	        rest.push(node[length]);
	      }
	    } else if (node != null && node !== true && node !== false) {
	      children.push(node);
	    }
	  }

	  return typeof name === "function"
	    ? name(attributes || {}, children)
	    : {
	        name,
	        attributes: attributes || {},
	        children: children
	      };
	}

	function renderChildren(children, element) {
	  patchChildren(element, children);
	}


	function clone(target, source) {
	  var obj = {};

	  for (var i in target) obj[i] = target[i];
	  for (var i in source) obj[i] = source[i];

	  return obj;
	}

	function eventListener(event) {
	  return event.currentTarget.events[event.type](event);
	}

	function updateAttribute(element, name, value, isSvg) {
	  if (name[0] === "o" && name[1] === "n") {
	    if (!element.events) {
	      element.events = {};
	    }
	    name = name.slice(2);
	    const oldValue = element.events[name];
	    element.events[name] = value;
	    if (value) {
	      if (!oldValue) {
	        element.addEventListener(name, eventListener);
	      }
	    } else {
	      element.removeEventListener(name, eventListener);
	    }
	  } else if (name in element && name !== "list" && !isSvg) {
	    element[name] = value == null ? "" : value;
	  } else if (value != null && value !== false) {
	    element.setAttribute(name, value === true ? '' : value);
	  }

	  if (value == null || value === false) {
	    element.removeAttribute(name);
	  }
	}

	function createElement(node, isSvg) {
	  var element =
	    typeof node === "string" || typeof node === "number"
	      ? document.createTextNode(node)
	      : (isSvg = isSvg || node.name === "svg")
	        ? document.createElementNS(
	            "http://www.w3.org/2000/svg",
	            node.name
	          )
	        : document.createElement(node.name);

	  var attributes = node.attributes;
	  if (attributes) {
	    for (var i = 0; i < node.children.length; i++) {
	      element.appendChild(createElement(node.children[i], isSvg));
	    }

	    for (var name in attributes) {
	      updateAttribute(element, name, attributes[name], isSvg);
	    }
	  }

	  return element;
	}

	function getElementAttributes(element, isSvg) {
	  var attributes = {};
	  for (var i = 0; i < element.attributes.length; i++) {
	    var { name, value } = element.attributes[i];
	    if (name in element && name !== "list" && !isSvg) {
	      attributes[name] = element[name];
	    } else {
	      attributes[name] = value === '' ? true : value;
	    }
	  }
	  return attributes;
	}

	function updateElement(element, attributes, isSvg) {
	  var oldAttributes = getElementAttributes(element);
	  for (var name in clone(oldAttributes, attributes)) {
	    if (
	      attributes[name] !==
	      (name === "value" || name === "checked"
	        ? element[name]
	        : oldAttributes[name])
	    ) {
	      updateAttribute(
	        element,
	        name,
	        attributes[name],
	        isSvg
	      );
	    }
	  }
	}

	function removeElement(parent, element) {
	  parent.removeChild(element);
	}

	function patchChildren(element, children, isSvg) {
	  var i = 0;

	  while (i < children.length) {
	    patch(element, element.childNodes[i], children[i], isSvg);
	    i++;
	  }

	  while (i < element.childNodes.length) {
	    removeElement(element, element.childNodes[i]);
	  }
	}

	function patch(parent, element, node, isSvg) {
	  var name = element && element.nodeName !== '#text' ? element.nodeName.toLowerCase() : undefined;
	  if (element == null || name !== node.name) {
	    var newElement = createElement(node, isSvg);

	    if (parent) {
	      parent.insertBefore(newElement, element);
	      if (element != null) {
	        removeElement(parent, element);
	      }
	    }

	    element = newElement;
	  } else if (name == null) {
	    if (element.nodeValue !== node) element.nodeValue = node;
	  } else {
	    updateElement(
	      element,
	      node.attributes,
	      (isSvg = isSvg || node.name === "svg")
	    );

	    patchChildren(element, node.children, isSvg);
	  }
	  return element;
	}

	/*!
	 * escape-html
	 * Copyright(c) 2012-2013 TJ Holowaychuk
	 * Copyright(c) 2015 Andreas Lubbe
	 * Copyright(c) 2015 Tiancheng "Timothy" Gu
	 * MIT Licensed
	 */

	const matchHtmlRegExp = /["'&<>]/;

	/**
	 * Escape special characters in the given string of html.
	 *
	 * @param  {string} string The string to escape for inserting into HTML
	 * @return {string}
	 * @public
	 */

	function escapeHtml(string) {
	  var str = '' + string;
	  var match = matchHtmlRegExp.exec(str);

	  if (!match) {
	    return str;
	  }

	  var escape;
	  var html = '';
	  var index = 0;
	  var lastIndex = 0;

	  for (index = match.index; index < str.length; index++) {
	    switch (str.charCodeAt(index)) {
	      case 34: // "
	        escape = '&quot;';
	        break;
	      case 38: // &
	        escape = '&amp;';
	        break;
	      case 39: // '
	        escape = '&#39;';
	        break;
	      case 60: // <
	        escape = '&lt;';
	        break;
	      case 62: // >
	        escape = '&gt;';
	        break;
	      default:
	        continue;
	    }

	    if (lastIndex !== index) {
	      html += str.substring(lastIndex, index);
	    }

	    lastIndex = index + 1;
	    html += escape;
	  }

	  return lastIndex !== index
	    ? html + str.substring(lastIndex, index)
	    : html;
	}

	const paragraph$1 = (attr, children) => h('p', null, children);

	const header$1 = (attr, children) => h(`h${attr.header}`, null, children);

	const list$1 = lists => {
	  const topLevelChildren = [];
	  const levels = [];
	  // e.g. levels = [ul, ul]

	  lists.forEach(([attr, children]) => {
	    const name = attr.list === 'ordered' ? 'ol' : 'ul';
	    const index = attr.indent || 0;
	    const item = h('li', null, children);

	    while (index >= levels.length) {
	      const newLevel = h(name, { start: attr.start, type: attr. type });
	      const childrenArray = levels.length ? levels[levels.length - 1].children : topLevelChildren;
	      const lastChild = childrenArray[childrenArray.length - 1];
	      if (lastChild && lastChild.name === 'li') {
	        lastChild.children.push(newLevel);
	      } else {
	        childrenArray.push(newLevel);
	      }
	      levels.push(newLevel);
	    }

	    if (!compare$1(levels[index], name, attr)) {
	      const newLevel = h(name, { start: attr.start, type: attr. type });
	      const childrenArray = index ? levels[index - 1].children : topLevelChildren;
	      childrenArray.push(newLevel);
	      levels[index] = newLevel;
	    }

	    levels[index].children.push(item);

	    levels.length = index + 1;
	  });

	  return topLevelChildren;
	};

	const blockquote$1 = quotes => h('blockquote', null, quotes.map(([attr, children]) => h('p', null, children)));

	const codeblock$1 = lines => h('pre', null, lines.map(([attr, children]) => [children, '\n']));

	const hr$1 = () => h('hr');

	list$1.rendersMultiple = true;
	blockquote$1.rendersMultiple = true;
	codeblock$1.rendersMultiple = true;

	function compare$1(list, name, attrs) {
	  return list.name === name
	    && (list.attributes.start === attrs.start
	        || (list.attributes.start && !attrs.start))
	    && list.attributes.type === attrs.type;
	}

	var blocks = /*#__PURE__*/Object.freeze({
	    paragraph: paragraph$1,
	    header: header$1,
	    list: list$1,
	    blockquote: blockquote$1,
	    codeblock: codeblock$1,
	    hr: hr$1
	});

	const bold$1 = (attr, children) => h('strong', null, children);

	const italic$1 = (attr, children) => h('em', null, children);

	const code$1 = (attr, children) => h('code', null, children);

	const link$1 = (attr, children) => h('a', { href: attr.link, target: '_blank' }, children);

	const decorator$1 = (attr, children) => {
	  const attrs = { ...attr.decorator };
	  attrs.class = attrs.class ? attrs.class + ' decorator' : 'decorator';
	  return h('span', attrs, children);
	};

	var marks = /*#__PURE__*/Object.freeze({
	    bold: bold$1,
	    italic: italic$1,
	    code: code$1,
	    link: link$1,
	    decorator: decorator$1
	});

	const image$1 = embed => {
	  const { image, ...attrs } = embed;
	  attrs.src = image;
	  return h('img', attrs);
	};

	const br$1 = () => h('br');

	var embeds = /*#__PURE__*/Object.freeze({
	    image: image$1,
	    br: br$1
	});

	var components$1 = {};
	function registerComponent$1(name, component, rendersMultiple) {
	    if (rendersMultiple != null)
	        component.rendersMultiple = rendersMultiple;
	    components$1[name] = component;
	}
	function getComponent$1(name) {
	    return components$1[name];
	}
	// Register the default components
	var all = __assign$5({}, blocks, marks, embeds);
	Object.keys(all).forEach(function (name) { return registerComponent$1(name, all[name]); });

	var nodeMarks = new WeakMap();
	var BR = h('br');
	var VOID_ELEMENTS = {
	    area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true,
	    link: true, meta: true, param: true, source: true, track: true, wbr: true
	};
	function deltaToVdom(delta, paper) {
	    var blocks = paper.blocks, marks = paper.marks, embeds = paper.embeds;
	    var blockData = [];
	    delta.eachLine(function (_a) {
	        var ops = _a.ops, attributes = _a.attributes;
	        var inlineChildren = [];
	        // Collect block children
	        ops.forEach(function (op, i, array) {
	            if (op.insert) {
	                var children_1 = [];
	                if (typeof op.insert === 'string') {
	                    var prev = array[i - 1];
	                    var next = array[i + 1];
	                    var text = op.insert.replace(/  /g, '\xA0 ');
	                    if (!prev)
	                        text = text.replace(/^ /, '\xA0');
	                    if (!next || (typeof next.insert === 'string' && next.insert[0] === ' '))
	                        text = text.replace(/ $/, '\xA0');
	                    children_1.push(text);
	                }
	                else {
	                    var embed = embeds.findByAttributes(op.insert);
	                    var component = void 0;
	                    if (embed && (component = getComponent$1(embed.name))) {
	                        var node = component(op.insert);
	                        children_1.push(node);
	                    }
	                }
	                if (op.attributes) {
	                    // Sort them by the order found in marks and be efficient
	                    Object.keys(op.attributes).sort(function (a, b) { return marks.priority(b) - marks.priority(a); }).forEach(function (name) {
	                        var mark = marks.get(name);
	                        var component;
	                        if (mark && (component = getComponent$1(mark.name))) {
	                            var node = component(op.attributes, children_1);
	                            nodeMarks.set(node, mark); // Store for merging
	                            children_1 = [node];
	                        }
	                    });
	                }
	                inlineChildren.push.apply(inlineChildren, children_1);
	            }
	        });
	        // Merge marks to optimize
	        inlineChildren = mergeChildren$1(inlineChildren);
	        var lastChild = inlineChildren[inlineChildren.length - 1];
	        if (!inlineChildren.length || (lastChild && (lastChild.name === 'br' || (inlineChildren.length === 1 && isDecoratorEmbed(lastChild))))) {
	            inlineChildren.push(BR);
	        }
	        var block = blocks.findByAttributes(attributes);
	        if (!block)
	            block = blocks.getDefault();
	        blockData.push([block, inlineChildren, attributes]);
	    });
	    // If a block has optimize=true on it, vdom will be called with all sibling nodes of the same block
	    var blockChildren = [];
	    var collect = [];
	    blockData.forEach(function (data, i) {
	        var block = data[0], children = data[1], attr = data[2];
	        var component = getComponent$1(block.name);
	        if (component && component.rendersMultiple) {
	            collect.push([attr, children]);
	            var next = blockData[i + 1];
	            if (!next || next[0] !== block) {
	                var children_2 = component(collect);
	                blockChildren = blockChildren.concat(children_2);
	                collect = [];
	            }
	        }
	        else if (component) {
	            var node = component(attr, children);
	            blockChildren.push(node);
	        }
	    });
	    return blockChildren;
	}
	/**
	 * Converts a delta object into an HTML string based off of the supplied Paper definition.
	 */
	function deltaToHTML(delta, paper) {
	    return childrenToHTML(deltaToVdom(delta, paper).children);
	}
	// Joins adjacent mark nodes
	function mergeChildren$1(oldChildren) {
	    var children = [];
	    oldChildren.forEach(function (next, i) {
	        var prev = children[children.length - 1];
	        if (prev && typeof prev !== 'string' && typeof next !== 'string' && nodeMarks.get(prev) &&
	            nodeMarks.get(prev) === nodeMarks.get(next) && deepEqual$5(prev.attributes, next.attributes)) {
	            prev.children = prev.children.concat(next.children);
	        }
	        else {
	            children.push(next);
	        }
	    });
	    return children;
	}
	// vdom node to HTML string
	function nodeToHTML(node) {
	    var attr = Object.keys(node.attributes)
	        .reduce(function (attr, name) {
	        return attr + " " + escapeHtml(name) + "=\"" + escapeHtml(node.attributes[name]) + "\"";
	    }, '');
	    var children = childrenToHTML(node.children);
	    var closingTag = children || !VOID_ELEMENTS[node.name] ? "</" + node.name + ">" : '';
	    return "<" + node.name + attr + ">" + children + closingTag;
	}
	// vdom children to HTML string
	function childrenToHTML(children) {
	    if (!children || !children.length)
	        return '';
	    return children.reduce(function (html, child) { return html + (child.name ? nodeToHTML(child) : escapeHtml(child).replace(/\xA0/g, '&nbsp;')); }, '');
	}
	function isDecoratorEmbed(node) {
	    return node.name === 'span' && node.attributes["class"] && node.attributes["class"].indexOf('decorator');
	}

	var SOURCE_API$2$1 = 'api';
	var SOURCE_USER$2$2 = 'user';
	/**
	 * Triggers before each render inside an editor transaction. Respond to this event to add decorations (span elements
	 * with the provided attributes at the given ranges).
	 *
	 * @event View#decorate
	 */
	/**
	 * Triggers right before the view renders the latest contents to the DOM. May pass a change event if the render is
	 * triggered by an editor change.
	 *
	 * @event View#rendering
	 */
	/**
	 * Triggers when the view renders the latest contents to the DOM. May pass a change event if the render is
	 * triggered by an editor change.
	 *
	 * @event View#render
	 */
	/**
	 * Triggers on a keydown event, calling listeners with the keydown event and a shortcut string. These shortcut strings
	 * will contain all the modifiers being pressed along with the key. Examples are:
	 * Ctrl+B, Ctrl+Shift+Tab, Alt+A, Enter, Shift+Enter, Cmd+Enter, Cmd+Backspace, Space, Tab, Ctrl+Shift+Alt+F11, Ctrl++
	 *
	 * In addition to the normal modifiers, Cmd, Ctrl, Alt, and Shift, a special modifier called Mod can be used to match
	 * Cmd on Mac and Ctrl on other OSes. This allows Mod+B to be used for bold and work correctly on all systems.
	 *
	 * You can listen for all shortcuts using the "shortcut" event, or you can listen for a specific shortcut using
	 * "shortcut:{shortcut}".
	 *
	 * @event View#shortcut
	 * @event View#shortcut:{shortcut} E.g. "shortcut:Mod+Bold"
	 */
	/**
	 * The Typewriter View displays and Editor's contents and selection. The contents are displayed as HTML using a tiny
	 * virtual dom implementation and Paper to describe the HTML. The selection is displayed with the native browser
	 * selection.
	 *
	 * View also sends changes to the editor using contenteditable and a mutation observer to capture text entry, keyboard
	 * shortcuts to capture other types of edits, and the native selectionchange event to update selection.
	 */
	var View = /** @class */ (function (_super) {
	    __extends$5(View, _super);
	    /**
	     * Create a new View to display an Editor's contents.
	     *
	     * @param {Editor} editor  A Typewriter editor this View will display the contents for
	     * @param {Object} options Options include:
	     *   @param {HTMLElement} root   The root HTML element of this view. If not provided, you must append view.root to the
	     *                               DOM yourself
	     *   @param {Object} paper       The blocks, marks, embeds, and/or container to be used in this editor
	     *   @param {Object} modules     Modules which can be used with this view
	     */
	    function View(editor, paper, options) {
	        if (options === void 0) { options = {}; }
	        var _this = _super.call(this) || this;
	        if (!editor)
	            throw new Error('Editor view requires an editor');
	        _this.editor = editor;
	        _this.root = options.root || document.createElement('div');
	        if (!options.root)
	            _this.root.className = 'typewriter-editor';
	        _this.paper = paper;
	        _this.enable();
	        _this._settingEditorSelection = false;
	        _this._settingBrowserSelection = false;
	        _this.modules = {};
	        _this.options = options;
	        _this.decorators = null;
	        _this.init();
	        return _this;
	    }
	    /**
	     * Returns whether or not the view has browser focus.
	     *
	     * @returns {Boolean} Whether the view has focus
	     */
	    View.prototype.hasFocus = function () {
	        var selection = this.root.ownerDocument.getSelection();
	        return selection.anchorNode && this.root.contains(selection.anchorNode);
	    };
	    /**
	     * Focuses the view using the last known selection.
	     */
	    View.prototype.focus = function () {
	        if (this.lastSelection)
	            this.editor.setSelection(this.lastSelection);
	        else
	            this.root.focus();
	    };
	    /**
	     * Removes focus from the view.
	     */
	    View.prototype.blur = function () {
	        this.root.blur();
	    };
	    /**
	     * Disables view text entry and key shortcuts.
	     */
	    View.prototype.disable = function () {
	        this.enable(false);
	    };
	    /**
	     * Enables (or disables) view text entry and key shortcuts.
	     *
	     * @param {Boolean} enabled Whether to make it enabled or disabled, default being true
	     */
	    View.prototype.enable = function (enabled) {
	        if (enabled === void 0) { enabled = true; }
	        this.enabled = enabled;
	        this.root.contentEditable = enabled;
	    };
	    /**
	     * Get the position and size of a range as it is displayed in the DOM relative to the top left of visible document.
	     * You can use `getBounds(editor.selection)` to find the coordinates of the current selection and display a popup at
	     * that location.
	     *
	     * @param {Number} from The start of the range
	     * @param {Number} to   The end of the range
	     * @returns {DOMRect}   A native DOMRect object with the bounds of the range
	     */
	    View.prototype.getBounds = function (from, to) {
	        var range = this.editor._normalizeRange(from, to);
	        range = this.editor.getSelectedRange(range);
	        return getBounds$2(this.root, this.paper, range);
	    };
	    /**
	     * Get all positions and sizes of a range as it is displayed in the DOM relative to the top left of visible document.
	     * This is different from `getBounds` because instead of a single bounding box you may get multiple rects such as when
	     * the selection is split across lines. You can use `getAllBounds` to draw a highlight behind the text within this
	     * range.
	     *
	     * @param {Number} from The start of the range
	     * @param {Number} to   The end of the range
	     * @returns {DOMRectList}   A native DOMRect object with the bounds of the range
	     */
	    View.prototype.getAllBounds = function (from, to) {
	        var range = this.editor._normalizeRange(from, to);
	        range = this.editor.getSelectedRange(range);
	        return getAllBounds(this.root, this.paper, range);
	    };
	    /**
	     * Get the HTML text of the View (minus any decorators). You could use this to store the HTML contents rather than
	     * storing the editor contents. If you don't care about collaborative editing this may be easier than storing Deltas.
	     *
	     * @returns {String} A string of HTML
	     */
	    View.prototype.getHTML = function () {
	        return deltaToHTML(this.editor.contents, this.paper);
	    };
	    /**
	     * Set a string of HTML to be the contents of the editor. It will be parsed using Paper so incorrectly formatted HTML
	     * cannot be set in Typewriter.
	     *
	     * @param {String} html A string of HTML to set in the editor
	     * @param {*} source    The source of the change being made, api, user, or silent
	     */
	    View.prototype.setHTML = function (html, source) {
	        this.editor.setContents(deltaFromHTML(this, html), source);
	    };
	    /**
	     * Re-render the current editor state to the DOM.
	     */
	    View.prototype.render = function (changeEvent) {
	        var contents = decorate$1(this.root, this.editor.contents);
	        var vdom = deltaToVdom(contents, this.paper);
	        this.root.dispatchEvent(new Event('rendering'));
	        renderChildren(vdom, this.root);
	        if (this.hasFocus())
	            this.updateBrowserSelection();
	        this.root.dispatchEvent(new Event('render'));
	    };
	    /**
	     * Update the browser's selection to match the editor's selection.
	     */
	    View.prototype.updateBrowserSelection = function () {
	        var _this = this;
	        if (this._settingEditorSelection)
	            return;
	        this._settingBrowserSelection = true;
	        this.setSelection(this.editor.selection);
	        setTimeout(function () { return _this._settingBrowserSelection = false; }, 20); // sad hack :(
	    };
	    /**
	     * Update the editor's selection to match the browser's selection.
	     *
	     * @param {String} source The source of the selection change, api, user, or silent
	     */
	    View.prototype.updateEditorSelection = function (source) {
	        if (source === void 0) { source = SOURCE_API$2$1; }
	        if (this._settingBrowserSelection)
	            return this._settingBrowserSelection = false;
	        var range = this.getSelection();
	        // Store the last non-null selection for restoration on focus()
	        if (range)
	            this.lastSelection = range;
	        this._settingEditorSelection = true;
	        this.editor.setSelection(range, source);
	        this._settingEditorSelection = false;
	        // If the selection was adjusted when set then update the browser's selection
	        if (!shallowEqual$5(range, this.editor.selection))
	            this.updateBrowserSelection();
	    };
	    /**
	     * Get the mapped editor range from the current browser selection.
	     *
	     * @returns {Array} A range (or null) that represents the current browser selection
	     */
	    View.prototype.getSelection = function (nativeRange) {
	        return getSelection$2(this.root, this.paper, nativeRange);
	    };
	    /**
	     * Set's the browser selection to the given range.
	     *
	     * @param {Array} range The range to set selection to
	     */
	    View.prototype.setSelection = function (range) {
	        var currentRange = getSelection$2(this.root, this.paper);
	        if (!shallowEqual$5(currentRange, range)) {
	            setSelection$1(this.root, this.paper, range);
	        }
	    };
	    /**
	     * Initializes the view, setting up listeners in the DOM and on the editor.
	     */
	    View.prototype.init = function () {
	        var _this = this;
	        // already inited
	        if (this.hasOwnProperty('uninit'))
	            return;
	        var onSelectionChange = function () {
	            _this.updateEditorSelection(SOURCE_USER$2$2);
	        };
	        var onEditorChange = function (event) {
	            if (event.change)
	                _this.render(event);
	            _this.updateBrowserSelection();
	        };
	        this.root.ownerDocument.addEventListener('selectionchange', onSelectionChange);
	        this.editor.on('editor-change', onEditorChange);
	        if (this.options.modules) {
	            Object.keys(this.options.modules).forEach(function (key) { return _this.modules[key] = _this.options.modules[key](_this.editor, _this.root, _this.paper); });
	        }
	        this.render();
	        this.uninit = function () {
	            _this.root.ownerDocument.removeEventListener('selectionchange', onSelectionChange);
	            _this.editor.off('editor-change', onEditorChange);
	            Object.keys(_this.modules).forEach(function (key) {
	                var api = _this.modules[key];
	                if (api && typeof api.onDestroy === 'function')
	                    api.onDestroy();
	                delete _this.modules[key];
	            });
	            delete _this.uninit;
	        };
	    };
	    /**
	     * Cleans up the listeners on the DOM and editor after they have been added.
	     */
	    View.prototype.uninit = function () {
	        // This is overwritten inside `init`
	    };
	    /**
	     * Clean up and allow modules to clean up before the editor is removed from the DOM.
	     */
	    View.prototype.destroy = function () {
	        this.uninit();
	        this.fire('destroy');
	    };
	    return View;
	}(EventDispatcher$5));

	/* src/VDom.svelte generated by Svelte v3.0.0-beta.21 */

	function create_fragment$j(ctx) {
		var div1, div0, t0, p, em0, t1, t2, br, t3, em1, t4, t5_value = outputBox$1(ctx.selectionBox), t5;

		return {
			c() {
				div1 = internal_13("div");
				div0 = internal_13("div");
				t0 = internal_16();
				p = internal_13("p");
				em0 = internal_13("em");
				t1 = internal_15("Selection: ");
				t2 = internal_15(ctx.selection);
				br = internal_13("br");
				t3 = internal_16();
				em1 = internal_13("em");
				t4 = internal_15("Box: ");
				t5 = internal_15(t5_value);
				div0.className = "typewriter-editor svelte-1bj00ke";
				div1.className = "container svelte-1bj00ke";
			},

			m(target, anchor) {
				internal_7(target, div1, anchor);
				internal_6(div1, div0);
				internal_62(() => ctx.div0_binding(div0, null));
				internal_6(div1, t0);
				internal_6(div1, p);
				internal_6(p, em0);
				internal_6(em0, t1);
				internal_6(em0, t2);
				internal_6(p, br);
				internal_6(p, t3);
				internal_6(p, em1);
				internal_6(em1, t4);
				internal_6(em1, t5);
			},

			p(changed, ctx) {
				if (changed.items) {
					ctx.div0_binding(null, div0);
					ctx.div0_binding(div0, null);
				}

				if (changed.selection) {
					internal_31(t2, ctx.selection);
				}

				if ((changed.selectionBox) && t5_value !== (t5_value = outputBox$1(ctx.selectionBox))) {
					internal_31(t5, t5_value);
				}
			},

			i: internal_81,
			o: internal_81,

			d(detaching) {
				if (detaching) {
					internal_8(div1);
				}

				ctx.div0_binding(null, div0);
			}
		};
	}

	function outputBox$1(box) {
	if (!box) return null;
	return `left: ${box.left}, top: ${box.top}, width: ${box.width}, height: ${box.height}`;
	}

	function instance$h($$self, $$props, $$invalidate) {
		

	let { editor, paper, modules } = $$props;

	let root;
	let view;
	let selection = editor.selection;
	let selectionBox = null;

	editor.on('selection-change', () => { const $$result = selection = editor.selection; $$invalidate('selection', selection); return $$result; });

	async function updateBox(selection) {
	  await svelte_7$1();
	  selectionBox = selection ? view.getBounds(selection[0], selection[1]) : null; $$invalidate('selectionBox', selectionBox);
	}

		function div0_binding($$node, check) {
			root = $$node;
			$$invalidate('root', root);
		}

		$$self.$set = $$props => {
			if ('editor' in $$props) $$invalidate('editor', editor = $$props.editor);
			if ('paper' in $$props) $$invalidate('paper', paper = $$props.paper);
			if ('modules' in $$props) $$invalidate('modules', modules = $$props.modules);
		};

		$$self.$$.update = ($$dirty = { selection: 1, editor: 1, paper: 1, root: 1, modules: 1 }) => {
			if ($$dirty.selection) {
				updateBox(selection);
			}
			if ($$dirty.editor || $$dirty.paper || $$dirty.root || $$dirty.modules) {
				if (editor && paper && root) {
	      view = new View(editor, paper, { root, modules }); $$invalidate('view', view);
	    }
			}
		};

		return {
			editor,
			paper,
			modules,
			root,
			selection,
			selectionBox,
			div0_binding
		};
	}

	class VDom extends internal_101 {
		constructor(options) {
			super();
			internal_100(this, options, instance$h, create_fragment$j, internal_90, ["editor", "paper", "modules"]);
		}

		get editor() {
			return this.$$.ctx.editor;
		}

		set editor(editor) {
			this.$set({ editor });
			internal_63();
		}

		get paper() {
			return this.$$.ctx.paper;
		}

		set paper(paper) {
			this.$set({ paper });
			internal_63();
		}

		get modules() {
			return this.$$.ctx.modules;
		}

		set modules(modules) {
			this.$set({ modules });
			internal_63();
		}
	}

	/* src/App.svelte generated by Svelte v3.0.0-beta.21 */

	function create_fragment$k(ctx) {
		var div, p0, button0, t1, button1, t3, p1, t19, p2, t43, h30, t45, t46, h31, t49, current, dispose;

		var frame0 = new Frame({
			props: {
			component: VDom,
			editor: ctx.editor,
			paper: ctx.paper,
			modules: ctx.modules
		}
		});

		var frame1 = new Frame({
			props: {
			component: Svelte,
			editor: ctx.editor,
			paper: ctx.paper,
			modules: ctx.svelteModules
		}
		});

		return {
			c() {
				div = internal_13("div");
				p0 = internal_13("p");
				button0 = internal_13("button");
				button0.textContent = "Populate";
				t1 = internal_15(" | ");
				button1 = internal_13("button");
				button1.textContent = "Clear";
				t3 = internal_16();
				p1 = internal_13("p");
				p1.innerHTML = `<span class="category svelte-5nzocr">Keyboard shortcuts:</span><br>
			    <strong>Headers (1-6 &amp; 0)</strong>: <code class="svelte-5nzocr">Ctrl+1</code>,
			    <strong>Undo</strong>: <code class="svelte-5nzocr">Ctrl+Z</code>,
			    <strong>Indent List</strong>: <code class="svelte-5nzocr">Tab</code> / <code class="svelte-5nzocr">Shift+Tab</code>`;
				t19 = internal_16();
				p2 = internal_13("p");
				p2.innerHTML = `<span class="category svelte-5nzocr">Text entry:</span><br>
			    <strong>Bullet List</strong>: <code class="svelte-5nzocr">* </code> / <code class="svelte-5nzocr">- </code>,
			    <strong>Ordered List</strong>: <code class="svelte-5nzocr">1._</code> / <code class="svelte-5nzocr">a._</code> / <code class="svelte-5nzocr">i._</code> / <code class="svelte-5nzocr">5._</code>,
			    <strong>Headers 1-6</strong>: <code class="svelte-5nzocr">#_</code> / <code class="svelte-5nzocr">##_</code>`;
				t43 = internal_16();
				h30 = internal_13("h3");
				h30.textContent = "Virtual DOM Renderer";
				t45 = internal_16();
				frame0.$$.fragment.c();
				t46 = internal_16();
				h31 = internal_13("h3");
				h31.innerHTML = `Svelte Renderer <small>(experimental)</small>`;
				t49 = internal_16();
				frame1.$$.fragment.c();
				p1.className = "help svelte-5nzocr";
				p2.className = "help svelte-5nzocr";
				h30.className = "svelte-5nzocr";
				h31.className = "svelte-5nzocr";
				div.className = "container svelte-5nzocr";

				dispose = [
					internal_18(button0, "click", ctx.populate),
					internal_18(button1, "click", ctx.clear)
				];
			},

			m(target, anchor) {
				internal_7(target, div, anchor);
				internal_6(div, p0);
				internal_6(p0, button0);
				internal_6(p0, t1);
				internal_6(p0, button1);
				internal_6(div, t3);
				internal_6(div, p1);
				internal_6(div, t19);
				internal_6(div, p2);
				internal_6(div, t43);
				internal_6(div, h30);
				internal_6(div, t45);
				internal_99(frame0, div, null);
				internal_6(div, t46);
				internal_6(div, h31);
				internal_6(div, t49);
				internal_99(frame1, div, null);
				current = true;
			},

			p(changed, ctx) {
				var frame0_changes = {};
				if (changed.VDom) frame0_changes.component = VDom;
				if (changed.editor) frame0_changes.editor = ctx.editor;
				if (changed.paper) frame0_changes.paper = ctx.paper;
				if (changed.modules) frame0_changes.modules = ctx.modules;
				frame0.$set(frame0_changes);

				var frame1_changes = {};
				if (changed.Svelte) frame1_changes.component = Svelte;
				if (changed.editor) frame1_changes.editor = ctx.editor;
				if (changed.paper) frame1_changes.paper = ctx.paper;
				if (changed.svelteModules) frame1_changes.modules = ctx.svelteModules;
				frame1.$set(frame1_changes);
			},

			i(local) {
				if (current) return;
				frame0.$$.fragment.i(local);

				frame1.$$.fragment.i(local);

				current = true;
			},

			o(local) {
				frame0.$$.fragment.o(local);
				frame1.$$.fragment.o(local);
				current = false;
			},

			d(detaching) {
				if (detaching) {
					internal_8(div);
				}

				frame0.$destroy();

				frame1.$destroy();

				internal_88(dispose);
			}
		};
	}

	function instance$i($$self, $$props, $$invalidate) {
		

	const editor = new Editor();
	const paper = getDefaultPaper();
	const modules = {
	  shortcuts: shortcuts(),
	  input: input(),
	  history: history(),
	  keyShortcuts: keyShortcuts(),
	  smartEntry: smartEntry(),
	  smartQuotes: smartQuotes(),
	  placeholder: placeholder('Write here...'),
	  hoverMenu: hoverMenu(),
	  highlightAs: (editor, root) => {
	    const exp = /the/ig;
	    function onDecorate(event) {
	      const decorators = event.detail;
	      const text = editor.getText();
	      let match;
	      while ((match = exp.exec(text))) {
	        decorators.mark(exp.lastIndex - match[0].length, exp.lastIndex, { class: 'highlight' });
	      }
	    }
	    root.addEventListener('decorate', onDecorate);
	    return {
	      onDestroy() {
	        root.removeEventListener('decorate', onDecorate);
	      }
	    }
	  }
	};
	const svelteModules = { ...modules, input: input({ forceTextUpdates: true }) };

	// Let the CSS get created so it will add to the iframes
	let menu = new HoverMenu({
	  target: document.body
	});
	menu.$destroy();
	menu = null; $$invalidate('menu', menu);

	function populate() {
	  editor.setContents(editor.delta([
	    { insert: 'The Two Towers' },
	    { insert: '\n', attributes: { header: 1 } },
	    { insert: 'Aragorn sped on up the hill.\n' },
	    { insert: 'Gandalf', attributes: { bold: true } },
	    { insert: ' the ', attributes: { bold: true, italic: true } },
	    { insert: 'Grey', attributes: { italic: true } },
	    { insert: '\n' },
	    { insert: 'asdf123' },
	    { insert: '\n', attributes: { list: 'bullet' } },
	    { insert: 'asdf' },
	    { insert: '\n', attributes: { list: 'ordered', indent: 1 } },
	    { insert: { image: 'https://uploads-ssl.webflow.com/5c3e4c64d1dbdf089664a286/5c3e841bb511dcf520fcc2cd_cabin-sm.jpg', width: 400, alt: 'Cabin' },
	      attributes: { link: 'https://github.com/typewriter-editor/typewriter/' } },
	    { insert: '\n' },
	  ]), 'user');
	}

	function clear() {
	  editor.setContents(editor.delta(), 'user');
	}

		return {
			editor,
			paper,
			modules,
			svelteModules,
			populate,
			clear
		};
	}

	class App extends internal_101 {
		constructor(options) {
			super();
			internal_100(this, options, instance$i, create_fragment$k, internal_90, ["editor"]);
		}

		get editor() {
			return this.$$.ctx.editor;
		}
	}

	var app = new App({
	    target: document.body
	});

	return app;

}());
//# sourceMappingURL=bundle.js.map
